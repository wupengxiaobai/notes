## 场景应用

### 微信登录

已有的互联网产品在接入小程序会面临一些和登录态相关的问题, 怎么获取微信登录态, 怎么把账号和自己的账号打通. **如何把微信登录应用到小程序中**

![54649235910](C:\Users\Administrator\AppData\Local\Temp\1546492359108.png)

#### 1. 获取微信登录凭证

登录, 我们正常想到一个做法: 通过 `wx.login` 直接拿到微信用户的 id 编号, 将这个 id 传到自己的后台, 从而知道哪个微信用户在使用我们的服务. 

如我们相想法, 带来的安全问题很大. 假设我们有一个接口, 通过 `wx.request` 请求 `https://test/com/getUserInfo?id=1` 拉取到微信用户id 为 1 在我们业务侧的个人信息, 如此黑客可以通过遍历所有 id, 把整个业务侧的个人信息数据全部拉走, 如果我们还有其他接口也是依赖这样方式实现, 黑客就可以伪装成任意身份来操作任意账户下的数据.

威哥规避这样的风险, `wx.login` 是生成一个带有时效性的凭证, 就像一个会过期的临时身份证一般, 在 `wx.login` 调用时, 先在微信后台生成一张临时身份证, 有效时间 5 分钟. 然后这个临时身份证会返回给小程序, 这个临时的身份证就是 **微信登录凭证 code**, 如果5分钟内小程序后台拿不到这个临时身份证来微信后台服务器换取微信用户id, 那么这个身份证就会作废, 需要再次调用 `wx.login` 重新生成登录凭证

由于 临时身份证5分钟有效, 如果黑客冒充一个用户, 则必须在5分钟内穷举所有身份证id, 然后去开发者服务器换取真实的用户身份. 显然, 黑客要付出非常大的成本才能获取一个用户信息, 同时, 开发者服务器也可以通过一些技术手段检测5分钟内频率从某个 ip 发送过来的登录请求, 从而拒绝掉这些请求.

```js
wx.login({
    success(res) {
        console.log(res.code)	//	081VzFNT0ajzNZ1OqTOT0AYhNT0VzFN4
    }
})
```

#### 2. 发送code到开发者服务器

在 `wx.logn` 的成功回调中拿到微信登录凭证, 紧接着会通过 `wx.request` 把 **登录凭证code** 传到开发者服务器, 为了后续可以换取微信用户身份id. 如果当前微信用户还没有绑定当前小程序业务的身份, 那在这次请求应该顺便把输入的账号密码一起传到后台, 然后开发者服务器局可以校验账号密码之后在和微信用户id进行绑定.

```js
wx.login({
    success(res) {
        if(res.code) {
            wx.request({
                url: "https://test.com/login",	//	开发者服务器地址
                data: {
                    username: '小白',	
                    password: 'password',
                    code: res.code	//	登录凭证
                },
                success(res) {
                    //	请求成功回调
                    if(res.statusCode === 200) {
                        console.log(res.data.sessionId)	//	服务器返回的 sessionId
                    } else {
                      console.log('获取登录态 sessionId失败')  
                    }
                }
            })
        }
    }
})
```

#### 3. 到微信服务器换取微信用户身份id

开发者的服务器就拿到了之前 `wx.login()` 生成的 **微信登录凭证 code**, 此时就可以拿着这个 code 到微信服务器换取微信用户身份, 微信用户为了确保拿 code 过来换取身份的人就是刚刚对应的小程序开发者, 到微信服务器的请求要求同时带上 **AppId** 和 **AppSecret**, 这两个信息在小程序管理平台的开发设置界面可以看到, 由此看出 AppId 和 AppSecret 时微信鉴别开发者身份的重要信息, AppId 是公开信息, 泄露 AppId 不会带来安全风险, 但是 AppSecret 是开发者的隐私数据不应该泄露, 如果发现泄露需要小程序管理平台进行重置 AppSecret, 而code在成功换取一次信息之后也会立即失效, 即便凭证code 生成时间还未过期

开发者服务器和微信服务器通信也是通过 HTTPS 协议, 微信服务器提供的接口地址是

```
https://api.weixin.qq.com/sns/jscode2session?appid=<AppId>&secret=<AppSecret>&js_code=<code>&grant_type=authorization_code
```

URL 的 query 部分的参数中 <AppId> <AppSecret> <code> 就是请求数据, 请求参数合法, 借口就会返回以下字段

- **openid** 微信用户唯一标识
- **session_key** 会话密钥
- **unionid**  用户在维修开放平台的唯一标识符, 本字段满足一定条件下才返回

`openid` 就是微信用户id, 可以用这个 id 来区分不同的微信用户. `session_key` 则是微信服务器给开发者服务器颁发的身份凭证, 开发者额可以使用 `session_key` 请求微信服务器其他接口来获取一些其他信息, 由此可以看到, `session_key`  不应该泄露或者下发到小程序前端

可能我们会好奇为什么要设计 `session_key`, 如果我们每次都通过小程序前端 `wx.login()` 生成微信凭证code去微信服务器请求信息, 步骤太多造成整体耗时比较严重, 因此对于一些比较可信的服务端, 给开发者颁发一个时效性更长的会话密钥就可以很有必要, `session_key` 也存在过期时间.

#### 4. 绑定微信用户身份id和业务用户身份

业务侧用户还没有绑定微信身份时, 会让用户填写业务侧的用户名密码, 这两个值会和微信登录凭证一起请求开发者服务器的登录接口, 此时开发者后台通过校验用户名和密码就拿到了业务侧的用户身份id, 通过 `code` 到微信服务器获取微信侧的用户身份 `openid`, 微信会建议开发者把这两个信息对应关系存起来, 我们称之为 绑定.

有了这个绑定信息, 小程序在下次需要用户登录的时候就可以不再输入账号密码, 通过 `wx.login()` 获取到 code 之后, 可以拿到用户的微信身份 `openid`, 通过绑定信息就可以查出业务侧用户身份id, 这样静默授权的登录方式显得非常便捷.

#### 5. 业务登录凭证 SessionId

微信侧返回 `session_key` 是开发者服务器和我先服务器的会话密钥, 同样道理, 开发者服务器和开发者的小程序也应该有会话密钥, 即 `SessionId`, 用户登录成功之后, 开发者服务器需要生产密钥 `SessionId`, 在服务端保持 `SessionId` 对应的用户身份信息, 同时把返回给小程序, 小程序后续发起请求中携带 `SessionId`, 开发者服务器就可以通过服务器端的 `Session` 信息查询到当前登录用户的身份, 这样我们就不需要每次重新获取 code, 省去了很多通讯消耗. 在之后利用本地数据缓存能力把 `SessionId` 存储起来, 以便在未过期的时候重复利用, 以提高通讯的性能.

### 本地数据缓存

本地数据缓存是微信小程序存储在当前设备硬盘上的数据, 笨的你数据缓存有非常多的用途, 我们可以通过本地数据缓存, 来存储用户在小程序上产生的操作, 在用户关闭小程序重新打开时可以恢复之前的状态. 我们还可以利用本地缓存依稀而服务端非实时的数据提高小程序获取数据的速度, 在特定场景下可以提高页面加载速度, 减少用户的等待时间

#### 读取本地数据缓存

小程序提供了镀锡而本地数据缓存的接口, 通过  `wx.getStorage/wx.getStorageSync` 读取本地缓存, 通过 `wx.setStorage/wx.setStorageSync` 写数据到缓存中.

```js
wx.getStorage({
    key: 'key1',
    success(res) {
        //	异步接口在success回调中拿取返回值
        res.data
    },
    fail() {
        console.log('接口调用失败')
    },
    complete() {
        console.log('接口调用结束')
    }
})

//	同步操作代码示例
try {
    var value = wx.getStorageSync('key1')
    } catch(e) {
        console.log('读取key1失败')
    }
```

#### 缓存限制和隔离

小程序宿主环境会管理不同小程序的数据缓存, 不同小程序的本地缓存空间是分开的, 每个小程序上限 10MB, 如果超过, 再通过 `wx.setStorage()` 写入缓存则直接触发 fail 回调

小程序的本地缓存不仅仅通过小程序这个维度来隔离空间, 考虑到同一个设备可以登录不同的微信服务, 宿主环境还对不同用户缓存进行隔离, 避免用户间的数据隐私泄露

由于本地缓存时存放在当前设备, 用户换设备后无法从另一个设备读取到当前设备数据, 因此用户的关键信息不建议只存在本地缓存, 应该把数据放到服务器端进行持久化存储

#### 利用本地缓存提前渲染界面

讨论一个需求: 我们要实现一个购物商场的小程序, 首页是展示一堆商品列表, 一般的实现方法就是在首页 `onLoad` 回调之后通过 `wx.request` 向服务器发起一个请求拉取首页购物车的商品列表数据, 等待 `wx.request` 的 success 回调之后把数据通过 `wx.setData` 渲染到界面

```js
onLoad() {
    var _this = this;
    wx.request({
        url: 'https://test.com/getproductlist',
        success(res) {
            if(res.statusCode === 200) {
                _this.setData({
                    list: res.data.list
                })
            }
        }
    })
}
```

设想当用户退出小程序再进来, 界面仍会出现白屏现象, 因为我们需要等待拉取商品列表的请求回来才能渲染列表, 当然我们还可以做一些体验优化, 请求前 loading提示用户加载数据, 者并没有解决延迟渲染现象, 如此我们可以利用本地缓存提前渲染界面.

我们在拉去商品列表后把列表存在本地缓存中, 在 `onLoad` 发起请求前, 先检查是否有缓存过列表, 如果有直接渲染界面, 然后等到 `wx.request` 的回调之后再覆盖本地缓存重新渲染新的列表

```js
onLoad(){
    var _this = this;
    var list = wx.getStorageSync('list');	//	读取本地缓存 list 数据
    
    if (list) {
        _this.setDta({
            list
        }) 
    }
    
    wx.request({
        url: 'https://test.com/genproductlist',
        success(res){
            if(res.statusCode === 200){
                list = res.data.list
                _this.setData({
                    list
                })
                wx.setStorage({
                    key: 'list',
                    data: list
                })
            }
        }
    })
}
```

这种做法可以让用户体验你的小程序时感觉加载非常快, 但是要注意这个做法的缺点, 如果小程序对渲染的数据实时性要求非常高的话, 用户看到一个旧数据的界面会非常困惑, 因此一般在对数据实时性, 一致性要求不高的页面才去这个方法来做提前渲染, 用于优化小程序体验.

#### 缓存用户登录态 SessionId

在处理用户登录态的一般方法. 通常用户在没有主动退出登录前, 用户的登录态会一直保存一段时间, 无需用户频繁地输入账号密码

如果我们把 `SessionId` 记录在 JavaScript 中某个内存变量, 当用户关闭小程序时, 之前内存的 `SessionId` 已经丢失, 此时我们就需要利用本地缓存的能力来持久化存储 `SessionId`

```js
//	page.js
var app = getApp();
Page({
    onLoad() {
        //	调用 wx.login 获取微信登录凭据
        wx.login({
            success(res) {
                //	拿到凭证, 发送code给服务器
                wx.request({
                    url: 'https://text.com/login',
                    data: {
                        code: res.code
                    },
                    success(res) {
                        var data  = res.data;
                        //	将 SessionId 存储到全局和本地缓存
                        app.globalData.sessionId = data.sessionId;
                        wx.setStorage({
                            key: 'SESSIONID',
                            data: data.sessionId
                        })

                        //	将登录态有效时间存储杜鳌全局和本地存储
                        var expiredTime = +new Data() + 1*24*60*60*1000;
                        app.globalData.expiredTime = expiredTime;
                        wx.setStorage({
                            key: 'EXPIREDTIME',
                            data: expiredTime
                        })
                    }
                })
            }
        })
    }
})
```

在重新打开小程序的时候, 我们把上一次存储的 SessionId 内容取出来, 恢复到内存

```js
//	app.js
App({
    onLaunch(options) {
        var sessionId = wx.getStorageSync('SESSIONID');
        var expiredTime = wx.getStorageSync('EXPIREDTIME');
        var now = +new Date();
        
        if(now - expiredTime <= 0) {
            this.globalData.sessionId = sessionId;
            this.globalData.expiredTime = expiredTime;
        }
    },
    globalData: {
        sessionId: null,
        expiredTime: 0
    }
})
```

### 设备能力

我们知道 PC的程序和手机的程序有很大的体验不一样的地方, 尤其在信息输入这个体验上差别非常大, PC端可以有键盘, 鼠标等外设来辅助用户输入很多复杂的信息, 而用户要在手机屏幕上输入复杂信息的效率是很低的, 小程序的宿主环境提供了非常多的操作设备能力来帮助用户在特定场景下做高效的输入, 例如: 扫码, 操控蓝牙等能力. 当前也有很多设备能力不是为了解决输入低效问题而设计的, 它们更多的是解决用户侧一些体验问题, 例如获取设备网络状态, 调整屏幕亮度等

#### 利用微信扫码能力

为了让用户减少输入, 我们可以把复杂的信息编码成一个二维码, 利用宿主环境 `wx.scanCode` 这个 API 调起微信扫一扫, 用户扫码之后, `wx.scanCode` 的 success回调会接收到这个二维码所对应的字符串信息.

比如餐厅点餐小程序, 我们给餐厅中每个餐桌编号 1-100 号, 把这个数字编码到二维码中, 扫码获得编号后,就可以知道哪一桌点的菜, 大大提高点餐体验和效率.

```js
//	点击 "扫码订餐" 按钮, 触发 tapScan 回调
tapScan() {
	//	调用 wx.login 获取微信登录凭证
    wx.scanCode({
        success(res) {
            var num = res.result
        }
    })
}
```

还有很多场景尅结合微信扫码能力做到很好的体验, 比如通过扫商品上的一维码做一个商品展示小程序, 通过扫共享单车二维码去开启单车, 我们如何利用扫码能力去替代一些繁琐的输入操作, 让我们小程序变得更加便捷.

## 小程序的协调工作和发布

### 用户体验审视

#### 体验和设计评估

在小程序的设计和开发阶段, 开发者始终将优秀的用户体验作为产品目标之一, 通过积极地用户体验评估, 在不断的迭代中完善体验, 用心打磨小程序, 从而更好地实现产品价值, 激发用户正向情感

开发者依据9点基础设计原则, 对小程序体验进行评估

1. 导航清晰

2. 流程明确

   为了让用户能够顺畅的使用小程序, 用户进行操作时, 应确定当前页面只设置了单一任务, 且不出现目标流程以外的内容, 这样有利于让用户明确当前操作的目的, 从而集中精力聚焦当前任务, 并通过操作达到结果.

3. 重点突出

   每个页面都有应该有明确的重点, 以便于用户进入一个新页面时能够快速理解页面内容, 子啊确定过重点的前提下, 尽量避免页面上出现其他与用户的决策和操作无关的干扰因素

4. 符合预期

   对用户友好的产品, 需要在其设计阶段便将自身信息架构和模型与用户的心理模型匹配, 以便于用户能够依据以往的使用经验或其他生活经验, 奖励使用的理解和学习成本, 达到使用目的

5. 等待和反馈

   在用户使用产品时, 往往页面过长事件的等待会引起不良情绪, 在不得不需要用户以一定记载等待时间作为代价, 我们需要明确的等待状态告知用户, 以舒缓用户在等待时期的不良情绪

   设计加载等待状态时, 注意以下操作:

   |载入等待时间过长, 提供取消操作, 并使用进度条显示加载进度

   |载入过程中, 保持动画效果, 无动画效果的加载容易让人产生界面卡死错觉

   |不要再同一个页面同时使用超过1个加载动画

6. 异常处理

   再设计任务和流程时, 而往往用户会因为各种原因导致操作失败, 此类异常场景往往是用户最为沮丧和需要班助的时候, 因此注意在异常状态下的设计

   除去模态框等提醒方式, 表单项较多的页面中, 应该明确指出出错项目, 以便用户修改

7. 内容和文案准确友好

   在产品通过文案或者页面表达内容时, 需要斟酌使用的内容和文案, 使用的语言应当简洁礼貌并容易被用户理解. 此外注意专业术语需要被清楚解释, 特有词汇全局需要统一的特定表达, 重要内容能够被快速获取, 且页面不存在无关文案干扰用户决策

8. 和谐统一

   小程序内的设计风格应该统一, 和谐且具有延续性的, 这样才能确保用户建立完整的产品品牌认知, 更好的辨析不同的小程序

9. 平台适配

   在小程序的设计过程中, 应该充分考虑 IOS 和 Android, 平台设计规范, 对设计进行适当调整

#### 用户体验测试和完善测试

1. 用户体验测试, 可以在设计, 开发, 测试等全部阶段使用.
2. 京造进行用户体验测试, 在产品设计过程中, 尚未启动开发时, 便可以低保真/高保真模型进行用户体验测试, 以检测设计质量.这样更有利于急躁发现问题并进行调整, 减少开发成本
3. 用户测试之前需要确定好需要被检测的流程的任务, 需要为用户构建明确的目标, 并提示用户完成任务的方式完成目标
4. 最好选择产品真实受众, 作为测试用户
5. 设计开放性的问题让用户回答, 不用带主观性询问语言, 引导用户回答
6. 在此用户测试过程中, 需要全程做好记录

### 发布

#### 发布前最后的检查

不少开发者再发布小程序后发现正式版小程序无法正常启动, 以下是开发者发布前常遗漏的点:

1. 如果小程序使用到 Flex 布局, 并且需要兼容 iOS 以下系统时, 要检查上传小程序包时, 开发者工具是否开启 "上传代码时样式自动补全"
2. 小程序使用的服务器接口应该走 HTTPS 协议. 并且对于的网络域名确保已经在小程序管理平台配置好
3. 在测试阶段不要打开小程序的调试模式进行测试, 因为在调试模式下, 微信不会校验域名合法性, 容易导致开发者误以为测试通过, 导致正式版小程序因为遇到非法域名无法正常工作
4. 发布前检查小程序使用网络接口已经在线部署好, 并且评估好服务器的机器负载情况

当体验版进行充分的检查和测试后达到发布状态, 项目管理者可以在小程序平台进行提交审核的操作, 提交审核后, 微信审核团队会根据相关运营桂发进行提审小程序的审核, 通过之后, 管理者可以随时发布自己的小程序

#### 发布模式

小程序提供了两种发布模式: 全量发布和分阶段发布. 全量发布是指当点击发布之后, 所有用户访问的小程序时都会使用当前最新发布的版本. 分阶段发布是指分不同的时间段来控制部分用户使用最新的发布版本. 一般来说, 普通小程序发布时采用全量发布即可, 当小程序承载的功能越来越多, 使用的用户越来越多时,采用分阶发布是一个规避风险的一个好办法. 新版本的代码改动可能会带来 BUG , 作为服务方不希望
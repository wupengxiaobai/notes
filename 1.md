## 插件

插件的开发和使用

插件是一组 js 接口, 自定义组件或页面的封装, 用于嵌入到小程序中使用, 插件不能独立运行, 必须嵌入在其他小程序中才能被用户使用, 而第三方小程序在使用插件时, 也无法看到插件代码, 因此, 插件适合用来封装自己的功能或服务, 提供给第三方小程序进行展示和使用.

插件开发者可以像开发小程序一样编写一个插件并上传代码, 在插件发布之后, 其他小程序方可调用. 小程序平台会托管插件代码, 其他小程序调用时, 上传的插件代码会跟随小程序一起下载运行

相比普通的 js 文件或自定义组件, 插件拥有更大的独立性, 拥有独立的 API 接口, 域名列表等, 但同时会受到一些限制, 如一些API 无法调用或功能受限, 还有个别特殊的接口, 虽然插件不能直接调用, 但可以使用插件功能页来间接实现

同时, 框架会对小程序和小程序使用的每个 插件进行数据安全保护, 保证它们之间不能切取其它任何一方的数据(除非数据被主动传递给另一方)

### 使用插件

**添加插件**

在使用插件前, 首先要在小程序管理后台的 "设置-第三方服务-插件管理" 中添加插件, 开发者可登录小程序管理后台, 通过 appId 查找插件并添加, 如果插件无需申请, 添加后可直接到使用, 否则需要申请并等待插件开发者通过后, 方可在小程序中使用相应的插件.

**引入插件代码包**

使用插件前, 使用者要在 `app.json` 声明需要使用的插件, 如

```json
//	app.json
{
    "plugins": {
        'myplugin': {
            "version": "1.0.0",
            "provider": "wxidxxxxxxxxxxxxx"
        }
    }
}
```

如上例所示, `plugins` 定义段中可以包含多个插件声明, 每个插件声明以一个使用者自定义插件引用名作为标识, 并指明插件的 appid 和 需要使用的版本号, 其中, 引用名由使用者自定义, 无需和插件开发者保持一致或与开发者协调, 在后续的插件使用中, 该引用名将被用于表示该插件

**使用插件**

使用插件时, 插件的代码对于使用者来说是不可见的. 为了正确使用插件, 使用者查看详情页面中的"开发文档"一节, 阅读由插件开发者提供的插件开发文档, 通过文档来明确插件提供的自定义组件, 页面名称及提供的js接口规范等

### 功能页

某些接口不能在插件中直接调用, 如 wx.login, 插件开发者额可以使用插件功能页的方式来实现. 目前, 插件功能页包括

- 获取用户信息, 包括 openid 和 昵称等(相当于 wx.login 和 wx.getUserInfo 的功能)
- 支持 (相当于 wx.requestPayment)
- 获取收货地址 (相当于 wx.chooseAddress)

要使用插件功能页, 需要县级或功能页特性, 配置对应的功能页函数, 再使用 <functional-page-navigator> 组件跳转到插件功能页, 从而实现相对应的功能

开始之前, 我们需要知道, 插件功能页是指 **插件所有者小程序** 中的一个特殊页面

插件所有者小程序, 指的是与插件 AppID 相同的小程序, 例如, '小程序实例' 小程序开发了一个 "小程序示例插件", 那么无论这个插件被哪个小程序使用, 这个插件的 插件所欧哲小程序 都是 '小程序示例'

**激活功能页特性**

要在插件中调用插件功能页, 需要先激活插件所有者小程序的功能页特性. 具体来说, 在插件所有者小程序的 app.json 中添加 `functionalPages` 定义段, 为 `true`

**跳转功能页**

功能页不能使用 `wx.navigateTo` 来进行跳转, 而是需要 <functional-page-navigator> 组件, 以获取用户信息为例, 

## 基础能力

### **网络**

在小程序中使用网络相关 API 时, 需要注意下列问题

1. 服务器域名配置

   每个微信小程序需要事先设置一个通讯域名, 小程序只可以跟指定的域名进行网络通信, 包括普通的 HTTPS 请求(wx.request), 上传文件(wx.uploadFile), 下载文件(wx.downloadFile) 和 WebSocket 通信(wx.connectSocket)

   **配置流程**

   服务器域名在 [小程序后台- 开发- 开发设置- 服务器域名] 中进行配置, 配置时需要注意

   - 域名只支持 `https` (wx.request, wx.uploadFile, wx.downloadFile) 和 `wss` (wx.connectSocket) 协议
   - 域名不能使用 IP 地址或 localhost;
   - 域名必须经过 ICP 备案
   - 出于安全考虑, api.weixin.qq.com 不能被配置为服务器域名, 相关 API 也不能在小程序内调用, 开发者应该将 appsecret 保存到后台服务器中, 通过服务器使用 appsecret 获取 accesstoken, 并调用相关 api
   - 对于每个接口, 分别可以配置最多 20 个域名

2. 网络请求

   超时时间 默认60s, 超时时间可以在 app.json 中设置

   使用限制

   - 网络请求的 `referer` header 不可设置. 其格式固定为 `https://servicewechat.com/{appid}/{version}/page-frame.html`, 其中 `{appid}` 为小程序的 `appid`, {version} 为小程序的版本号, 0 表示开发版, 体验版以及审核版本, 版本号为 `devtools` 表示为开发者工具, 其余为正式版
   - `wx.request` `wx.uploadFile` `wx.downloadFile` 的最大并发限制是 10 个
   - 小程序进入后台后, 非指定聊天, 如果 5s 内网络请求没有结束, 会回调错误信息 `fail interrupted` 在回到前台之前, 网络请求接口都无法调用

   返回值编码

   - 只要成功接收到服务器返回, 无论 `statusCode` 是多少, 都会进入 `success` 回调. 开发者根据业务逻辑对返回值进行判断

3. 常见问题

   HTTPS 证书

   小程序必须使用 HTTPS/WSS 发起网络请求, 请求时系统会对服务器域名使用的 HTTPS 证书进行校验, 如果校验失败, 则请求不能发送成功, 由于系统限制, 不同平台对于证书的要求的严格程度不同, 为了保证小程序的兼容性, 建议开发者按照最高标注进行证书配置, 并使用相关工具检查现有证书是否符合要求

   对证书要求如下

   - HTTPS 证书必须有效:
     - 证书必须被系统信任, 即根证书被系统内中
     - 部署的 SSL 证书的网站域名必须与证书颁发域名一致
     - 证书必须在有效期内
     - 证书的信任链必须完整(需要服务器配置)

   - ISO 不支持自签名证书
   - ISO 下证书必须满足苹果 App Transport Security 的要求

   跳过域名检验

   在微信开发者工具中, 可以临时开启 开发环境不校验请求域名, TLS 版本及 HTTPS 证书 选项, 跳过服务器域名的校验, 此时, 在微信开发者工具中及手机开启调试时, 不会进行服务器域名的检验

   在服务器域名配置成功后, 建议开发者关闭跳过该检验

##### 局域网通信

基础库 2.4.0 提供了 `wx.startLocalServiceDiscovery` 等系系列 mDNS API , 可以哟来获取局域网内提供的 mDNS 服务的设备 的 IP. 

`wx.request` 等的 url 参数允许为 `${IP}:${POST}/${PATH}` 的格式, 当且仅当 IP 与手机 IP处于同一网段, 且不与本机 IP 相同时, 请求/连接才会成功. 这种情况下, 不会进行安全域的额检验, 不要求必须使用 http/wss 也可以使用 http/ws

```js
wx.request({
    url: 'http://10.9.176.40:828'
    // 省略其他参数
})
```

### 存储

每个微信小程序都有可以有自己的本地存储, 可以通过 `wx.setStorage` `wx.getStorage` `wx.clearStorage` `wx.removeStorage`  对本地缓存进行读写操作

同一个微信用户, 同一个小程序 storage 上限为 10 MB, storage 以用户未读隔离, 同一台设备上, A用户无法读取 B用户的数据

注意: 如果用户存储空间不足, 我们会清空最近最久未使用的小程序本地缓存, 我们不建议将关键信息全部存在 storage, 以防止存储空不足或用户换设备的情况.

### 文件系统

文件系统是小程序提供的一套以我笑傲程序和用户维度隔离的存储以及一套相应的管理接口, 通过 `wx.getFileSystemManager()` 可以获取到去拿局唯一的文件系统管理器, 所有文件系统的管理操作通过 `fileSystemManager` 来调用

```js
const fs = wx.getFileSystemManager()
```

文件主要分为两大类

- **代码包文件**: 在目录项目目录中添加的文件

- **本地文件**: 通过调用接口本地产生, 或通过网络下载来, 存储到本地的文件.

本地文件分为三种:

1. 本地临时文件: 临时产生, 随时会被回收的文件, 不限制存储大小
2. 本地缓存文件: 小程序通过接口把本地临时文件缓存后产生的文件, 不能自定义目录和文件名, 除非用户主动删除小程序, 否则不会被删除, 跟本地哟惊呼文件共计, 普通小程序最多可存储 10 MB
3. 本地用户文件: 小程序通过接口把本地临时文件缓存后产生的文件, 允许自定义目录和文件名, 除非用户主动删除小程序, 否则不会被删除. 跟本地用户文件共计, 普通小程序最多存储 10MB

##### **代码包文件**

由于代码包文件大小限制, 代码包文适用于放置首次加载时需要的文件, 对于内容较大或需要动态替换的文件, 不推荐用添加到代码包中.

**访问代码包文件**

代码包文件的访问方式是从项目根目录开始写文件路径, 不支持相对路径的写法

**修改代码包文件**

代码包内的我呢间无法在运行后动态修改或删除, 修改代码包文件需要重新发布版本

##### **本地文件**

本地文件指的是小程序被用户添加到手机后, 会有一块独立的文件存储㻃, 以用户维度隔离, 即同一台手机, 每一个微笑用户不能访问到其他登录用户的文件, 同一个用户不同 appid 之间文件也是不能相互访问

本地文件的文件均为以下格式

{{协议名}}://文件路径

**本地临时文件**

本地临时文件只能通过调用特定接口产生, 不能直接写入内容. 本地临时文件产生后, 仅在当前生命周期内有效, 重启逆之后即不可用. 因此, **不可以把本地临时文件路径存储起来下次使用**. 如如果需要下次使用, 通过 FileSystemManger.saveFile() 或 FileSystemManager.copyFile() 接口把本地临时文件转换成本地缓存文件或本地用户文件.

```js
wx.chooseImage({
    success(res){
        const tempFilePaths = res.tempFilePaths	//	tempFilePaths 的每一项是一个本地临时文件路径
    }
})
```

**本地缓存文件**

本地缓存文件只能通过接口调用特定的接口产生, 不能直接写入内容. 本地缓存文件产生后, 重启之后仍可用. 本地缓存文件只能通过 FileSystemManager.saveFile() 接口将本地临时文件保存获得.

示例:

```js
fs.saveFile({
    tempFilePath: '',	//	传入一个本地临时文件
    success(res) {
        console.log(res.savedFilePath)	//	res.savedFilePath 作为一个本地缓存文件路径
    }
})
```

注意: 本地缓存文件是最初的设计 提供了功能更完整的本地文件, 可以完全覆盖本地缓存文件的功能

**本地用户文件**

本地用户是从`1.7.9` 版本开始新增的概念, 我们提供了一个用户文件目录给开发者, 开发者对这个目录有完全自由的读写权利. 通过 `wx.env.USER_DATA_PATH` 可以虎丘到这个目录的路径

```js
const fs = wx.getFileSystemManager()
fs.writeFileSync(`${wx.env.USER_DATA_PATH}/hello.txt`, 'heelo, world', 'utf8')
```

**读写权限**

| 接口、组件   | 读   | 写   |
| ------------ | ---- | ---- |
| 代码包文件   | 有   | 无   |
| 本地临时文件 | 有   | 无   |
| 本地缓存文件 | 有   | 无   |
| 本地用户文件 | 有   | 有   |

### 画布

**Canvas** 画布

所有在 `canvas` 中的图画必须使用 JavaScript 完成

WXML 

```js
//	wxml
<canvas canvas-id="myCanvas" style="border: 1px solid;" />

//	js
const ctx = wx.createCanvasContext('myCanvas')
ctx.setFillStyle('red')
ctx.fillRect(10,10,150,75)
ctx.draw()
```

第一步: 创建一个 Canvas 绘图上下文

首先, 我们需要创建一个 Canvas 绘图上下文 CanvasContext

CanvasContext 是小程序内建的一个对象, 有一些绘图的方法

```js
const ctx=wx.createCanvasContext('myCanvas')
```

第二步: 使用Canvas 绘图上下文进行绘图描述

接着, 我们来描述在Canvas 中绘制什么内容

设置绘图上下文填充色为红色

```js
ctx.setFillStyle('red')
```

用 `fillRect(x, y, width, height)` 方法绘制一个矩形, 填充为刚刚才设置的红色

```js
ctx.fillRect(10, 10, 150, 75)
```

第三步: 画图

告诉 `<canvas>` 组件你要将刚刚的描述绘上去

```js
ctx.draw()
```

**坐标系**

canvas 是一个在二维网格中, 左上角坐标为 `(0, 0)`

我们使用 `fileRect()` 方法

含义是从左上角 `(0, 0)` kaish8i, 画一个 `150*75 px` 的矩形

代码示例

我们可以在<canvas> 中加上一些事件, 来观测他的坐标系

```html
<canvas 
        canvas-id="myCanvas"
        style="margin: 5px; border:1px solid #ddd"
        bindtouchstart="start"
        bindtouchend="end"
        />

<view hidden="{{hidden}}">Coordinates: ({{x}}, {{y}})</view>
```

```js
Page({
    data: {
        x: 0,
        y: 0,
        hidden: true
    },
    start(e) {
        this.setData({
            hidden: false,
            x: e.touches[0].x,
            y: e.touches[0].y
        })
    },
    move(e){
        this.setData({
            x: e.touches[0].x,
            y: e.touches[0].y
        })
    },
    end(e){ 
        this.setData({
            hidden: true
        })
	}
})
```

**渐变**

渐变能用于填充一个 矩形, 圆, 线, 文字等. 填充色可以不固定

我们提供了两种颜色渐变方式

- `createLinearGradient(x, y, x1, y1)` 创建一个线性渐变
- `createCircularGadient(x, y, r)` 创建一个从圆心开始的渐变

一旦我们创建了一个渐变对象, 我们必须添加两个颜色渐变点

`addColorStop(postion, color)` 方法用于指定颜色渐变点的位置和颜色, 位置必须位于 0-1 之间

可以用`setFillStyle` 和 `setStrokeStyle` 方法设置渐变, 然后进行画圆描述

使用 `createLinearGradient()`

```js
const ctx = wx.createCanvasContext('myCanvas')
const grd = ctx.createLinearGradient(0, 0, 200, 0)
grd.addColorStop(0, 'red')
grd.addColorStop(1, 'write')

ctx.setFillStyle(grd)
ctx.fillRect(10, 10, 150, 80)
ctx.draw()

```

### 分包加载

某些情况下, 开发者需要将小程序划分成不同的子包, 在构建时打包成不同的分包, 用户使用时按需进行加载

在构建小程序分包项目时, 构建会输出一个或多个分包. 每个分包小程序必定含一个主包. 所谓的主包, 即放置默认启动页面/TabBar页面, 以及一些所有分包都必须用到的公共资源/JS脚本; 而分包则根据开发者额的配置进行划分

在小程序启动时, 默认会下载主包并启动主包内的页面, 当用户进入分包内某个页面, 客户端会把对应分包下载, 下载完成进行展示

目前小程序分包大小有以下限制:

- 整个小程序所有分包大小不超过 8M

- 单个分包/主包大小不能超过 2M

对小程序进行分包, 可以优化小程序首次启动的下载时间, 以及在多团队共同开发时可以更好的解耦协作

##### 使用分包

**配制方法**

假设支持分包的小程序目录结构如下

```
├── app.js
├── app.json
├── app.wxss
├── packageA
│   └── pages
│       ├── cat
│       └── dog
├── packageB
│   └── pages
│       ├── apple
│       └── banana
├── pages
│   ├── index
│   └── logs
└── utils
```

开发者通过在 app.json `subpackages` 字段声明项目分包结构

```json
{
    "pages": ["pages/index", "pages/logs"],
    "subpackages": [
        {
            "root": "packageA",
            "pages": ["pages/cat", "pages/dog"]
        },
        {
            "root":"packageB",
            "name":"pack2",
            "pages": ["pages/apple","pages/banana"]
        }
    ]
}
```

`subpackages` 中, 单个分包的配置有以下几项

- root 分包根目录
- name 分包别名, 分包预下载时可以使用
- pages 分包的页面路径, 相对分包根目录
- independent 分包是否是独立分包

**打包原则**

- 声明 `subpackages` 后, 将按 `subpackage` 配置路径进行打包, `subpackages` 配置路径外的目录将被打包到 `app` (主包) 中
- app (主包) 也可以由自己的 pages (最外层的pages 字段)
- `subpackage` 的根目录不能是另外一个 `subpackage` 内的子目录
- `tabBar` 页必须在 app (主包) 内

**引用原则**

- `packageA` 无法 require `packageB` 的JS 文件, 但是可以 require `app`, 自己的 package 内的 JS 文件
- `packageA`  无法 import `packageB` 的 `template`, 但可以 import  `app` , 自己 package 内 的 template
- `packageA` 无法使用 `packageB` 的资源, 但是可以使用 `app`, 自己的 package 内的资源

**低版本兼容**

由于微信后台编译来处理旧版本的客户端的兼容, 后台会编译两份代码包, 一份是分包后代码, 另外一份是整包的兼容代码, 新客户端用分包, 老客户端还是用整包, 完整包会把各个 `subpackage` 里面的路径放到 pages 中.

##### 独立分包

独立分包是小程序中一种特殊类型的分包, 可以独立与主包和其它分包运行. 从独立分包中的页面进入小程序时, 不需下载主包, 当用户进入普通分包或主包内页面时, 主包才会被下载.

开发者可以按需将某些具有一定功能的独立性的页面配置到独立分包中, 当小程序从普通的分包项目启动时, 需要首先下载主包; 而毒瘤分包不依赖主包即可运行. 可以很大程度提升分包页面启动速度

一个小程序中可以有多个分包.

**配置方法**

假设小程序目录结构如下

```
├── app.js
├── app.json
├── app.wxss
├── moduleA
│   └── pages
│       ├── rabbit
│       └── squirrel
├── moduleB
│   └── pages
│       ├── pear
│       └── pineapple
├── pages
│   ├── index
│   └── logs
└── utils
```

开发者可以在 `app.json` 的 `subpackages` 字段中对应的分包中定义 `independent` 字段声明对应包为独立分包

```json
{
    "pages": ["pages/index", "pages/logs"],
    "subpackages": [
        {
            "root": "moduleA",
            "pages": ["pages/rabbit", "pages/squirrel"]
        },
        {
            "root": "moduleA",
            "pages": ["pages/pear", "pages/pineapple"],
            "independent": true
        }
    ]
}
```

独立分包属于分包的一种, 普通分包的所有限制都对独立分包有效.. 独立分包中插件, 自定义组件的处理方式同普通分包.

此外,  使用独立分包时要注意

- 独立分包中不能依赖主包和其他分包中的内容, 包括 js , template , wxss, 自定义组件, 插件等, 主包中的 app.wxss 对独立分包无效, 应避免在独立分包中使用 app.wxss 中的样式
- app 只能在主包内定义, 独立分包中不能定义 app
- 独立分包中暂不支持使用插件

**注意事项**

1. 关于 getApp()

   与普通分包不同, 独立分包运行时, App 不一定被注册, 因此 getApp() 也不一定可以获得 App 对象

   - 当用户从独立分包页面启动小程序时, 主包不存在, App 也不存在, 此时调用 getApp() 获取到的是 `undefined`, 当用户进入普通分包或主包页面时, 主包才会被瞎子啊, App 才会被注册
   - 当用户是从普通分包或主包内页面内跳转到独立分包页面时, 主包已经存在, 此时掉用 getApp() 可以获得真正的 App

   由于以上限制, 开发者无法通过 APP 对象实现独立分包和小程序其它不部分的全局变量共享

   为了在独立分包中满足这一需求, 基础库2.2.4 版本开始 getApp  支持 allowDefault 参数, 在 App 未定义时返回一个默认实现, 当主包加载,  App 被注册, 默认实现中定义的属性会被覆盖合并到真正的 App 中

   示例代码

   - 独立分包中

   ```js
   const app = getApp({allowDefault: true})
   app.data = 456
   app.global= {}
   ```

   - app.js中

   ```js
   App({
       data: 123,
       other: 'hello'
   }),
   console.log(getApp()) //	{global: {}, data: 456, other: 'hello'}
   ```

2.关于 App 的生命周期

​	当从独立分包启动小程序时, 主包中 App 的 `onLaunch` 和 首次 `onShow` 会从独立分包页面首次进入主包或其它分包页面时调用. 由于独立分包中无法定义 app, 小程序生命周期函数的监听可以使用 `wx.onAppShow`, `wx.onAppHide` 完成. App 上的其他事件可以使用 `wx.onError` `wx.onPageNotFound` 监听

在兼容模式下, 主包中的 app.wxss 可能灰度独立分包中的页面产生影响, 一次你应该避免在独立分包中使用 app.wxss 中的样式

##### 分包预下载

开发者可以通过配置, 在进入小程序某个页面时, 由框架自动预下载可能需要的分包, 提升进入后续分包页面时的启动速度. 对于独立分包, 也可以预下载主包

分包预下载目前只支持通过配置方式使用, 暂不支持通过API完成

**配制方法**

预下载分包行为在进入某个页面时触发, 通过在 `app.json` 增加 `preloadRule` 配置来控制

```json
{
    "pages": ["pages/index"],
    "subpackages": [{
        "root": "sub1",
        "pages": ["index"]
    },{
        "root": "sub2",
        "pages": ["index"]
    },{
        "root": "sub3",
        "pages": ["index"],
      	"independent": true
    }],
    "preloadRule": {
        "pages/index": {
            "network": "all",
            "packages": [""]
        },
        "sub1/index": {
          "packages": ["hello", "sub3"]
        }
    }
}
```

`preloadRule` 中, `key` 是页面路径, `vcalue` 是进入此页面的预下载配置, 每个配置有以下几项

- packages: 进入页面后预下载分包的 `root` 或 `name`
- network: 指定网洛预下载 all/wifi

**限制**

同一个分包中的页面共享有共同的预下载带小限额 2M, 限额会在工具中打包时校验.

页面A 和 B 都在同一个分包中, A 中下载总代小为 0.5M的分包, B中最多只能预下载 1.5M 的分包

### 多线程 Worker

一些异步处理的惹怒, 可以放置于 Worker 中运行, 带运行结束后, 再把结果返回给小程序主线程. Worker 运行于一个单独的全局上下文与线程中, 不能直接调用主线程的方法

Worker 与主线程之间的数据传输, 双方使用 Worker.postMessage() 来发送数据, Worker.onMessage() 来接收数据, 传递的数据并不是直接共享的, 而是吧被复制的.

**使用线程**

1. 配置 Worker 信息

   在 `app.json` 中可配置 `Worker` 代码放置的目录, 目录下的代码将被打包成一个文件

   配置示例:

   ```json
   {
       "workers": "workers"
   }
   ```

2. 添加 Worker 代码文件

		根据步骤 1 中的配置, 在代码目录下新建以下两个入口文件

```
workers/request/index.js
workers/request/utils.js
workers/response/index.js
```

​	添加后, 目录结构如下:

```
├── app.js
├── app.json
├── project.config.json
└── workers
    ├── request
    │   ├── index.js
    │   └── utils.js
    └── response
        └── index.js
```

3. 编写 Worker 代码

   在 `workers/request/index.js` 编写 Worker 响应代码

   ```js
   const utils= require('./utils')
   //	在 Worker 线程中执行上下文会全局暴露一个 worker 对象, 直接调用 worker.onMessage/postMessage 即可
   worker.onMessage(function(res){
       console.log(res)
   })
   ```

4. 在主线程中初始化 Worker

   ```js
   const worker = wx.createWorker('workers/request/index.js')	//	文件制定 worker 的入口文件路径, 绝对路径
   ```

5. 主线程向 Worker 发送消息

   ```js
   worker.postMessage({
       msg: 'hello worker!'
   })
   ```

**注意事项**

- Worker 最大并发数量限制为 1 个, 创建下一个前请用 Worker.teerminate() 结束当前 Worker
- Worker 内代码只能 require 指定 Worker 路径内的文件, 无法引用其他路径
- Worker 内的入口文件由 wx.createWorker() 时指定, 开发者课动态指定 Worker 入口文件
- Worker 内不支持 wx 系列 API
- Workers 之间不支持发送消息

## 硬件能力

### 蓝牙

蓝牙适配器模块生效周期为调用 `wx.openBluetoothAdapter` 至调用 `wx.closeBluetoothAdapter` 或小程序被销毁位置.

在小程序蓝牙适配器模块期间, 开发者才能正常调用蓝牙相关小程序API, 并收到蓝牙模块相关的事件回调

注意

- 系统限制, Android 上获取到的 `deviceId` 为设备 MAC 地址, IOS 上则无设备uuid. 因此 `deviceId` 不能硬编码到代码中.

**低功耗能蓝牙 (BLE) 注意事项**

- ios 上对特征值的 `read`, `write`, `notify	` 操作, 由于系统需要获取特征值实例, 传入的 `serviceId` 与 `characteristicId` 必须由 `wx.getBLEDeviceServices` 与`wx.getBLEDeviceCharacteristic` 中获取到后才能使用. 建议双平台统一在建立连接后先执行 `wx.getBLEDeviceServices` 与 `wx.getBLEDeviceCharacteristics` 后再进行与蓝牙设备的数据交互

### NFC

暂只支持 HCE (基于主机的卡模拟) 模式, 即将安卓手机模拟成实体智能卡.

- 适用机型: 支持 NFC 功能, 且系统为5.0+
- 适用卡范围: 符合 ISO 14443-4 标准的 CPU 卡

### Wi-Fi

在小程序中支持搜索周边的 Wi-Fi, 同时可以针对指定 Wi-Fi, 传入密码发起连接.

该系列接口为系统原生能力

注意

- Wi-Fi 相关接口暂不可用 `wx.canIUse` 接口判断.
- Android 6+ 版本, 在没有打开定位开关的时候会导致设备不能正常获取周边 Wi-Fi 信息.

## 开放能力

### 用户信息

##### 小程序登录

小程序可以通过微信官方提供的登录能力方便地虎丘微信提供的用户身份标识, 快速建立小程序内的用户体系

**登录流程时序**

![1546352529492](.\wx\1546352529492.png)

说明: 

1. 调用 `wx.login()` 获取 零时登录凭证 code, 并回传到开发者服务器
2. 调用 `code2Session` 接口. 换取 **用户唯一标识 OpenID ** 和 **会话密匙 session_key**.

之后开发者服务器可以根据用户标识来生成自定义登录态, 用于后续业务逻辑中前后端交互时识别用户身份

**注意**

1. 会话密钥 `session_key` 是对用户数据进行 `加密签名` 的密钥, 为了应用自身数据安全, 开发者 **不应该把会话密匙下发到小程序, 也不应该对外提供这个密钥** 
2. 临时登录凭证 code 只能使用一次

##### UnionID 机制说明

如果开发者拥有多个移动应用, 网站应用 和公众账号 (包括小程序), 可通过 UnionID 来区分用户的唯一性, 因为只要是同一个微信开放平台账号下的移动应用, 网站应用和公众账号, 用户的 UnionID 是唯一的. 换句话说, 同一用户, 对同一个微信开放平台下的不同应用, unionid 是相同的.

**UnionID 获取途径**

绑定了开发者账号的小程序, 可以通过以下途径获取 UnionID.

1. 调用接口 `wx.getUserInfo`. 从解密数据中获取 UnionID, 注意本接口需要用户授权, 开发者需要妥善处理用户拒绝授权后的情况.
2. 如果开发者账号下存在 **同主体的** 公众号, 并且该用户已经关注了公众号. 开发者可以直接通过 `wx.login` + `code2Session` 获取到该用户 UnionID, 无需用户再次授权.
3. 如果开发者账号下存在 **同主体的** 公众号或移动应用, 并且该用户已经授权登录过该公众号或移动应用. 开发者也可以直接通过 `wx.login` + `code2Session` 获取到该用户 UnionID, 无需用户再次授权.
4. 用户在小程序中支付完成后, 开发者可以直接通过 `getPaidUnionid` 接口获取该用户的 UnionID, 无需用户授权. 注意本接口仅在用户支付完成后 5分钟内有效
5. 小程序端调用 `云函数` 时, 如果开发者账号下存在 **同主体** 的公众号, 并且用户已经关注了公众号, 可以在云函数中通过 `cloud.getWXContext` 获取 UnionID.
6. 小程序段调用 `云函数` 时, 如果开发者账号下存在 **同主体** 的公众号或移动应用, 并且该用户已经授权登录过该公众号或移动应用. 也可以在云函数中通过 `cloud.getWXContext` 获取 UnionID.

**微信开放平台绑定小程序流程**

登录微信开放平台 ---- 管理中心 ----- 小程序 ----- 绑定小程序

![1546354417870](.\wx\1546354417870.png)

##### 授权

部分接口需要用户授权同意后才能调用. 我们把这些接口按使用范围分成多个 `scope`, 用户选择对 `scope` 来进行授权, 当授权给一个 `scope` 之后, 其对应的所有接口都可以直接使用.

部分接口需要获得用户授权同意后才能调用. 此类接口调用时

- 如果用户未接受或拒绝过此权限, 会弹窗询问用户, 用户点击同意方可调用接口
- 如果用户已授权, 可以直接调用接口.
- 如果用户已拒绝授权, 则不会弹窗, 直接进入接口 fail 回调, 我们要兼容用户拒绝授权的场景

**获取用户授权设置**

开发者可以使用 `wx.getSetting` 获取用户当前授权状态

**打开设置界面**

用户可以在小程序设置界面([右上角] - [关于] - [右上角] - [设置] ) 中控制对该小程序的授权状态

开发者可以调用 `wx.openSetting` 打开设置界面, 引导用户开启授权.

**提前发起授权请求**

开发者可以使用 `wx.authorize` 在调用需授权 API 之前, 提前向用户发起授权请求

**Scope 列表**

| scope                  | 对应接口                                            | 描述         |
| ---------------------- | --------------------------------------------------- | ------------ |
| scope.userInfo         | wx.getUserInfo                                      | 用户信息     |
| scope.userLocation     | wx.getLocation, wx.chooseLocation                   | 地理位置     |
| scope.address          | wx.chooseAddress                                    | 通讯地址     |
| scope.invoiceTitle     | wx.chooseInvoiceTitle                               | 发票抬头     |
| scope.invoice          | wx.chooseInvoice                                    | 获取发票     |
| scope.werun            | wx.getWeRunData                                     | 微信运动步数 |
| scope.record           | wx.startRecord                                      | 录音功能     |
| scope.writePhotosAlbum | wx.saveImageToPhotosAlbum,wx.saveVideoToPhotosAlbum | 保存到相册   |
| scope.camera           | <camera /> 组件                                     | 摄像头       |

**注意事项**

1. `wx.authorize({scope: "scope.userInfo})` 不会弹出授权窗口, 我们需要使用 `<button open-type="getUserInfo">` 
2. 需要收取 `scope.userLocation` 时必须配置地理位置用途说明

##### 开放数据校验与解密

小程序可以通过各种前端接口获取微信提供的开放数据. 考虑到开发者服务器也需要获取这些开放数据, 微信会对这些数据做签名和加密出米.

开发者后台拿到的开放数据后可以对数据进行校验签名和解密, 来保证数据不被篡改.

![1546355965102](.\wx\1546355965102.png)

签名校验以及数据加解密涉及用户的会话密匙 `session_key` , 开发者应该事先通过 `wx.login` 登录流程获取会话密钥 `session_key` 并保存在服务器. 为了数据不被篡改, 开发者不应该把 `session_key` 传到小程序客户单等服务器外的环境.

**数据签名校验**

为了确保开放接口返回用户数据的安全性, 微信会对明文数据进行签名. 开发者可以根据业务需求对数据包进行签名校验, 确保数据的完整性.

1. 通过调用接口 (如 `wx.getUserInfo`) 获取数据时. 接口会同时返回 `rawData` `signature`, 其中 `signature=sha1(rawData + session_key)` 
2. 开发者将 `sinature`, `rawData` 发送到开发者服务器进行校验. 服务器利用用户对应的 `session_key` 使用相同算法计算出签名 `signature2`, 比对 `signature` 和 `signature2` 即可校验数据的完整性

如 `wx.getUserInfo` 的数据校验

接口返回的 rawData

```json
{
  "nickName": "Band",
  "gender": 1,
  "language": "zh_CN",
  "city": "Guangzhou",
  "province": "Guangdong",
  "country": "CN",
  "avatarUrl": "http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"
}
```

用户的 session-key

```
HyVFkGl5F5OQWJZZaNzBBg==
```

用于签名的字符串为

```
{"nickName":"Band","gender":1,"language":"zh_CN","city":"Guangzhou","province":"Guangdong","country":"CN","avatarUrl":"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"}HyVFkGl5F5OQWJZZaNzBBg==
```

使用 sha1 得到的结果为

```
75e81ceda165f4ffa64f4068af58c64b8f54b88c
```

**加密数据解密算法**

接口如果涉及敏感数据 (如 `wx.getUserInfo` 当中的 openId 和unionId), 接口的明文内容将不包括这些敏感数据. 开发者如需要获取敏感数据, 需要对接口返回的 **加密数据(encryptedData)** 进行对称解密. 解密算法如下

1. 对称解密使用算法为 `AES-128-CBA`, 数据采用 `PKCS#7` 填充
2. 对称解密的目标密文为 `Base64_Decode(encryptedData)`
3. 对称解密秘钥 `aeskey = Base64_Decode(session_key)`, aeskey 是 16字节.

4. 底层解密算法初始向量为 `Base64_Decode(iv)` 其中 iv 由数据接口返回

微信官方提供了多种编程语言的示例代码, 每种语言类型的接口名字均一致, 调用方式可以参照示例

另外,为了应用能校验数据有效性, 会在敏感数据加上数据水印(watermark)

watermark参数说明

- appid 敏感数据归属 appId, 开发者可校验此参数与自身 appId 是否一致
- timestamp 敏感数据获取的时间戳, 开发者可以用于数据时效性校验

如接口 `wx.getUserInfo` 敏感数据当中的 `watermark`

```json
{
    "openId": "OPENID",
    "nickName": "NICKNAME",
    "gender": GENDER,
    "city": "CITY",
    "province": "PROVINCE",
    "country": "COUNTRY",
    "avatarUrl": "AVATARURL",
    "unionId": "UNIONID",
    "watermark": {
        "appid": "APPID",
        "timestamp": TIMESTAMP
    }
}
```

注: 解密后得到的 json 数据根据需求可能会增加新字段, 旧字段不会改变和删减, 开发者需要预留足够空间

**会话密钥 session_key 有效性**

开发者如果遇到因为 sesion_key 不正确而校验签名失败或解密失败, 请关注 下面几个与 session_key 有关的注意事项

1. `wx.login` 调用时, 用户 `session_key` 可能会被更新而致使旧 `session_key` 失效(刷新机制存在最短周期, 如果同一个用户短时间内多次调用 `wx.login` 并非每次调用都导致 session_key 刷新) 开发者应该在明确需要重新登录时才调用 `wx.login` , 即使通过 `code2Session` 接口更新服务器存储的 `session_key`
2. 微信不会把 `session_key` 的有效期告知开发者, 我们会根据用户使用小程序的行为对 `session_key` 进行续期, 用户越频繁使用小程序, `session_key` 有效期越长
3. 开发者在 `session_key` 失效时, 可以通过重新执行登录流程获取有效 `session_key`, 使用借口 `wx.checkSession` 可以校验 `session_key` 是否有效, 以此避免小程序反复执行登录流程
4. 当开发者在实现自定义登录态时, 可以考虑以 `session_key` 有效期作为自身登录态有效期, 也可以实现自定义时效性策略.

##### 获取手机号码

获取微信用户绑定的手机号, 首先调用 `wx.login` 接口

因为需要用户主动触发才能发起获取手机号接口, 所以该功能不能有 API 来调用, 需要 <button> 组件点击来触发

注意: 目前该接口针对非个人开发者, 且完成了 认证的小程序开放, 若该用户举报较多或被发现在不必要场景下使用, 微信有权永久回收小程序的该接口权限

**使用方法**

需要将 <button> 组件 `open-type` 的值设置为 `getPhoneNumber`, 当用户点击并同意之后,可已通过 `bindgetphonenumber` 事件回调获取到微信服务器返回的加密数据, 然后在嗲三分服务端结合 `session_key` 以及 `app_id` 进行解密获取手机号.

**注意**

在回调中调用 `wx.login` 登录, 可能会刷新登录状态, 此时服务器使用 `code` 换取的 `sessionKey` 不是加密时使用的 `sessionKey`, 导致解密失败, 建议开发者提前进行 `login` 或在回调汇总先使用 `checkSession` 进行登录态检查, 避免 `login` 刷新登录态

示例代码

```html
<button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"></button>
```

```JS
Page({
    getPhoneNumber({detail}) {
        console.log(detail.errMsg)
        console.log(detail.iv)
        console.log(detail.encryptedData)
    }
})
```

返回参数说明

- encryptedData 包括敏感数据在内的完整用户信息的加密数据
- iv 加密算法的初始量

`encryptedData` 解密后为以下 JSON 结构

```json
{
    "phoneNumber": "13580006666",
    "purePhoneNumber": "13580006666",
    "countryCode": "86",
    "watermark": {
        "appid": "APPID",
        "timestamp": TIMESTAMP
    }
}
//	参数说明
//	phoneNumber 用户绑定的手机号
//	purePhoneNumber 没有区号的手机号
//	countryCode	区号
```

##### 生物认证

小程序通过 `SOTER` 提供以下生物认证

目前暂时只支持指纹识别认证, 设备支持的生物认证方式可使用 `wx.checkIsSupportSoterAuthentication` 查询

**流程步骤说明**

1. 调用 `wx.startSoterAuthentication` 获取 `resultJSON` 和 `resultJSONSignature`
2. (可选) 签名校验. 此处 `resultJSONSignature` 使用 `SHA256widthRSA/PSS` 作为签名算法进行验签
3. 维修提供后台接口用于可信的密钥签服务, 微信将保证该接口返回的验签结果的正确性和可靠性, 并且对于 Android root 情况下该接口具有上述特性(将返回是否保证root情况安全性)

接口地址

```
POST htto://api.weixin.qq.com/cgi-bin/soter/verify_signature?access_token = %access_token
```

post 数据内容(JSON 编码)

```json
{
    "openid": "$openid",
    "json_string": "$resultJSON",
    "json_signature": "$resultJSONSignature"
}
```

### 转发

**获取更多转发信息**

通常开发者希望转发出去的小程序被二次打开的时候能够获取到一些信息, 例如群的标识. 现在通过调用 `wx.shoShareMenu` 并且设置 `withShareTicket` 为true, 当用户将小程序转发到任意群聊之后, 此转发卡片在群聊中被其他用户打开时, 可以再 `App.onLaunch` 或 `App.onShow ` 获取到一个 `shareTicket` 通过调用 `wx.getShareInfo` 接口传入此 `shareTicket`  可以获取到转发信息

**页面内发起转发**

通过给 button 组件设置属性 `open-type="share"` 可以在用户点击按钮后触发 `Page.onShareAppMessage` 事件 , 如果当前页面没有定义该事件, 点击无效

**使用指引**

转发按钮 , 旨在帮助用户更流畅地与好友分享内容和服务. 转发, 应是用户自发的行为, 且在需要时触手可及. 开发者在使用时若遵从以下指引, 会得到更佳的用户体验

1. 含义清晰: 明确, 一目了然的图形按钮, 将为用户减少理解的时间, 在我们的资源下载中心, 可以找到这样的按钮素材并直接使用. 或者可以根据自己业务的设计风格, 灵活设计含义清晰的按钮样式. 当然, 也尅一直接使用带文案的按钮, 如"转发给好友"

- 方便点击: 按钮点击热区不宜过小, 不宜过大. 同时转发按钮与其他按钮一样, 热区不宜过密, 以免用户误操作
- 按需出现: 并非所有页面都适合放置转发按钮, 涉及用户隐私的非公开内容, 或可能打断用户完成当前操作体验的场景, 该功能不推荐使用, 同时, 由于转发过程中, 我们将截取用户屏幕图形作为配图, 因此, 需要注意帮助用户屏蔽个人信息
- 尊重意愿: 理所当然, 并非所有的用户都喜欢与朋友分享你的小程序, 因此, 他不应该成为一个诱导或强制行为, 如转发后才能解锁某项功能等. 这类做法不仅不被推荐, 还肯呢个违反我们 `<<运营规范>>` 

##### 动态消息

2.4.0+ 支持转发动态消息. 动态消息对比普通消息具备以下特点

1. 消息发出去之后, 开发案这颗已通过后台接口修改部分消息内容
2. 消息有对应提醒按钮, 用户点击提醒按钮可以订阅提醒, 开发者可以通过后台修改消息状态并推送一次提醒消息给订阅了提醒的用户

**消息属性**

动态消息, 文字内容, 文字颜色

**状态**

消息有两个状态, 分别有其对应的文字内容和颜色. 其中状态 0 可以转移到状态 0 和 1, 状态1无法再转移

- 0  "成员正在加入, 当前{member_count}/{room_limit}人"
- 1  "已开始" 

**状态参数**

每个状态转移的时候可以下带参数

- member_count 状态0时有效, 文字内容模板中的 member_count 的值
- room_limit 状态0时有效, 文字内容模板中的 room_limit 的值
- path 状态1时有效, 点击 [进入] 启动小程序时使用的路径. 可以用于传递查询字符串(query), 如` "?foo=bar"`
- version_type 状态1时有效, 点击进入启动小程序时使用的版本. 有效参数值为: `develop(开发版)` `trial(体验版)` `release(正式版)`

**使用方法**

1. 差UN关键爱你 activity_id

   每条动态消息都可以理解为一个活动, 活动发起前需要通过 `createActivityId` 接口创建 `activity_id`. 后续转发动态消息以及更新动态消息都需要传入这个 `activity_id`

   活动的默认有效值是  24h, 活动结束后 消息内容会变成统一的样式

   - 文字内容: "已结束"
   - 文字颜色: #00ff00

2. 在转发之前声明消息类型为动态消息

   通过调用 `wx.updateShareMenu` 接口, 传入 `isUpdatableMessage: true` 以及 `templateInfo`, `activityId` 参数. 其中 `activityId` 从步骤一中获得

   ```js
   wx.updateShareMenu({
       withShareTicket: true,
       isUpadatableMessage: true,
       activityId: '',	//	活动 ID
       templateInfo: [{
           name: "member_count",
           value: "1"
       },{
           name: "room_limit",
           value: '3'
       }]
   })
   ```

3.修改动态消息内容

动态消息发出去之后, 可以通过 `setUpdatableMsg` 修改消息内容

对于不支持动态消息的客户端版本, 收到动态消息后会展示成普通消息

### 打开 App

此功能需要用户主动触发才能打卡 APP, 所以不由 API 调用, 需要使用 `open-type="launchApp"` 的 <button> 组件的点击来触发

当小程序从 APP 分享消息卡片的场景打开 (场景 1036, APP分享小程序) 或从 APP 打开的场景打开时(场景1069), 小程序会获得 打开 APP 的能力, 此时用户点击阿牛可以打开分享该小程序卡片/ 拉起概小程序的 APP, 即**小程序不能打开任意 APP , 只能跳回 APP**.

在一个小程序的生命周期内, 只有再特定条件下, 财局有打开 `APP` 的能力.

当小程序从 1069 场景打开时, 可以打开 APP

当小程序从非1069场景打开时, 会在小程序框架内部管理一个状态, 为true 则可以打开 APP, 为false则不可以打开 APP, 这个状态的维护遵循以下骨子额

- 当小程序从 App 分享消息卡片(1036) 打开时
- 当小程序从以下场景打开时, 保持上一次打开小程序时打开 APP 的能力的状态
  - 从其它小程序返回小程序(1038) 
  - 小程序从聊天顶部场景 (1089) 中 [最近使用] 内打开
  - 长按小程序右上角菜单换出最近使用历史 (1090) 打开
- 当小程序从非以上场景打开时, 不具备打开 APP 的能力, 改状态置为 false

![1546428964744](C:\Users\mengbao\AppData\Roaming\Typora\typora-user-images\1546428964744.png)

**使用方法**

小程序端

需要将 <button> 组件 `open-type` 值设置为 `launchApp` 如果需要在打开 APP 时向 APP 传递参数, 可以设置 `app-parameter` 为要传递的参数, 通过 `binderror` 可以监听打开 APP 的错误事件

app 端

APP 需要接入 OpenSDK

Android 第三方 app 需要处理 `showMessageFromWX.req` 的微信回调, ios则需要将 appId 添加到第三方 app 工程所需 plist 文件 URLtypes 字段, `app-parameter` 的获取方法, 参考 [Android SDKSample](https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/WeChatSDK_sample_Android.zip) 中 WXEntryActivity 中的 onResp 方法以及 [iOS SDKSample](https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/WeChatSDK_sample_iOS_1.4.2.1.zip) 中 WXApiDelegate 中的 onResp 方法。

代码示例

```html
<button open-type="launchApp" app-parameter="wechat" binderror="launchAppError">打开 APP</button>
```

error 事件参数说说明 

- invalid scene 调用场景不正确, 即此时的小程序不具备打开 APP 的能力

### 消息

##### 模板消息

基于微信的通知渠道, 我们为开发者提供了可以高效触达用户的模板消息能力, 以便实现服务的闭环并提供更佳的体验.

- 模板推送位置: 服务通知
- 模板下发条件: 用户本人在微信体系内与页面由交互行为后触发
- 模板跳转能力: 点击查看详情仅能跳转下发模板的该账号的各个页面

**使用说明**

步骤一: 获取模板 ID

有两个方法可以获取模板 ID:

1. 通过模板消息管理接口获取模板 ID
2. 在微信公众平台手动配置获取模板 ID

登录 https://mp.weixin.qq.com 获取模板，如果没有合适的模板，可以申请添加新模板，审核通过后可使用

![1546429657372](C:\Users\mengbao\AppData\Roaming\Typora\typora-user-images\1546429657372.png)

步骤二: 页面的 <form /> 组件, 属性 `report-submit` 为 true 时, 可以声明为需要发送信息的模板消息, 此时点击按钮提交表单可以获取 `formId`, 用于发送模板消息. 或者当用户完成 支付行为, 可以获取 `prepay_id` 用于发送模板消息

步骤三: 调用接口下发消模板消息

使用效果

![1546429775060](C:\Users\mengbao\AppData\Roaming\Typora\typora-user-images\1546429775060.png)

**下发条件说明**

1. 支付

   当用户在小程序内完成支付行为, 可允许开发者向用户在 7 天内推送有限条数的模板消息(1次支付可下发3条, 多次支付下发条数独立, 互不影响)

2. 提交表单

   用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的, 开发者需要向用户提供服务时, 课允许开发者向用户在 7 天内推送有限条数的模板消息(1次提交表单可下发1条, 多次提交下发条数独立, 互不影响)

**审核说明**

1. 标题

   1. 标题不能存在相同
   2. 标题意思不能存在过度相似

   3. 标题必须以 "提醒" 或 "通知" 结尾
   4. 标题不能懈怠特殊符号等
   5. 标题必须体现服务场景
   6. 标题不能涉及营销相关内容

2. 关键词

   1. 同一个标题下, 关键词不能存在相同
   2. 同一标题下, 关键词不能过度相似
   3. 关键词不能懈怠特殊符号等
   4. 关键词内容示例必须与关键词对应匹配
   5. 关键词不能太过宽泛, 需要具有限制性

消费优惠间类, 购物返利类, 商品更新类, 优惠券类, 代金券类,...活动类等营销倾向通知

##### 统一服务消息

为便于开发者对用户进行服务消息触达, 简化小程序和公众号模板消息下发了流程, 小程序提供统一服务消息下发接口

##### 客服消息

**在页面使用客服消息**

需要将 <button> 组件 `open-type` 的值设置为 `contact`, 当用户点击后就会进入客服会话, 如果用户在会话中点击了小程序消息, 则返回到小程序, 开发者可以通过 `bindcontact` 事件回调获取用户所点消息的页面路径 `path` 和对应参数 `query` 

代码示例

```html
<button open-type="contact" bindcontact="handleContact"></button>
```

```js
Page({
    handleContact(e) {
        console.log(e.path)
        console.log(e.query)
    }
})
```

- path 小程序消息指定的路径
- query 小程序消息指定的查询参数

**后台接入消息服务**

接入微信小程序消息服务, 开发者需要按照如下步骤完成

1. 填写服务器配置
2. 验证服务器地址的有效性
3. 据接口文档实现业务逻辑

第一步: 填写服务器配置

登录小程序官网后, 在小程序逛网的 "设置- 消息服务器" 页面, 管理员扫码启用消息服务, 填写服务器地址 (URL). Token 和 EncodingAESKey

- URL 是开发者用来接收微信消息和事件的借口 URL.
- Token 可由开发者任意填写, 用作生成签名 (该 Token 会和接口 URL 中包含的 Token 进行对比, 从而验证安全性).
- EncodingAESKey 由开发者手动填写或随机生成, 将用作消息体和加密密钥

同时, 开发者可选择消息解密方式: 明文模式, 兼容模式和安全模式. 可以选择消息数据格式: XML 格式 或 JSON 格式. 加密方式的默认状态是明文格式, 而数据格式的默认状态是 XML 格式.

模式的选择与服务器配置在提交后都会立即生效, 请开发者谨慎填写及选择. 切换加密方式和数据格式需要提前配置好相关代码, 详情参考 消息加解密说明

![1546442158505](C:\Users\mengbao\AppData\Roaming\Typora\typora-user-images\1546442158505.png)

第二步: 验证消息却来自微信服务器

开发者提交信息后, 微信服务器将发送 GET 请求到填写服务器地址URL上, GET请求携带参数如下表所示

| 参数      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| signature | 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。 |
| timestamp | 时间戳                                                       |
| nonce     | 随机数                                                       |
| echostr   | 随机字符串                                                   |

开发者通过检验 `signature` 对请求进行校验, 若确定此次GET请求来自微信服务器, 请原样返回 `echostr` 参数内容, 则接入生效, 成为开发者成功, 否则将接入失败, 加密/校验流程如下

1. 将 token, timestamp, nonce 三个参数进行字典序排序
2. 将三个参数字符串拼成一个字符串进行 sha1 加密
3. 开发者获得加密后的字符串与 signature 对比, 标识该请求来源于微信

检验 `signature` 的PHP代码示例

```php
private function checkSignature()
{
    $signature = $_GET["signature"];
    $timestamp = $_GET["timestamp"];
    $nonce = $_GET['nonce'];
    
    $token = TOKEN;	//	TOKEN 常量, token
    $tmpArr = array($token, $timestamp, $nonce);
    sort($tmpArr, SORT_STRING);
    $tmpStr = implode($tmpArr);
    $tmpStr = sha1($tmpStr);
    
    if($tmpStr === $signature){
        return true;
    }else{
        return false;
    }
}
```

第三步: 依据接口文档实现业务逻辑

验证 URL 有效性成功后即接入生效, 成为开发者. 至此用户向小程序客服发送消息, 或者进入会话等情况时, 开发者填写的服务器配置URL 将得到微信服务器推送过来的消息和事件, 开发者可以依据自身业务逻辑进行响应.

另外注意: 开发者所填写的URL 必须以 `http://` 或 `https://`开头, 分别支持端口 80和 443

###### 接收消息和事件

在页面中使用 `<button open-type="contact" />` 可以显示进入客服会话按钮

当用户在客服会话发送消息(或进行某些特定的用户操作引发的事件推送时), 微信服务器会将消息(事件) 的数据包(JSON/XML) 格式 POST请求道开发者服务器, 开发者收到请求后可以使用 `发送客服消息` 接口进行异步回复.

微信服务器在将用户的消息发给小程序开发者服务器地址后, 微信服务器在五秒内收不到响应会断掉连接, 并且重新发起请求, 总共重试三次, 如果在调用中, 发现用户无法接收到响应的消息, 可以检查是否消息处理超时, 关于重试的消息拍重, 有 msgid 的消息推荐使用 msgid 排重. 事件类型消息推荐使用 FromUserName + CreateTime 排重.

服务器收到ingIQU币徐作出下述回复, 这样微信服务器才不会对此作任何处理, 并且不会发起重试, 否则将出现严重的错误提示, 详见下面说明

```
1. 直接回复 success (推荐)
2. 直接回复空串(指字符长度为0的空字符串, 而不是结构体中content字段的内容为空)
```

一旦遇到以下情况,微信都会在小程序会话中, 向用户下发系统提示 "该小程序客服暂时无法提供服务, 请稍后再试"

```
1.开发者在5秒内未回复任何内容
2.开发者恢复了异常数据
```

如果开发者希望增强安全性, 可以在开发者中心处开启消息加密, 这样用户发给小程序的消息以及小程序被动回复的消息都会继续加密

各类消息类型的推送 `JSON`  `XML`数据包结构如下

**文本消息**

用户在客服会话中发送文本消息时将产生如下数据包:

XML 格式

```xml
<xml>
   <ToUserName><![CDATA[toUser]]></ToUserName>
   <FromUserName><![CDATA[fromUser]]></FromUserName>
   <CreateTime>1482048670</CreateTime>
   <MsgType><![CDATA[text]]></MsgType>
   <Content><![CDATA[this is a test]]></Content>
   <MsgId>1234567890123456</MsgId>
</xml>
```

JSON 格式

```json
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "text",
  "Content": "this is a test",
  "MsgId": 1234567890123456
}
```

参数说明

| 参数         | 说明                |
| ------------ | ------------------- |
| ToUserName   | 小程序的原始ID      |
| FromUserName | 发送者的openid      |
| CreateTime   | 消息创建时间(整型） |
| MsgType      | 类型 text           |
| Content      | 文本消息内容        |
| MsgId        | 消息id，64位整型    |

**图片消息**

XML 格式

```xml
<xml>
      <ToUserName><![CDATA[toUser]]></ToUserName>
      <FromUserName><![CDATA[fromUser]]></FromUserName>
      <CreateTime>1482048670</CreateTime>
      <MsgType><![CDATA[image]]></MsgType>
      <PicUrl><![CDATA[this is a url]]></PicUrl>
      <MediaId><![CDATA[media_id]]></MediaId>
      <MsgId>1234567890123456</MsgId>
</xml>
```

JSON 格式

```json
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "image",
  "PicUrl": "this is a url",
  "MediaId": "media_id",
  "MsgId": 1234567890123456
}
```

| MsgType | image                                                        |
| ------- | ------------------------------------------------------------ |
| PicUrl  | 图片链接（由系统生成）                                       |
| MediaId | 图片消息媒体id，可以调用[获取临时素材]((getTempMedia)接口拉取数据。 |

**小程序卡片消息**

用户在客服会话中发送小程序卡片消息

XML 格式

```xml
<xml>
	<ToUserName><![CDATA[toUser]]></ToUserName>
	<FromUserName><![CDATA[fromUser]]></FromUserName>
	<CreateTime>1482048670</CreateTime>
	<MsgType><![CDATA[miniprogrampage]]></MsgType>
	<MsgId>1234567890123456</MsgId>
	<Title><![CDATA[Title]]></Title>
	<AppId><![CDATA[AppId]]></AppId>
	<PagePath><![CDATA[PagePath]]></PagePath>
	<ThumbUrl><![CDATA[ThumbUrl]]></ThumbUrl>
	<ThumbMediaId><![CDATA[ThumbMediaId]]></ThumbMediaId>
</xml>
```

JSON 格式

```json
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "miniprogrampage",
  "MsgId": 1234567890123456,
  "Title": "title",
  "AppId": "appid",
  "PagePath": "path",
  "ThumbUrl": "",
  "ThumbMediaId": ""
}
```

| PagePath     | 小程序页面路径        |
| ------------ | --------------------- |
| Title        | 标题                  |
| ThumbUrl     | 封面图片的临时cdn链接 |
| ThumbMediaId | 封面图片的临时素材id  |

**进入会话事件**

XML 格式

```xml
<xml>
    <ToUserName><![CDATA[toUser]]></ToUserName>  
    <FromUserName><![CDATA[fromUser]]></FromUserName>  
    <CreateTime>1482048670</CreateTime>  
    <MsgType><![CDATA[event]]></MsgType>  
    <Event><![CDATA[user_enter_tempsession]]></Event>  
    <SessionFrom><![CDATA[sessionFrom]]></SessionFrom> 
</xml>
```

JSON 格式

```json
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "event",
  "Event": "user_enter_tempsession",
  "SessionFrom": "sessionFrom"
}
```

| Event       | 事件类型，user_enter_tempsession                             |
| ----------- | ------------------------------------------------------------ |
| SessionFrom | 开发者在[客服会话按钮](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)设置的 session-from 属性 |

###### 发送客服信息

当用户和小程序客服产生特定动作的交互时, 微信将会把消息数据推送给开发者, 开发者可以在一段时间内(48小时)调用客服接口, 通过调用 `发送客服消息接口` 来发送消息给普通用户, 此接口主要用于客服等有人工消息处理环节的功能, 方便开发者为用户提供更佳优质的服务

目前允许的动作列表如下, 不同动作触发后, 允许的客服接口下发消息条数和下发时限不同

| 用户动作     | 允许下发条数限制 | 下发时限 |
| ------------ | ---------------- | -------- |
| 用户发送消息 | 5 条             | 48 小时  |

###### 转发客服消息

如果小程序设置了消息推送, 普通微信用户向小程序客服发消息时, 微信服务器会先讲消息 POST 到开发者服务器填写的 URL 上, 如果希望将消息转发到网页版客服工具, 则需要开发者在响应包中返回 MsgType 为 transfer_customer_service 的消息, 微信服务器收到响应后会把当次法搜的消息转发至客服系统

用户被客服接入以后, 客服关闭会话以前, 处于会话过程中时, 用户发送的消息均会被直接转发至客服系统. 当会话超时30分钟客服没有关闭时. 微信服务器会自动停止转发至客服, 而将消息回复发送到开发者服务器上

用户在等待队列中时, 用户发送的消息仍会被推送至开发者服务器上

这里特别注意, 只针对微信用户发来的消息才进行转发, 对于其它事件(比如用户从小程序唤起客服会话) 都不应该转发, 否则客服在客服系统上就会看到一些无意义的消息了

**消息转发到网页版客服工具**

开发者只在响应包中返回 MsgType 为 transfer_customer_service 的消息, 微信服务器接收到响应后就会把当次发送的消息转发至客服系统

```xml
<xml>
    <ToUserName><![CDATA[touser]]></ToUserName>
    <FromUserName><![CDATA[fromuser]]></FromUserName>
    <CreateTime>1399197672</CreateTime>
    <MsgType><![CDATA[transfer_customer_service]]></MsgType>
</xml>
```

| 参数         | 是否必须 | 描述                       |
| ------------ | -------- | -------------------------- |
| ToUserName   | 是       | 接收方帐号（收到的OpenID） |
| FromUserName | 是       | 开发者微信号               |
| CreateTime   | 是       | 消息创建时间 （整型）      |
| MsgType      | 是       | transfer_customer_service  |

###### 客服输入状态

开发者可以通过调用客服输入状态接口, 返回客服当前输入状态给用户

1. 此接口需要客服消息接口权限
2. 如果不满足发送客服消息的触发条件, 则无法下发输入状态

3. 下发输入状态, 需要客服之前30s内和用户有过消息交互
4. 再输入态中(15s), 不可重复下发输入态
5. 再输入状态中, 如果向用户下发消息, 会同时取消输入状态

###### 在客服消息中使用临时素材

开发者可在接受和发送客服消息的过程中获取或上传临时素材.

**获取临时素材**

接收到用户消息后, 课通过`获取临时素材接口` 获取消息中的临时素材

**上传临时素材**

通过 `上传临时素材接口` 可以上传临时素材, 并在`发送消息接口` 中使用.

### 卡卷


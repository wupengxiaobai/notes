# 数据库 MySQL 学习笔记



## 数据库分类

**网络数据库**

​	网络数据库是指把数据库技术引入到计算机网络系统中, 借助于网络技术将存储于数据库中的大量信息及时发布出去, 而计算机网络借助于成熟的数据库技术对网络中的各种数据进行有效管理, 并实现用户与网络中的数据库进行实时动态数据交互.(云存储)

**层级数据库**

​	层级结构模型的实质上是一种有根节点的定向有序树(在数学中 "数"被动另一为一个无回的连通图).

### 关系数据库

​	**关系型数据库**, 是建立在**关系模型**基础上的数据库, 借助于集合代数等数学概念和方法来处理数据库中的数据.

​	数据库的另外一种区分方式, 基于存储介质(磁盘/内存).

关系型数据库: 存储在磁盘中.

非关系型数据库: 存储在内存中.

**基本概念**

​	关系数据库, 是建立在 **关系模型** 基础上的数据库, 借助于集合代数等数学概念和方法来处理数据库中的数据.现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示. 关系模型由 **关系数据结构** **关系操作集合** **关系完整性约束** 三部分组成.

<u>关系数据结构</u>: 指的是数据以什么方式来存储, 是一种二维表的形式存储.

​	**本质: 二维表**

| 姓名 | 年龄 | 身高 | 体重 |
| :--: | :--: | :--: | :--: |
| 小白 |  18  | 170  | 120  |
| 懵宝 |  19  | 168  | 115  |

<u>关系操作集合</u>: 如何关联和管理对应的存储数据, SQL指令

```mysql
# 获取小白的年纪, 已知条件为姓名
select 年龄 from 二维表 where 姓名 = 小白;
```

<u>关系完整性约束</u>: 数据内部有对应的关联关系, 以及数据与数据之间也有对应的关联关系.

​	表内约束; 对应的具体列只能放对应数据(不能乱放)

​	表外约束: 自然界各实体都是有着对应的关联关系(外键)

**典型的关系型数据库**列举

​	小型关系型数据库: Microsoft Access, SQLite	

​	中型关系型数据库: SQL Server, MySQL

​	大型关系型数据库: Oracle, DB2

Mysql 当前跟 Oracle 是同一个公司, 其实隶属于 Oracle.



## SQL 介绍

**基本介绍**

​	**结构化查询语言(Structured Query Language)**简称 SQL, 是一种特殊目的的**编程语言**, 是一种数据库查询和程序设计语言, 用于存储数据以及**查询 更新 管理**关系数据库系统; 同时也是数据库脚本文件的扩展名. 

sql 就是专门为关系型数据库而设计出来的.

**分类**

1. 数据查询语言 (DQL: Data Query Language)

   其语句一般被称为 "数据检索语句", 用于从表中获取数据, 确定数据怎样在应用程序给出. 保留字 `SELECT` 是 `DQL` 用得最多的动词,其他 DQL 常用保留字有 `WHERE`, `ORDER BY`, `GROUP BY`, 和 `HAVING`. 这些保留字常与其它类型的 SQL 语句一起使用.

   **专门用于查询数据**. 代表指令为 select/show

2. 数据操作语言 (DML: Data Manipulation Language)

   其语言包括动词 `INSERT`, `UPDATE`, `DELETE`. 分别用于添加, 修改和删除表中的行. 也称为动作查询语言

   **专门用于写数据.** 代表指令为 insert/update/delete

3. 事物处理语言 (TPL)

   它的语言能确保被 DML 语句影响的表的所有行级及得到更新. TPL 语句包括 `BEGIN TRANSACTION`. `COMMIT` 和 `ROLLBAK`.(不是所有的关系型数据库都提供事物安全处理)

   **专门用于事物安全处理.** transaction/begin

4. 数据控制语言 (DCL: Data Control Language)

   它的语句通过 `GRANT` 或 `REVOKE` 获得许可, 确定单个用户和用户组队数据库访问对象. 某些 `RDBMS` 可用 `GRANT` 或 `REVOKE` 控制对表单列的访问。

   **专门用于权限管理:** 代表指令 grant 和 revoke

5.  数据定义语言 (DDL)

   其语言包括动词 `CREATE` 和 `DROP`. 在数据库中创建表或删除表(CREAT TABLE/DROP TABLE); 为表加入索引等. DDL 包括许多与人数据库目录中获得数据有关保留字. 他也是动作查询的一部分.

   **专门用于结构管理:** 代表指令 create 和 drop (alter)

### MySQL 基本介绍

MySQL 是一个**关系型数据库管理系统**, 由瑞典 MySQL AB 公司开发, 目前隶属于 Oracle 旗下产品. MySQL 是最流行的关系型数据库管理系统之一, 在 WEB 应用方面, MySQL 是最好的 RDBMS(关系型数据库关系系统) 应用软件.

1. Mysql 是一种开源免费的数据库产品
2. Mysql 对 PHP 的吃吃是最好的(wamp 或者 lamp)

Mysql 中用到的操作指令就是 SQL 指令



#### 启动/停止MySQL服务

Mysql 是一种 C/S 结构: 客户端和服务端.

服务端对应的软件: Mysqld.exe

命令行方式: 通过 cmd 控制台使用命令进行管理.

```PHP
# 开启服务
net start MySQL
# 关闭服务
net stop MySQL
```

系统进入服务的方式

前提: 在安装 Mysql 的时候将 mysql 添加到 windows 的服务中1去.

![53452295943](./MySQL\1534522959434.png)

方式2 命令行工具输入 services.msc

```
services.msc
```

通过服务对 mysql 服务器进行管理 

方案一: 右键服务, 选择开启或者停止

方案二: 双击服务, 进入服务详情界面, 可以开启或者停止

![53452435966](./MySQL\1534524359663.png)

**登录和退出 MySQL 系统**

通过客户端(mysql.exe) 与服务器进行连接认证, 就可以进行操作.

通常服务端和客户端不在同一台电脑上

**登录**

1. 找到mysql.exe(通过cmd控制台,如果安装的时候制定了 mysql.exe 所在路径为环境变量, 就可以直接访问; 如果没有, 配置环境变量)
2. 输入对应服务器地址: `-h[IP地址/域名]`  (-h www.studyphp.com) 
3. 输入服务器中 mysql 监听的端口: `-P[端口号]` (通常3306)
4. 输入用户名. `-u(用户名)` (-u root)
5. 输入密码: `-p(密码)` 

连接认证基本语法:

Mysql.exe/mysql `-h 主机地址 -P端口 -u root -p woaiwo`

![53452508993](./MySQL\1534525089931.png)

注意事项:

1. 通常端口都是默认的: mysql 监听的端口通常是 3306
2. 密码的输入可以先不显示输入, 直接 -p 之后不书写密码, 回车即可再次输入密码(隐蔽).如此相对安全.

**退出**

断开服务器的链接: 通常 mysql 提供的服务器数量有限, 一旦客户端用完, 建议就该断开链接.

建议方式: 使用 SQL 提供的指令

Exit;	//	exit 带分号	

\q;		//	quit 缩写

![53452542173](./MySQL\1534525421733.png)

![53452545697](./MySQL\1534525456979.png)

#### MySQL 服务端架构

mysql 服务端架构有以下几层构成:

1. 数据库管理系统 (最外层): DBMS, 专门管理服务器端的所有内容.
2. 数据库(第二层): DB, 专门用于存储数据库的仓库 (可以n个).
3. 二维数据表(第三层): Table, 专门用于存储具体实体的数据.
4. 字段(第四层): Field, 具体存储某种类型的数据 (实际存储单元). 

数据库中常用的几个**关键字**

Row: 		行

Column: 	列(field)

## 数据库基本操作

数据库是数据存储的最外层 (最大单元)

### 创建数据库

基本语法 : `create database 数据库名字 [库选项]`

```mysql
create database mydatabase;
```

![53454676355](./MySQL\1534546763558.png)

库选项: 数据库相关属性

字符集: charset 字符集. 代表着当前数据库下的所有表存储的数据默认指定的字符集(如果不指定, 采用 DBMS 默认的)

校对集: collate 校对集

```mysql
create database mydatabase charset gbk
```

![53454695679](./MySQL\1534546956793.png)

### 显示数据库

每当用户通过 sql 指令创建一个数据库, 那么系统就会产生一个对应的存储数据库的文件夹 (data)

![53454939949](./MySQL\1534549399498.png)

![53454947367](./MySQL\1534549473675.png)

其实, 每个数据库文件夹下都有一个 opt 文件, 保存着数据库选项.

![53454954902](./MySQL\1534549549029.png)

数据库没有指定字符集, 那么就会使用 DMBS 默认的字符集 (安装的时候指定) 校对集随字符集.

**显示全部**

基本语法:  `show databases;`

![53454986427](./MySQL\1534549864270.png)

**显示部分**

基本语法:  `show databases like '匹配模式';`

`_` : 匹配当前位置单个字符

`%` : 匹配指定位置多个字符

```php
#	获取以 my 开头的全部数据
show databases like 'my%';
#	获取 m 开头, 后面的第一个字母不确定, 最后为 database 的数库:
show databases like 'm_database';
# 	获取 database 结尾的数据库: 
show databases like '%_database';
```

![53455011104](./MySQL\1534550111049.png)

**显示数据库创建语句**

基本语法: `show create database 数据库名字;`

![53455018201](./MySQL\1534550182014.png)

看到的信息并非原始指令, 经系统修改.

### 选择数据库

为什么要选择数据库? 因为数据库是存储到数据表, 表存在数据库下, 如果要操作数据库, 比如进入到对应的数据库才行.

基本语法: `use 数据库名字;`

![53455038912](./MySQL\1534550389127.png)

### 修改数据库

修改数据库字符集 (库选项): 字符集和校对集

基本语法: `alter database 数据库名 charset 字符集; `

是否可以修改数据库名字? `mysql 5.5-` 可以  但是 `mysql5.5+` 不可以

![53455056850](./MySQL\1534550568501.png)

修改成功对应 db.opt 文件就会有所体现.

![53455059994](./MySQL\1534550599945.png)

### 删除数据库

基本语法: `drop database 数据库名字;`

```php
drop database mydatabase;
```



![53455070713](./MySQL\1534550707130.png)

删除虽然简单, 但是切记做好安全操作: 确保里面数据没有问题. (重要)

删除数据库之后, 对应的存储数据的文件夹也会被删除 (opt 文件也会被删除)

![53455083973](./MySQL\1534550839730.png)



## 数据表操作

### 创建数据表

**普通创建表**

基本语法: `create table 表名(字段名 字段类型 [字段属性], 字段名 字段类型 [字段属性], ...)[表选项];`

```mysql
create table class (
	name varchar(10)
);
```

![53455117643](./MySQL\1534551176431.png)

错误提示: 没有选择数据库. 

有两种方式可以将表挂载到指定个数据库下:

1. 创建表的时候 带上 数据库名

![53455154720](./MySQL\1534551547202.png)

2. 创建表之前, 进入某个数据库, 再进行创建操作

```mysql
use mydatabase2;
create table teacher (
	name varchar(10)
);
```

![53455171307](./MySQL\1534551713077.png)

表选项: 与数据库选项类似

`Engine` : 存储引擎, mysql 提供的具体数据存储方式, 默认有一个 innodb(5.5一起默认是myisam)

`Charset` : 字符集, 只对当前自己表有效 (级别比数据库高)

`Collate` : 校对集, 只对自己

使用表选项

```mysql
create table student(
	name varchar(10)
)charset utf8;
```

![53455202671](./MySQL\1534552026716.png)

**复制已有表结构**

从已经存在的表中复制一份 (只复制结构: 数据不复制)

基本语法: `create table 新表名 like 表名;` 使用 `数据库.表名`, 就可以在任何数据库下访问其它数据的表名.

```mysql
#	在测试数据库中创建一个teacher表和mydatabase2.teacher结构相同.
creata table teacher like mydatabase2.teacher;
```

![53455229687](./MySQL\1534552352199.png)

### 显示数据表

每当一张数据表创建, 就会在对应数据库下创建一些文件 (与存储引擎有关)

![53455256571](./MySQL\1534552565712.png)

注意: 这个结构文件来自于 innodb 存储引擎, innodb存储引擎所有的文件都存储在外部的 ibdata 文件中.

![53455281848](./MySQL\1534552818481.png)

**显示所有表**

基本语法: `show tables;`

![53455289953](./MySQL\1534552899535.png)

**匹配显示表**

基本语法: `show table like '匹配模式';`

```php
#	显示c开头的表
show tables like 'c%';
```

![53455321838](./MySQL\1534553218385.png)

**显示表结构**

本质含义: 显示表中所包含的字段信息(名字, 类型, 属性等)

`Describe 表名`

`Desc 表名`

`show columns from 表名`

```mysql
describe class;
desc student;	#	因为短, 所以大家都喜欢使用 desc
show columns from student;
```

![53455361316](./MySQL\1534553613162.png)

**显示表的创建语句**

查看数据表创建时的语句: 此语句看到的是被加工后的语句

基本语法: `show create table 表名;`

![53455380590](./MySQL\1534553805904.png)

Mysql 中有多种语句结束符

`;` 和 `\g` 所表示的效果一样, 都是字段在上排横着, 下面跟对应数据.

`\G` 字段在左侧竖着, 数据在右侧横着.

![53455400136](./MySQL\1534554001364.png)

### **设置表属性**

表属性指的就是表选项: engine charset collate

基本语法: `alter table 表名 charset 表选项 [=] 值;`

```mysql
alter table student charset 'gbk';
```

![53455424942](./MySQL\1534554249425.png)

注意: 如果数据库已经确定, 库中已存在很多数据, 不要轻易修改表选项 (字符集影响不大)

#### **修改表结构**

- 修改表名: `rename table 旧表名 to 新表名`

```mysql
#	数据库中数据表名字通常有前缀: 去数据库的前两个字母加上下划线
rename table student to my_students;
```

![53455486272](./MySQL\1534554862722.png)

- 修改表选项: `alter table 表名 表选项 [=] 新值`


- 新增字段: `alter table 表名 add [column] 新字段名 列类型 [列属性] [位置first/after字段名]`

```mysql
#	给 学生表 新增 gender 字段
alter table my_students add column gender int;
```

![53455587860](./MySQL\1534555905320.png)

字段位置: 字段想要存放的位置

`First`: 某某之前(最前面), 第一个字段.

`After: 字段名` 放到某个具体字段之后(默认的)

![53455609175](./MySQL\1534556091754.png)

- 修改字段名: `alter table 表名 change 旧字段名 新字段名 字段类型 [列属性] [新位置]`

```mysql
#	修改学生表中gender字段名称为 xb
alter table my_students change gender xb int;
```

![53455626318](./MySQL\1534556263185.png)

- 修改字段类型(属性): **`alter table 表名 modify 字段名 新类型 [新属性] [新位置]`**

```mysql
#	修改字段 name 类型
alter table my_students modify name varchar(20); 
```

![53455645358](./MySQL\1534556453580.png)

- 删除字段: `alter table 表名 drop 字段名`

```mysql
# 删除 xb 字段
alter table my_students drop xb;
```

![53455652712](./MySQL\1534556527127.png)

**删除表结构**

基础语法: `drop table 表名 [,表名 2 ...]`  可以同时删除多个数据表

```mysql
drop table class, teacher;
```

![53455677480](./MySQL\1534556774803.png)



## 数据基础操作

### 插入操作

本质含义: 将数据以 SQL 的形式存储到指定数据表 (字段) 里面

**在指定字段中插入数据**

基本语法: `Insert into 表名[(字段列表)] values(对应字段列表值)`

```mysql
#	往学生列表中插入一条数据
insert into my_students (name, gender) values('小白', 0);
```

![53455740499](./MySQL\1534557404995.png)

注意点:

1. 后面的 (values 中) 度基于的值列表只需与之前的字段列表相对应即可(不一定与表结构完全一致)
2. 字段列表不一定非要知道所有表中的字段.

**在表中所有字段插入数据**

基本语法 `Insert into 表名 values (对应表结构)` 值列表必须与字段列表一致

```mysql
insert into my_students values('大白', 1);
```

![53455836764](./MySQL\1534558367649.png)

### 查询操作

**查询表中全部数据**: `select * from 表名;`

![53455847658](./MySQL\1534558476582.png)

**查询表中部分字段**: `select 字段列表 from 表名;` 字段列表使用 `,` 隔开

![53455863824](./MySQL\1534558958197.png)

**简单条件查询**: `select * from 表名 where 字段名 = 值;`

![53455874740](./MySQL\1534558747402.png)

### 删除操作

基本语法: `delete from 表名 [where 条件];` 如果没有where条件意味着系统会自动删除该表所有数据(慎用).

![53455893956](./MySQL\1534558939569.png)

### 更新操作

更新, 将数据进行修改(通常修改部分字段数据)

基础语法: `update 表名 set 字段名 = 新值 [where 条件]` 如果没有where条件, 则修改所有表对应字段.

![53455912916](./MySQL\1534559129165.png)



## 字符集

**字符编码概念**

字符(Character) 是各种文字和符号的总称, 包括各国家文字 标点符号 图形符号 数字等.

在计算机中所看到的任何内容都是字符构成的.

字符编码 (character code) 是计算针对各种符号, 字啊计算机中的一种二进制存储代号

**字符集概念**

字符集是多个字符的集合,  字符集种类较多, 每个字符集包含的字符个数不同.

常见的字符集名称: `ASCII 字符集` `GB2312 字符集` `BIG5 字符集` `GB18030 字符集` `Unicode 字符集` 等. 计算机要准确地处理各种字符集文字, 需要进行字符编码. 以便计算机能够识别和存储各种文字. 中文文字数目大, 而且还分为简体中文和繁体中文两种不同书写规则的文字. 而计算机最初是按英语单字节设计的, 因此, 对中文符进行编码, 是中文信息交流的技术基础.

**设置客户端所有字符集**

如果直接通过 cmd 下的 mysql.exe 进行中文数据插入, 那么可能会出现问题

![53455981576](./MySQL\1534559815769.png)

出错原因:

1. 用户通过 mysql.exe 来操作 mysqld.exe
2. 真正的 SQL 执行是 Mysqld.exe 来执行
3. mysql.exe 将数据传入 msqld.exe 的时候, 没有告知其对于的符号规则 (字符集), 而 mysqld 也没有能力自己判断, 就会使用自己默认的 (字符集)

解决方案: mysql.exe 客户端在进行数据操作之前将自己所用的字符集告诉 mysqld

Cmd 下的mysql.exe 默认只有一个字符集: GBK

![53456028417](./MySQL\1534560284176.png)

Mysql.exe 如何告知 Mysqld.exe 对应的字符集为 gbk?

快捷方式: `set names 字符集`

```mysql
set names gbk;
```

![53456051591](./MySQL\1534560515916.png)

深层原理: 客户端, 服务端, 连接层 (show variables like 'character_set%')

Mysql.exe 与 Mysqld.exe 之间的处理关系一共分为三层

客户端传入数据给服务端: client, character_set_client

服务端返回数据给客户端: server, character_set_server

客户端与服务端之间的链接: collection, character_set_collection

*`Set names 字符集` 的本质就是一次性打通三层关系的字符集, 变得一致.*

在系统中有三个变量来记录着这三个关系对应的字符集: `show variables like 'character_set%'`

![53456104222](./MySQL\1534561042222.png)

查看一个新的客户端的对应字符集关系

![53456198927](./MySQL\1534561989276.png)



*修改服务器端变量的值 `Set 变量名 = 值;`*

```mysql
set character_set_client = gbk;
```

`Set names gbk;` 相当于做了以下几件事情:

1. set character_set_client = gbk;	//	为了让cmd窗口识别客户端传来的数据
2. set character_set_connection = gbk; //   为了更好帮助客户端与服务端之间进行字符集转换
3. set character_set_results = gbk; //   为了告诉客户端服务端所有的返回数据字符集



## 列类型(字段类型)

### 整型类型

**Tinyint ** 

迷你整形, 系统采用一个字节来保存的整形, 一个字节 = 8位, 最大能表示的数值是 0-255.

**Smallint** 

小整形, 系统采用两个字节来保存的整形, 能表示 0-65535 之间

**Mediumint**

中整形, 采用三个字节来保存数据.

**Int**

整形(标准整形), 采用四个字节来保存数据.

**Bigint**

大整形, 采用八个字节来保存数据.

1. 创建数据表

   ![53458098198](./MySQL\1534580981980.png)

2. 插入合理数据

   ![53458107988](./MySQL\1534581079886.png)

3. 插入错误数据(超出对应数据范围)

   ![53458111263](./MySQL\1534581112639.png)

4. 错误原因: 并不是 `tinyint ` 没有这么大的空间, 是因为 mysql 默认为整形增加负数. 迷你整形(tinyint) 实际区间应该是 (-128~127) 之间.

   ![53458124146](./MySQL\1534581241464.png)

实际应用中应该根据我们对应的数据的实际范围,来定义我们整形的使用范围, 通常 `tinyint ` 和 `int ` 使用较多.

**无符号设定**

无符号. 表示存储的数据在当前数据中, 没有负数(只有正数, 区间为 (0~255).

基本语法: 在类型之后加上一个 `unsigned` 即可.

![53458176277](./MySQL\1534582078458.png)

查看此时该表结构 `desc my_int;`

![53458216929](./MySQL\1534582182832.png)

**Type** 之后的数字表示什么呢?

### 显示长度

显示长度: 指数据(整形) 在我们数据显示的时候, 可以显示多少位.

Tinyint(3) 表示最长可以显示3位, unsigned 说明只能是正数, 0~255 不可能超过3个长度

Tinyint(4) 表示最长可以显示4位, -128~127.

显示长度只是代表了数据是否可以达到指定长度, 但是不糊自动满足到指定长度, 如果想要数据显示的时候保持最高度(显示长度), 那么还需要给字段增加一个 **`zerofill`** 属性才可以.

![53458325834](./MySQL\1534583258341.png)

zerofill: 从左侧开始填充0(左侧不会改变数值大小), 所以负数的时候不能使用 zerofill, 一旦使用 zerofill 相当于确定该字段为正数 (unsigned).

![53458336376](./MySQL\1534583363761.png)

数据显示的时候, zerofill 会在左侧填充 0 到指定位置, 不足三位, 填充到三位, 本身已经够了, 或者超出, 就不再填充.

![53458373750](./MySQL\1534583737501.png)

显示长度可以自己设定: 超出长度(但是不超出范围)不会影响只会对不够长度的进行补充(显示长度)

### 小数类型

专门用于存储小数的.

在 Mysql 中将小数类型又分为两类: 浮点型, 定点型.

####**浮点型**

浮点型又称值为进度类型: 是一种有可能丢失精度的数据类型, 数据有可能不那么准确(尤其是在超出范围的时候).

浮点型之所有能够存储较大的数值(不精确), 原因就是利用存储数据的位来存储指数

​	整形: 全部用于存数据

​	浮点型: 有部分用于存数据, 有部分用于存指数

**Float**

float 又称为单进度类型: 系统提供 4 个字节来存储数据, 但是能表示的数据范围比整形大得多, 大概 10^38; 只能保证大概 7 个左右的精度(如果在7位内, 基本是准确的, 超出就会不准确).

基本语法:

1. Float: 不指定小数位的浮点数
2. Float(M, D): 一共存储 M 个有效数据, 其中小数部分占 D 位

**演示float**

1. 创建数据表

   ![53458513017](./MySQL\1534585130178.png)

2. 存入合法数据

   ![53458517509](./MySQL\1534585266189.png)

注意: 如果数据精度丢失, 那么浮点型是按照四舍五入方式进行计算的.

3. 插入数据, 超出大小

   ![53458529531](./MySQL\1534585295312.png)

4. 插入数据, 数据长度刚好满足条件, 但是会超出精度

   ![53458538193](./MySQL\1534585381931.png)

说明用户不能直接超过指定的整数部分长度, 但是如果系统自动进位导致, 系统可以承担.

5. 浮点数可以采用科学技术法来存储

   ![53458549680](./MySQL\1534585496801.png)

浮点数的应用: 通常是用来保存一些数量特别大, 大到可以不用那么精确的数据.

**Double**

double 又称为双精度: 系统用 8 个字节来存储数据, 表示的范围更大, 10^308次方, 但是精度也只有 15 位左右.

#### 定点数

定点数: 能保证数据精确的小数 (小数部分可能不精确, 超出长度会四舍五入), 整数部分一定精确

**Decimal**
decimal定点数: 系统自动根据存储的数据来分配存储空间, 每大概 9 个数就会分配四个字节进行存储, 同时小数和整数部分是分开的.

Decimal(M, D): M表示总长度, 最大值不能超过65, D代表小数部分长度, 最长不能超过30.

案例演示:

1. 创建表: 与浮点数对比

   ![53458682655](./MySQL\1534586826558.png)

2. 插入正常数据

   ![53458705188](./MySQL\1534587051885.png)

3. 插入最大数据

   ![53458712871](./MySQL\1534587128714.png)

4. 尝试定点数进行四舍五入

   ![53458719330](./MySQL\1534587193308.png)

   定点数超出范围直接报错.并没有进位之说.

   定点数的应用: 如果涉及到钱之类的敏感数据, 可能使用定点数进行存储.

### 日期时间类型

**Date**

​	日期类型: 系统使用三个字节来存储数据, 对应格式为: YY-mm-dd, 能表示IDE范围从 1000-01-01 到 9999-12-12, 初始值为 0000-00-00

**Time**

​	时间类型: 能够表示某个指定给的时间, 但是系统同样是提供 3 个字节来存储, 对应的格式为: HH:ii:ss. 但是 mysql 中的 time 类型能表示的时间范围要大的多, 能表示从 -838:59:59~838:59:59 , 在 mysql 中具体的用处是用来描述时间段.

**Datetime**

​	日期时间类型: 就是将起那么的 date 和 time 合并起来, 表示的时间, 使用 8 个字节存储数据, 格式为 YYYY-mm-dd HH:ii:ss, 能表示的区间 1000-01-01 00:00:00~9999-12-12 23:59:59, 其可以为 0 值, 0000-00-00 00:00:00.

**Timestamp**

​	时间戳类型: mysql 中的时间戳只是表示从格林威治时间开始, 但是其格式依然是: YYYY-mm-dd HH:ii:ss.

**Year**

​	年类型: 占用一个字节来保存, 能表示 1900~2155年, 但是 year 有两种数据插入方式: 0~99 和 四位数的具体年

测试:

1. 创建对应的时间日期类型数据表

   ![53458798929](./MySQL\1534587989292.png)

2. 插入数据: 正常数据

   ![53458817101](./MySQL\1534588171010.png)

3. year 的特殊性, 可以采用两位数的数据插入, 也可以采用四位数的年份插入

   ![53458825120](./MySQL\1534588251208.png)

4. year 作为两位数插入的时候, 有一个区间划分, 临界点为 69 和 70: 输入 69以下, 那么系统时间为 20+数字, 如果是 70以上, 则时间为 10+数字

   ![53458837083](./MySQL\1534588370834.png)

5. timestamp 特性: 当对应数据被修改, 自动更新(这被修改的数据当然不是自己)

   ![53458919353](./MySQL\1534589193539.png)

6. time 类型的特殊性: 本质是用来表示时间区间, 能表示的范围比较大:

   ![53458935415](./MySQL\1534589354155.png)

7. time 特性2: 在进行时间类型录入的时候(time) 还可以使用一个简单的日期代替时间, 在时间格式之前加一个空格, 然后指定一个数字 (可以是负数), 系统就会自动将该数字转换成天数 * 24小时, 再加上后面的时间.

   ![53458943070](./MySQL\1534589430700.png)

PHP 中有着非常强大的时间日期转换函数: date 将事件戳转成想要的格式, strtotime 又可以将很多格式转换成对应的时间戳. PHP 通常不需要数据库来帮助我们处理这么复杂的时间日期, **所以通常配合 PHP 的时候, 时间的保存通常使用时间戳(真正), 从而用整型来保存**.

### 字符串类型

**Char**

定长字符: 指定长度之后, 系统一定会分配指定的空间用于存储数据.

基本语法: `char(L)` : L代表字符数 (中文与英文那字母一样). L长度为 0 到 255

**Varchar**

变长字符: 指定长度后, 系统会根据实际存储的数据来计算长度, 分配合适的长度 (数据没有超出)

基本语法: `varchar(L)` : L代表字符数, L的长度理论值为 0 到 65535.

因为 varchar 要记录数据的长度 (系统根据数据长度自动分配空间), 所以每个 varchar 数据产生后都会在数据后面增加 1-2 个字节的额外开销, 用来保存数据所占用的空间长度.

如果数据本身小于 127 个字符, 额外开销一个字节, 如果大于127就开销两个字节.

char 和 varchar 数据存储对比(utf8, 一个字符都会占用 3 个字节)

| 存储数据 | Char(2) | Varchar(2) | char所占字节 | varchar所占字节 |
| :------: | :-----: | :--------: | :----------: | :-------------: |
|    A     |    A    |     A      |    2*3=6     |     1*3+1=4     |
|    AB    |   AB    |     AB     |    2*3=6     |     2*3+1=7     |

Char 和 Varchar 的区别:

1. char 一定会使用指定的空间, varchar 根据数据来定空间
2. char 的数据查询效率比 varchar 高, varchar是需要通过后面的记录数来计算

如果确定数据一定是占指定长度, 那么使用 char 类型, 如果不确定数据到底用多少, 那么使用 varchar 类型, 如果数据长度超过 255 个字节, 不论是否固定长度, 我们一般都会使用 text, 不在使用 char 和 varchar.

**Text**

文本类型: 本质上 mysql 提供了两种文本类型

Text: 存储普通的字符文本.

Blob: 存储为二进制文本(图片,文件), 一般都不会使用 blob 来存储文件本身, 通常是使用一个链接来指向对应的文件本身.

Text: 系统中提供了四种 text.

**Tinytext**: 系统使用一个字节来保存, 实际能存储的数据为 2^8+1

***Text***: 使用两个字节保存, 实际存储为 2^16+2

**Mediumtext**: 使用三个字节保存, 实际存储为 2^24+3

**Longtext**: 使用四个字节保存, 实际存储为 2^32+4

注意: 

1. 在选择对应存储的文本的时候, 不用刻意去选择 text 类型, 系统会根据存储的数据长度来选择合适文本类型
2. 在选择字符存储的是偶, 如果数据超过 255 个字符, name一定选择 text 存储.

**Enum**

枚举类型: 在数据插入之前, 先设定几个项, 这几个项就是可能最终出现的数据结果.

如果确定某个字段数据就只有那么几个值: 如性别 男. 女. 保密. 系统可以在设定字段的时候, 规定当前字段只能固定放的几个值, 使用枚举

基本语法: `enum(数据值1, 数据值2, ...)` 

系统提供了1 到 2 个字节来存储枚举数据: 通过该计算 enum 列举的具体指来选择实际的存储空间, 如果数据列表在 255 个以内, 那么一个字节就够了, 如果超过 255 小于 65535, 那么系统就会采用两个字节保存.

演示 enum:

1. 创建表

   ![53463571109](./MySQL\1534635711099.png)

2. 插入一个合法的数据, 所设定的值必须是 enum 指定的数据

   ![53463578005](./MySQL\1534635780059.png)

3. 错误数据: enum 有规范数据的功能, 能够保证插入的数据必须是设定范围, 其它都不行.

   ![53463582956](./MySQL\1534635829564.png)

4. 枚举 enum 的存储原理: 实际上字段上所存储的值并不是真正的字符串, 而是字符串对应的下标: 当系统设定枚举类型的时候, 会给枚举中每个元素定义一个下标, 下标规则就是从 1 开始 (`enum(1=>'男',2=>'女',3=>'保密')`) 

   ![53463589551](./MySQL\1534635895519.png)

特性: 在 mysql 中系统是自动进行类型转换的: 如果数据碰到 `+ - * /` 系统就会自动将数据转换成数值: 而普通字符串转成数值为 0 `Select 字段名 + 0 from 表名`

![53463595299](./MySQL\1534635952995.png)

5. 既然实际 enum (枚举) 字段存储的结果是数值, 那么在进行数据插入的时候, 就可以使用对应的数值来进行.

![53463626622](./MySQL\1534636266223.png)

枚举的意义: 

1. 规范数据本身, 限定插入规定的数据项
2. 节省存储空间 (存储的是下标)

**Set**

集合: 是一种将多个数据选项可以同时保存的数据类型, 本质是将指定的项按照对应的二进制位来进行控制: 1表示该选项被选中, 0 表示该选项没有被选中.

基本语法: `set('值1', '值2', '值3'...)` 

系统为 set 提供了多个字节进行保存, 但是系统会自动计算选择具体的存储单元.

1 个字节: set 只能有 8 个选项

2 个字节: set 只能有 16 个选项

3 个字节: set 只能有 24 个选项

8个字节: set 可以表示 64 个选项

Set 和 enum 一样, 最终存储到字段中的依然是数字而不是真实的字符串.

set 演示

1. 创建表

   ![53463671183](./MySQL\1534636711832.png)

2. 插入数据: 可以插入多个数据, 就是在值中使用 `, ` 隔开即可

   ![53463700766](./MySQL\1534637007667.png)

3. 数据选项所在的数据与插入数据的顺序无关: 最终都会变成选项对应的顺序

   ![53463721306](./MySQL\1534637213061.png)

4. 分析数据存储的方式: 

   1. 系统将对应的数据选项 (设计) 按照顺序进行编排. 从第一个开始进行占位, 每个都对对应一个 二进制位.

   ![53463732880](./MySQL\1534637328808.png)

   2. 数据在存储的时候, 被选中的标识 1 , 未选中标识 0

      ![53463749395](./MySQL\1534637493955.png)

   3. 系统在进行存储的时候回自动将得到的最终的二进制颠倒过来, 然后再进行转换成十进制存储

      ![53463916433](./MySQL\1534639164338.png)

5. 查看数据: 按照自动转换成数值来查看

   ![53464011641](./MySQL\1534640116416.png)

6. 既然是数值, 那么就可以插入数值代替值来输入

   ![53464102171](./MySQL\1534641021717.png)

我们不推荐如此. 因为不一定是期望值.

set 集合的意义:

1. 规范数据
2. 节省存储空间

### mysql记录长度

在 mysql  中, 有一项规定: mysql 的记录长度 (record == 行 row) 总长度不超过 65535 个字节.

Varchar 能够存储的理论值为 65535 个字符: 字符在不同字节集下可能占用多个字节.

varchar 能够存储的最大长度证明:

1. 创建表: 证明 varchar 在 mysql 中能达到的理论值 (utf8 和 gbk)

   Varchar 除了本字符需要占空间, 还需要额外空间来保存记录长度

   ![53464144399](./MySQL\1534641443998.png)

2. 计算在 utf8 和 gdk 下 varchar 能够存储的最大长度

   utf8 65535 / 3 = 21845, 如果采用 varchar 存储, 需要额外的 1个字节保存长度. 最多能够存储 21184 个字符

   gbk 65535 / 2 = 32767 余 1, 如果采用 varchar存储, 需要额外 2 个字节 , 最毒哦只能存储 32766 个字符

   ![53464183733](./MySQL\1534641837339.png)

碰到较长的字符, 建议不使用 varchar, 使用 text 进行存储.



## 列属性(字段属性)

列属性又称值为 字段属性. 在 mysql 中一共有 6 个属性, 分别是: `null` `默认值` `列描述` `主键` `自增长` `唯一键`

**Null 属性** 

​	null属性: 代表字段为空. 如果对应的值为 yes , 表示该字段可以为空. 

​	![53464232073](./MySQL\1534642320732.png)

注意: 

1. 在设计表的时候, 尽量不让数据为空.
2. mysql 的记录长度为 65535 个字节, 如果一个表中有字段允许为 null, name系统就会设计保留一个字节来存储 null, 最终有效存储长度为 65534 个字节.

**默认值**

​	Default: 默认值, 当字段被设计的时候, 如果允许默认条件下, 用户不进行数据的插入, 那么就可以使用事先准备好的数据来填充, 通常填充的是 null.

![53464303184](./MySQL\1534643031849.png)

测试:

![53464314614](./MySQL\1534643146147.png)

Defalut 关键字另外一层使用: 显示的告知字段使用默认值: 在进行数据插入的时候, 对字段直接使用 default

![53464337760](./MySQL\1534643377600.png)

**列描述**

列描述: coumment: 是专门用于给开发商人员进行维护的一个注释说明

基础语法: `comment 字段描述`.

![53464411849](./MySQL\1534644118496.png)

查看 comment: 必须通过该查看表创建语句. `show create table my_comment`

### 主键

顾名思义: 主要的键, primarykey, 在一张表中, 有且只有一个字段, 里面的值具有唯一性.

**创建主键**

**随表创建**

系统提供了两种增加主键的方式:

1. 直接在需要做主键的字段后面, 直接增加 `primary key` 属性来确定主键.

2. 在所有字段之后增加 `primary key(字段名)` 选项进行确定主键.

   ![53464461268](./MySQL\1534644612681.png)

**表后增加**

基本语法: alter table 表名 `add primary key(字段)`

![53464476639](./MySQL\1534644766392.png)

**查看主键**

1. 通过查看表结构

   ![53464487132](./MySQL\1534644871323.png)

2. 查看表的创建语句

   ![53464497395](./MySQL\1534644973956.png)

**删除主键**

基本语法: `alter table 表名 drop primary key;`

![53464508312](./MySQL\1534645083126.png)

**复合主键**

案例: 有一张学生选修课表: 一个学生是可以选修多个选修课, 一个选修课也可以由多个学生来选, 但是一个学生在一个选修课只中只有一个成绩

```mysql
create table my_score(
    student_no char(10),
    curse_no char(10),
    score tinyint not null,
    primary key (student_no, curse_no)
)charset utf8;
```

![53464558915](./MySQL\1534645589157.png)

**主键约束**

主键一旦增加, 那么对对应的字段有数据要求:

1. 当前字段对应的数据不能为空.
2. 当前字段对应的数据不能有任何重复.

![53464577207](./MySQL\1534645772075.png)

![53464578861](./MySQL\1534645788614.png)

**主键的分类**

主键分类采用的是主键所对应的字段的业务意义进行分类:

1. 业务主键: 主键所在字段具有业务意义 (学生ID, 课程ID)
2. 逻辑主键: 自然增长的整型 (应用广泛)

### 自动增长

​	自动增长: auto_increment, 当给定某个字段该属性之后, 该列的数据在没有提供确定数据的时候, 系统会根据之前已经存在的数据进行自动增长后, 填充数据.

通常自动增长用于逻辑主键

**原理**

自动增长的原理:

1. 在系统中有维护一组数据, 用来保存当前使用了自动增长属性的字段, 记住当前对应的数据值, 再给定一个指定的步长.
2. 当用户进行数据插入的时候, 如果没有给定值, 系统在原始值上加上步长变成新的数据.
3. 自动增长的触发: 给定属性的字段没有提供值.
4. 自动增长只适用于数值.

**使用自动增长**

基本语法: 在字段之后增加一个属性 `auto_increment` 即可.

```mysql
#	创建一个带自动增长的表
create table my_auto(
    id int primary key auto_increment,
    name varchar(10) not null comment '用户名',
    pass varchar(10) not null comment '密码'
)charset utf8;
```

![53464643612](./MySQL\1534646489876.png)

![53464660778](./MySQL\1534646607783.png)

![53464663243](./MySQL\1534646632430.png)

还有一种方式: `alter table my_auto modify id int auto_increment;`

**修改自增长**

1. 查看自增长: 自增长一旦触发使用之后会自动在表选项中增加一个选项 (一张表最多只能拥有一个自增长)

   ![53464675313](./MySQL\1534646753138.png)

2. 如此我们试着修改表选项进行修改自动增长

   ![53464728038](./MySQL\1534647280380.png)

**删除自动增长**

删除自增长: 就是在字段再属性之后不再保留 auto_increment. 当用户修改自增长所在字段时,如果没有看到 auto_increment 属性, 系统会自动清除该自增长

![53464794327](./MySQL\1534647943277.png)

增加一条数据.

![53464807844](./MySQL\1534648078442.png)

**初始设置**

在系统中, 有一组变量, 用来维护自增长的初始值和步长.

```mysql
#	查看自增长初始变量
show variables like 'auto_increment%';
```

![53464818511](./MySQL\1534648185116.png)

**细节问题**

1. 一张表只有一个自增长: 自增长会上升到表选项中. 

2. 如果数据插入中没有触发自增长 (给定数据), 那么自增长不会表现.

   ![53464854367](./MySQL\1534648543674.png)

3. 自增长在修改的时候, 这个值可以较大, 但是不能比当前已有的自增长字段的值小

   ![53464867506](./MySQL\1534648675065.png)

### 唯一键

唯一键: unlque key, 用来保证对应的字段中的数据唯一的.

主键也可以用来保证字段数据唯一性, 但是一张表只有一个主键. 

1. 唯一键在一张表中可以有多个.
2. 唯一键允许字段数据为 NULL. NULL 可以有多个(NULL不参与比较).

**创建唯一键**

1. 直接在表字段之后增加唯一键标识符: unique[key]
2. 在所有的字段之后使用 unique key(字段列表)
3. 在创建完表之后也可以增加唯一键 `alter table 表名 add unique key(字段列表)`

```mysql
create table my_unique1(
id int primary key auto_increment,
username varchar(10) unique
)charset utf8;

create table my_unique2(
id int primary key auto_increment,
username varchar(10),
unique key(username)
)charset utf8;

create table my_unique3(
id int primary key auto_increment,
username varchar(10)
)charset utf8;
alter table my_unique3 add unique key(username);
```

**查看唯一键**

唯一键是一个属性, 可以通过查看表属性来查看唯一键![53465132710](./MySQL\1534651327108.png)

特性: 允许为空, 标识符 UNI

唯一键效果: 在不为空的情况下不允许重复数据.

![53465177792](./MySQL\1534651777928.png)

在查看表创建语句的时候, 会看到与主键不同的一点, 会多出一个"名字".

![53465199850](./MySQL\1534651998508.png)

**删除唯一键**

一个表中允许存在多个唯一键: 假设命令和主键一样 alter table 表名 drop unique key, //	这是错误的.

删除唯一键的基本语法: `alter table 表名 drop index 唯一键名字;`

index 关键字: 索引, 唯一键是索引的一种 (提升查询效率)

![53465235547](./MySQL\1534652355476.png)

修改唯一键: 先删除 后增加

**复合唯一键**

唯一键和主键一样可以使用多个字段来共同保证唯一性.

一般主键都是单一字段(逻辑主键), 而其他需要唯一性的内容都是由唯一键来处理.



## 表关系

表关系: 表与表之间 (实体之间) 有什么样的关系, 每种关系我们该如何设计表结构.

### **一对一**

一对一: 一张表中的一条记录与另外一张表中最多有一条明确的关系: 通常此设计方案**保证两张表中使用同样的主键**即可.

学生表

| 学生ID(PRI) | 姓名 | 年龄 | 性别 | 籍贯 | 婚姻 | 住址 |
| :---------: | :--: | :--: | :--: | :--: | :--: | :--: |
|             |      |      |      |      |      |      |

表的使用中:  常用的信息会经常去查询, 而不常用的信息会偶尔才会用到.

解决方案: 将两张表拆分, 常用的放一张表, 不常用的放一张表.

常用表

| 学生ID(PRI) | 性别 | 年龄 | 姓名 |
| :---------: | :--: | :--: | :--: |
|             |      |      |      |

不常用表:

| 学生ID(PRI) | 籍贯 | 婚否 | 住址 |
| :---------: | :--: | :--: | :--: |
|             |      |      |      |

### **一对多**

一对多, 通常也叫作多对一的关系. 通常一对多的关系设计方案, **在"多"关系的表中去维护一个字段, 这个字段就是 "一" 关系的主键**.

母亲表

| 母亲ID | 姓名 | 年龄 | 身高 |
| ------ | ---- | ---- | ---- |
| M1     |      |      |      |
| M2     |      |      |      |

孩子表

| 孩子ID | 姓名 | 年龄 | 身高 | 母亲ID |
| ------ | ---- | ---- | ---- | ------ |
| C1     |      |      |      | M1     |
| C2     |      |      |      | M2     |

### 多对多

多对多: 一张表中的一条记录可以在另外一张表中可以匹配到多条记录, 反过来也是如此.

多对多的关系如果按照多对一的关系维护: 就会出现一个字段中有多个其它主机, 在访问的时候就会带来不便.

既然通过两张表自己增字段解决不了问题, 那么就通过第三张表来解决.

师生关系举例:

1. 一个老师教过多个班级的学生
2. 一个学生听过多个老师讲的课

首先得到两个实体: 老师表和学生表

![53465906984](./MySQL\1534659069844.png)

从中间设计一张表: 维护两张表对应的联系: 每一种联系都包含

![53465926685](./MySQL\1534659266855.png)

多对多的解决方案: **增加一个中间表, 让中间表与对应的其他表形成两个多对一的关系; 多对一的解决方案就是在 "多" 表中增加 "一" 表对应的主键字段**.



## 数据表高级操作

### 新增数据

#### 多数据插入

只要写一次 insert 指令, 可以直接插入多条记录.

基本语法: `insert into 表名 [(字段列表)] values(值列表),(值列表)...;`

```mysql
insert into my_insert values('小白'),('懵宝'),('无所畏惧');
```

![53466067874](./MySQL\1534660678744.png)

#### 主键冲突

主键冲突: 在有的表中, 使用的是业务主键 (字段有业务含义:如学生id), 但是往往在进行数据插入的时候, 又不确定数据表中是都已存在对应的主键.

![53466114821](./MySQL\1534661148217.png)

插入一条主键冲突的数据

![53466125190](./MySQL\1534661251909.png)

主键冲突的解决方案: 一般情况下我们是不允许此事情发生的, 但是不可避免.

1. 主键冲突更新:	类似插入语法, 如果插入的过程中主键冲突, 采用 更新方法

   `insert into 表名 [(字段列表)] values(值) on duplicate key update 字段 = 新值;`

   ```mysql
   insert into my_primaryKey values('stu0001','爱无畏') on duplicate key update name = '爱无畏';
   ```

   ![53466171616](./MySQL\1534661716168.png)

2. 主键冲突替换:     当主键冲突之后, 干掉原来的数据, 重新插入进去

   `Replace into 表名 [(字段列表)] values (值列表);` 

   ```mysql
   replace into my_student values('stud0004', '大白兔');
   ```

   ![53466181229](./MySQL\1534661842754.png)

#### 蠕虫复制

蠕虫复制: 一分为二, 成倍地增加. 从已有的数据中获取数据, 并且将获取到的数据直接插入到数据表中.

基本语法: `insert into 表名 [(字段列表)] select */字段列表 from 其它表;`

```mysql
insert into my_simple select * from my_simple;
```

![53466261902](./MySQL\1534662619029.png)

注意: 

1. 蠕虫复制的确一般用于重复数据, ,没有很大的业务意义; 可以再短期内快速增加表的数据量, 从而可以测试表的压力,还可以通过大量数据测试标的效率 (索引)
2. 蠕虫复制虽好, 但是要注意主键冲突.

### 更新数据

注意: 

1. 在更新的数据的时候, 特别要注意通常是要根据条件进行更的.

   `Update 表名 set 字段名 = 新值 where 判断条件;`

2. 如果没有条件, 是全表更新数据. 但是可以使用 `limit` 来限制更新的数据

   `Update 表名 set 字段名 = 新值 [where 判断条件] limit 数量;`

   ```mysql
   #	改变 四个 无所畏惧 改成 步步为营 
   update my_simple set name = '步步为营' where name = '无所畏惧' limit 3;
   ```

   ![53466315970](./MySQL\1534663159700.png)

### 删除数据

注意: 

1. 删除数据的时候, 尽量不要全部删除, 应该使用 where 进行条件判定部分删除.
2. 删除数据的时候, 可以使用 limit 限制要删除的具体数量.

**Delete 删除数据的时候无法重置 auto_increment(自动增长)**

我们希望自增长能从头开始(不断断续续的)

解决方案:  Mysql 有一个能够重置表选项中的自增长的语法;

`Truncate 表名;`  (drop --- create)

```mysql
truncate my_auto;
```

1. 初始数据

   ![53466395015](./MySQL\1534663950158.png)

2. 使用 delete 删除数据

   ![53466400571](./MySQL\1534664005715.png)

3. 再次插入数据, 查看 auto_increment 情况

   ![53466413587](./MySQL\1534664135871.png)

4. 使用 mysql 提供的 truncate 重置表

   ![53466426611](./MySQL\1534664266115.png)

注意: truncate 是直接将数据表全部置空(drop -> create), 如果数据需要保留就别使用了. 

### 查询数据

完整的查询指令: 

​	**`Select select选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制`**

**Select 选项**: 系统该如何对待查询得到的结果 

1. ALL: 默认的, 表示保存所有的记录
2. Distinct: 去重, 去除重复的记录, 只保留一条(所有的字段都相同).

```mysql
select all * from my_simple;	#	等价于 select * from my_simple;
select distinct * from my_simple;
```

![53466879672](./MySQL\1534668796720.png)

![53466887749](./MySQL\1534668877497.png)

**字段列表** : 有的时候需要从多张表中获取数据, 在获取数据的时候可能存在不同字段有同名字段. 需要将同名的字段命名成不同名的.  利用别名 alias.

基本语法: `字段名 [as] 别名`

```mysql
select name as name1, name name2 from my_simple;
```

![53466895825](./MySQL\1534668958257.png)

- **From 数据源**

From 是为了前面的查询提供数据: 数据源只要是一个符合为二维结构的数据即可.

**单表数据** 从一张表获取数据

![53466918751](./MySQL\1534669203841.png)

**多表数据** 获取多张表的数据

基本语法: `from 表1, 表2`

![53466941906](./MySQL\1534669419067.png)

结果: 两张表的记录数相乘, 字段数拼接.

本质: 从一张表去除一条记录去拼凑第二张表的所有记录, 保留所有结果. 得到的结果在数学上有个专业的说法: 笛卡尔积, 这个结果出了给数据库造成压力, 没有其他意义, 应该尽量避免出现"笛卡尔积".

**动态数据**

From 后面跟的数据不是一个实体表, 而是一个从表中查询出来得到的二维结果表(**子查询**)

基本语法: `from (select 字段列表 from 表名) as 别名`.

```mysql
select * from (select name as autoMessage from my_primaryKey) as auto;
```

![53466984324](./MySQL\1534669843240.png)

- **Where 子句**

Where 子句: 用来从数据表获取数据的时候进行条件筛选.

数获取原理: 针对表去对应的磁盘处获取所有的数据(一条条), where 的作用就是在拿到一条结果就开始进行判断, 判断是否符合条件: 如果符合就保存下来, 不符合就直接舍弃 (不放到内存中).

Where 是通过运算符进行结果比较来判断数据.

- **Group by 子句**

  Group by 表示分组的含义: 根据指定的字段, 将数据进行分组, 分组的目标是为了统计.

**分组统计**

基本语法: `group by 字段名;`

开始操作: 报错.

```
ERROR 1055 (42000): Expression #3 of SELECT list is not in GROUP BY clause and contains nonaggregated column ‘imooc.s.type_name’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
```

解决错误: 查看sql_model参数命令： 

```mysql
-- 查看sql_model参数, 
SELECT @@GLOBAL.sql_mode; 
-- 发现： 第一项默认开启ONLY_FULL_GROUP_BY了。导致出现了错误。
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 
-- 解决: 执行命令
set sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```

修改参数后使用分组统计 按照班级 id 进行分组统计

![53493121889](./MySQL\1534931218890.png)

Group by 是为了分组后进行数据统计的, 如果只是想看数据显示, 那么 group 没什么含义: group by 将数据按照指定的字段分组之后, 只会保留每组第一条记录.

利用统计函数 (聚合函数): 

1. `count()`: 统计每组中的数量, 如果统计的目标是字段, 那么不统计, 为空 (NULL)字段. 如果为(*)那么代表统计记录.
2. `avg()`: 求平均值
3. `sum()`: 求和
4. `max()`: 求最大值
5. `min()`: 求最小值

使用聚合函数: 按照班级统计每班人数, 最大年龄, 最可爱的身高, 平均年龄

```mysql
#	使用聚合函数作统计. //	select class_id,count(*) as '人数',max(age),min(height),avg(age) from my_gb
select class_id,count(*) as '人数',max(age),min(height),avg(age) from my_gb group by class_id; 

#	group_concat() 
select group_concat(name,class_id),class_id,count(*) as '人数',max(age),min(height),avg(age) from my_gb group by class_id; 
```

![53467485104](./MySQL\1534674911371.png)

`Group_concat() `: 为了将分组中指定的字段进行合并(拼接)

![53467512858](./MySQL\1534675128585.png)

**多分组**

将数据按照某个字段进行分组之后, 对已经分组的数据进行再次分组.

基本语法: `grup by 字段1, 字段2;` 先按照字段1进行排序, 之后将结果按照字段2 进行排序, 以此类推.

```mysql
select class_id, gender, count(*) as '人数', group_concat(name) from my_gb group by class_id, gender;
```

![53467576191](./MySQL\1534675761913.png)

**分组排序**

Mysql中,分组默认有排序的功能: 按照分组字段进行排序, 默认是升序.

基本语法: `group by 字段 [asc|desc], 字段 [asc|desc]..`

```mysql
select class_id, gender, count(*) as '人数', group_concat(name) from my_gb group by class_id, gender desc;
```

![53467654653](./MySQL\1534676546535.png)

**回溯统计**

当分组进行多分组以后, 往上统计的过程, 需要进行层层上报, 将这种层层上报统计的过程称为回溯统计: 每一次分组向上统计的过程都会产生一次新的统计数据, 而且当前数据对应分组字段为 NULL.

基本语法: `group by 字段 [asc|desc] with rollup`

```mysql
select class_id,count(1) as '人数' from my_gb group by class_id with rollup;
```

![53467681929](./MySQL\1534676819293.png)

**多分组的回溯**

```mysql
select class_id,count(1) as '人数', gender from my_gb group by class_id with rollup, gender;
```

![53467696462](./MySQL\1534676964624.png)

- having 子句

Having 的本质和 where 一样, 是用来进行数据条件筛选.

having 是在 group by 子句之后: 可以针对分组数据进行统计筛选, where 这点是不行的.

```mysql
#	select class_id, count(1) as number from my_gb where count(1) >= 4 group by class_id;	//	错误的
# 	筛选分组中 class 人数大于 3 的分组, 显示班级和人数
select class_id, count(1) as number from my_gb group by class_id having count(1) >= 3;
select class_id, count(1) as number from my_gb group by class_id having number >= 3;
```

![53467833002](./MySQL\1534678330027.png)

Having 在 group by 分组之后, 可以使用聚合函数或字段别名进行分组筛选(where 是从表中取出数据, 别名是在数据进入到内存中后才有的)

![53467848954](./MySQL\1534678489549.png)

强调: having 是在 group by之后, group by 是在 where 之后, where 的时候表示数据从磁盘拿到内存, where 之后的所有操作都是内存操作.

- **Order by 子句**

order by 排序: 根据校对规则对数据进行排序

基本语法: `order by 字段 [asc|desc];` 其中 asc(升序) 是默认的.

```mysql
select * from my_gb order by age desc;
```

![53467898875](./MySQL\1534678988759.png)

order by 也可以像 group by 一样进行多字段排序: 先按照第一个字段进行排序, 然后按照第二个字段进行排序

基本语法: `order by 字段1 [asc|desc], 字段2 [asc|desc];`

```mysql
select * from my_gb order by class_id desc,age;
```

![53467901656](./MySQL\1534679016565.png)

- **Limit 子句**

Limit 限制子句: 主要用啦限制记录数量的获取

**记录数限制**

纯粹的限制获取的数量: 从第一条到指定的数量

基本语法: `limit 数量;`

```mysql
select * from my_gb limit 2;
```

![53467920243](./MySQL\1534679202436.png)

limit 通常在查询的时候如果限定为 1 条记录的时候使用的比较多: 有时候获取多条记录并不能解决业务问题, 但是会增加服务器的压力.

**分页**

利用 limit 来限制获取指定区域的数据

基本语法: `limit offset,length;`  //	offset 偏移量: 从哪开始, length 就是具体的获取多少条记录

```mysql
select * from my_gb limit 2, 2;
```

![53467949185](./MySQL\1534679491858.png)

注意: limit 后面的 length 表示最多获取对应数量, 如果数量不够, 系统不会强求

![53467954355](./MySQL\1534679543557.png)



## 查询中的运算符

### 算数运算符

`+` `-` `*` `/` `%` 

基本算数运算, 通常 不在条件中使用, 而是用于结果运算(select 字段中)

![53468006770](./MySQL\1534680097068.png)

### 比较运算符

`>` `<` `>=` `<=` `=` `<>`

通常使用来在条件中进行限定结果

`=` : 在 mysql 中, 没有对应的 == 比较符号, 就是使用 = 来进行相等判断 

`<=>` : 相等比较

```mysql
select * from my_gb where age >= 20;
```

![53468029230](./MySQL\1534680292302.png)

特殊运用: 就是在字段结果中进行比较运算

```mysql
#	字符串与数值的比较
#	mysql 中没有规定 select 必须有数据表
select '1' <=> 1, 0.02 <=> 0, 0.01 <> 0;
```

![53468040115](./MySQL\1534680473969.png)

在条件判断的时候, 还有一种运用: 计算区间

基本语法: `Between 条件1 and 条件2;`

```mysql
#	查找年龄区间
select * from my_gb where age between 20 and 30;
```

![53468068195](./MySQL\1534680681951.png)

between 中 条件1 必须小于条件2, 反过来不可以!

![53468073846](./MySQL\1534680738467.png)

### 逻辑运算符

`and` `or` `not`

`and`: 逻辑与

```mysql
select * from my_gb where age >=20 and age <=30;
```

`or`: 逻辑或

```mysql
select * from my_gb where age >=20 or height >=170;
```

![53468093260](./MySQL\1534680932607.png)

### In 运算符

`in`: 在什么里面, 用来替代 `=`, 当结果不是一个值, 而是一个结果集的时候使用.

基本语法: `in(结果1, 结果2, 结果3...);`

```mysql
select * from my_gb where class_id in (1);
```

![53468107094](./MySQL\1534681070946.png)

### Is 运算符

is 是专门用来判断字段是否为 NULL 的运算符.

基本语法: `is null/is not null;`

```mysql
# 	查询不为空数据
#	select * from my_gb where height = null;	//	这样是没有结果的, null的判断必须是用 is
select * from my_gb where height is null;
```

![53468135907](./MySQL\1534681359077.png)

### Like 运算符

Like 运算符: 是用来进行模糊匹配 (匹配字符串)

基本语法: `like '匹配模式';`

匹配模式中, 有两种占位符:

1. `_`: 匹配对应的单个字符
2. `%`: 匹配多个字符

```mysql
#  匹配所有 name 中带有 "小" 的数据
select * from my_gb where name like '%小%'; 	//	匹配 含有小的
select * from my_gb where name like '小%'; 	//	匹配 以小开头+n个字符的
select * from my_gb where name like '小_'; 	//	匹配 小开头+一个字符的
```

![53468166838](./MySQL\1534681668385.png)

![53468175840](./MySQL\1534681758402.png)



## 联合查询

**基本概念**

​	联合查询是可合并多个相似的选择查询的结果集. 等同于将一个表追加到另一个表, 从而实现两个表查询组合到一起, 使用谓词为 UNION 或 UNION ALL.

联合查询: 就是将多个查询的结果合并到一起 (纵向合并), 字段数不变, 多个查询的记录数合并

**应用场景**

1. 将同一张表中不同的结果 (需要对应多条查询语句来实现), 合并到一起来展示数据.
2. 最常见: 在数据量大的情况下会对表进行分表操作, 需要对每张表进行部分数据统计, 使用联合查询来讲数据存放到一起显示.

**基本语法**

```mysql
Select 语句
Union [union 选项]
Select 语句;
```

Union 选项: 与 select 选项基本一样

1. Distinct: 去重: 去掉完全重复的数据 (默认的)

   ```mysql
   select * from my_gb
   union
   select * from my_gb;
   ```

   ![53468938989](./MySQL\1534689389890.png)

2. All: 保存所有的数据

   ```mysql
   select * from my_gb
   union all
   select * from my_gb;
   ```

   ![53468947414](./MySQL\1534689474148.png)

   注意细节: UNION 理论上只要保证字段数一样, 不需要每次拿到的数据类型一致. 永远只保留第一个 select 语句对应的字段名字.

   ![53468973122](./MySQL\1534689731222.png)

   **order by 的使用**

   1. 在使用联合查询的时候, 如果需要使用 order by ,则对应的 select 语句必须使用  `()` 包起来

   2. order by 在联合查询中若生效, 必须需要 limit: 而 limit 后面必须跟对应的限制数量 (通常可以使用一个较大的值: 大于对应表的记录数即可)

      ```mysql
      (select * from my_gb where gender = 1 order by height asc limit 10)
      union all
      (select * from my_gb where gender = 2 order by height desc limit 10);
      ```

       ![53469005277](./MySQL\1534690052777.png)




## 连接查询

连接查询: 顾名思义, 将多张表连到一起进行查询 (会导致记录数行和字段数列发生变化)

**连接查询的意义**

在关系型数据库设计过程中, 实体 (表) 与实体之间是存在很多联系的. 在关系型数据库表的设计过程中, 遵循着关系设计:  一对一, 一对多 和 多对多. 通常在实际操作的过程中, 需要利用这层关系来保证数据的完整性.

**连接查询的分类**

1. 交叉连接
2. 内连接
3. 外连接:
   1. 左外连接(左连接)
   2. 右外连接(右连接)
4. 自然连接

### 交叉连接

​	将两张表的数据与另外一张表彼此交叉

**原理**

1. 从第一张表依次取出每一条记录. 
2. 取出一条记录之后与另外一张表的全部记录挨个匹配.
3. 没有任何匹配条件, 所有结果都会被保留.
4. 记录数 = 第一张表 * 第二张表记录数. 字段数 = 第一张表字段数 + 第二张表字段书数 (笛卡尔积).

**语法**

基本语法: `表一 cross join 表2;`

```mysql
select * from my_gb cross join my_auto;
```

![53471832192](./MySQL\1534718403050.png)

**应用**

交叉连接产生的结果是笛卡尔积, 没有实际应用.

本质: `from 表1, 表2;`

### 内连接

 	内连接: **inner join**, 从一张表中取出所有的记录, 去另外一张表中匹配, 利用匹配条件进行匹配, 成功了进行保留. 失败了放弃.

**原理**

1. 从一张表中取出一条记录, 然后去另外一张表中进行匹配
2. 利用匹配条件进行匹配:
   1. 匹配成功: 保留, 继续向下匹配
   2. 匹配失败: 向下继续, 如果全表匹配失败, 结束

**语法**

基本语法: `表1 [inner] join 表2 on 匹配条件;`

演示: 班级匹配.

![53472450362](./MySQL\1534724503622.png)

1. 如果内连接没有匹配条件(允许), 其实就是交叉连接(尽量避免)

```mysql
select * from my_gb inner join my_class;
```

![53472459100](./MySQL\1534724591008.png)

2. 使用匹配条件进行匹配

```mysql
select * from my_gb inner join my_class on my_gb.class_id = my_class.id;
```

![53472486775](./MySQL\1534724867756.png)

3. 因为表的设计通常容易产生同名字段, 尤其是 ID, 为了避免重名出现错误, 通常使用 `表名.字段名` 确保唯一性

```mysql
select my_gb.*,my_class.class_name from my_gb inner join my_class on my_gb.class_id = my_class.id;
```

![53472503347](./MySQL\1534725033472.png)

4. 如果条件中使用到对应的表名. 而表名通常比较长, 所以可以通过表别名进行简化

```mysql
select g.*, m.class_name from my_gb as g inner join my_class as m on g.class_id = m.id;
```

![53472556782](./MySQL\1534725567820.png)

5. 内连接匹配的时候, 必须确保匹配到才能保存数据.

```mysql
select m.class_name, g.* from my_class as m inner join my_gb as g on m.id = g.class_id;
```

![53472579869](./MySQL\1534725798696.png)

6. 内连接因为可以不强制必须使用匹配条件, 因此可以在数据匹配完成之后, 使用 where 条件来限制, 效果与 on 一样(建议使用 on)

```mysql
select m.class_name, g.* from my_class as m inner join my_gb as g where m.id = g.class_id;
```

![53472585841](./MySQL\1534725858418.png)

**应用**

内连接通常是在对数据有精确要求的地方使用: 必须保证两张表中都能进行数据匹配.

### 外连接

​	外连接: outer join: 按照某一张表作为主表 (表中所有记录在最后都会保留), 根据条件去连接另外一张表, 从而得到目标数据.

​	外连接分类两种: 左外连接(left join), 右外连接 (right join).

左连接: 左表是主表

右链接: 右表是主表

**原理**

1. 确定连接主表: 左连接就是 left join 左边的表为主表; right join 就是右边的表为主表.
2. 拿主表的每一条记录, 去匹配另外一张表 (从表) 的每一条记录.
3. 如果满足匹配条件: 保留, 不满足即不保留.
4. 如果主表记录在从表中一条都没有匹配成功, 那么也要保留该记录, 但是从表对应的字段值都为 NULL.

**语法**

基本语法:

左连接: `主表 left join 从表 on 连接条件;`

右连接: `从表 right join 主表 on 连接条件;`

左连接对应的主表数据在左边, 右连接对应的主表数据在右边.

```mysql
select a.*, b.class_name from my_gb as a left join my_class as b on a.class_id = b.id;
```

![53472701777](./MySQL\1534727017777.png)

![53472707502](./MySQL\1534727075025.png)

![53472721868](./MySQL\1534727218682.png)

特点:

1. 外链接中主表记录一定会保存: 连接之后不会出现记录数少于主表 (内连接可能)
2. 左连接和右连接起始可以互相转换, 但是数据对应位置(表顺序) 会改变

**应用**

非常常用的一种获取数据的方式.: 作为数据获取对应主表以及其他数据(关联). 

### Using 关键字

是在连接查询中用来代替对应的 on 关键字的, 进行条件匹配

**原理**

1. 在连接查询时, 使用 on 的地方用 using 代替.
2. 使用 using 的前提, 是对应的两张表中连接的字段是同名的 (类似自然连接自动匹配).
3. 如果使用 using 关键字, 那么对应的同名字段, 最终在结果中只会保留一个.

**语法**

基本语法: `表1 [inner, left, right] join 表2 using(同名字段列表); `  

```mysql
#	select * from my_gb left join my_class on my_gb.class_id = my_class.id;
select my_gb.*,my_class.class_name from my_gb left join my_class using(class_id);
```

![53472792902](./MySQL\1534727929022.png)



## 子查询

### 什么是子查询

**子查询概念**

子查询: sub query

子查询是一种常用的计算机语言 SELECT-SQL 语言中 **嵌套查询下层的程序模块**. 当一个查询是另一个查询的条件时, 称之为子查询.

子查询: 指在一条查询语句中, 嵌入了另外一条 select 语句, 那么被嵌入的 select 语句称之为子查询语句.

**主查询概念**

主查询: 主要的查询对象, 第一条 select 语句, 确定的用户所有获取的数据目标 (数据源), 已经要具体得到字段信息.

**子查询和主查询的关系**

1. 子查询是嵌入到主查询中的
2. 子查询是辅助主查询的: 要么作为条件, 要么作为数据源
3. 子查询其实可以独立存在: 是一条完整的 select 语句

### 子查询分类

**按功能分**

- 标量子查询: 子查询返回的结果是一个数据 (一行一列)
- 列子查询: 返回的结果是一列 (一列或多列)
- 行子查询: 返回结果是一行 (一行多列)
- 表子查询: 返回结果是多行多列
- Exists 子查询: 返回的结果是 1 或者 0 (类似布尔操作)

**按位置分**

- Where 子查询: 子查询出现的位置在 where 条件中
- From 子查询: 子查询出现的位置在 from 数据源中 (作为数据源)

### 标量子查询

**概念**

标量子查询: 子查询得到的结果是一个数据 (一行一列)

**语法**

基本语法: 

`select * from 数据源 where 条件判断 =/<=> (select 字段名 from 数据源 where 条件判断);` 得到的结果只有一个值.

```mysql
#	只要一个学生的名字: 小白, 想知道他在哪个班级 (班级名字)
#	1. 通过学生表获取他所在班级 ID
#	2. 通过 ID 获取班级名字
select * from my_gb where class_id=(select my_class.id from my_class where class_name = '一班');
```

![53473000083](./MySQL\1534730000835.png)

通过标量子查询结果, 辅助主查询获得数据.

![53472988389](./MySQL\1534729883899.png)

### 列子查询

**概念**

列子查询: 列子查询返回的结果是一列数据 (一列多行)

**语法**

基本语法: `主查询 where 条件 in (列子查询);`  是一个数据集合

```mysql
# 	想要查找 my_class 中的 class_name 在 my_gb 中出现过的班级结果
#	1. 找出 my_gb 中所有的班级 ID
#	2. 找出 my_class 中对应的班级名称
select class_name from my_class where id in (select class_id from my_gb); 
```

![53473080735](./MySQL\1534730807355.png)

![53473075052](./MySQL\1534730750526.png)

### 行子查询

**概念**

行子查询: 子查询返回的结果是一行多列.

**行元素**

行元素: 字段元素是指一个字段对应的值. 行元素对应的就**是多个字段. 多个字段合起来作为一个元素参与运算**, 把这种情况称之为**行元素**.

**语法**

基本语法: `主查询 where 条件[(构造一个行元素)] = (行子查询);`

```mysql
#	获取班级上年龄最大, 且身高最高的学生
#	1. 求出班级年龄最大值
#	2. 求出班级身高最高值
#	3. 求出对应的学生
select * from my_gb where (age, height) = (select max(age),max(height) from my_gb);
```

![53473413885](./MySQL\1534734138856.png)

添加一条符合条件的数据.再进行行子查询.

![53473423337](./MySQL\1534734233377.png)

```mysql
#	select * from my_gb having age = max(age) and height = max(height);
#	这样查询错误的原因: 
#	1. having 是在 group by之后: 使用having代表着前面的  group by 执行了一次 (聚合函数使用)
#	2. 一旦 group by 执行, 结果就是只返回一行记录: 第一行
```

**总结**

已经学的三个子查询: 常见的三个子查询(标量子查询 列子查询 和 行子查询), 都属于 where 子查询.

### 表子查询

**概念**

表子查询: 子查询返回的结果是多行多列. 表子查询与行子查询非常相似. 只是行子查询需要产生行元素, 而表子查询没有.

行子查询用于 where 条件判断: where 子查询 

表子查询用于 from 数据源: from 子查询

**语法**

基本语法: `Select 字段表 from (表子查询) as 别名;`

```mysql
#	获取每个班上最高身高的学生(一个/班)
# 	1. 将每个班最高的学生排在最前面: order by
# 	2. 再针对结果进行 grouo by: 保留每组第一个
select * from (select * from my_gb order by height desc) as temp group by class_id;
```

我的报错了...

![53473557300](./MySQL\1534735686606.png)

老师的: 

![53473561283](./MySQL\1534735612839.png)

### Exists 子查询

**概念**

exists 子查询: 查询返回的结果只有 0 或 1, 1代表成立, 0代表不成立

**语法**

基本语法: `where exists(查询语句);` exists 就是根据查询结果进行判断: 如果存在返回1, 否则返回0 

Where 1: 永远为真.

```mysql
#	求出有学生在的所有班级
select * from my_class where exists(select class_id from my_gb where my_gb.class_id = my_class.id);
```

![53473746781](./MySQL\1534737467813.png)

### 子查询中特定关键字的使用

- In

  `主查询 where 条件 in (列子查询);`

- Any

  任意一个

  `= any(列子查询)` : 条件在查询结果中有任意一个匹配即可, 等价于 in. `1 = any(1,2,3) ===== true`

  `<> any(列子查询)` : 条件在查询结果中不等于任意一个.  `1 <>any(1,2,3) ===== true`

- Some

  与 any 完全一样: 在国外, some 与 any 的正面含义一致, 如果是否定就大不相同: not any 与 not some

  开发者为了让队友的使用者不要再语法上纠结: 重新设计了 some

- ALL

  `= all(列子查询)` : 等于里面所有

  `<> all(列子查询)` : 不等于里面所有

```mysql
select * from my_gb where class_id in (select id from my_class);
select * from my_gb where class_id = any (select id from my_class);
select * from my_gb where class_id <> any (select id from my_class);
select * from my_gb where class_id = all (select id from my_class);
select * from my_gb where class_id <> all (select id from my_class);
```

![53473842642](./MySQL\1534738426428.png)

![53473865236](./MySQL\1534738652368.png)

![53473883344](./MySQL\1534738833443.png)

![53473920017](./MySQL\1534739200175.png)



## 整库数据备份与还原

整库数据备份也叫 SQL 数据备份: 备份的结果都是 SQL 指令

在 MYSQL 中提供了一个专门用于备份 SQL 的客户端: mysqldump.exe

![53474025288](./MySQL\1534740252889.png)

**应用场景**

SQL 备份是一种 mysql 非常常见的备份与还原方式, SQL 备份不只是备份数据, 还备份对应的 sql 指令(表结构):即便是数据库遭到毁灭性的破坏 (数据库被删), 那么利用 sql 备份依然可以实现数据还原.

SQL 备份因为需要备份结构, 因此产生的备份文件特别大, 因此不适合特大型数据备份, 也不适合数据变换频繁型数据库备份.

**应用方案**

### SQL 备份

SQL 备份用到的是专门的备份客户端, 因此还没与数据库服务器进行连接.

基本语法: `mysqldump/mysqldump.exe -hPup 数据库名字 [表1 [表2...]] > 备份文件地址`

备份可以有三种形式: 

1. 整库备份 (只需要提供数据库名字)
2. 单表备份: 数据库后面跟一张表
3. 多表备份: 数据库后面跟多张表

**利用mysqldump进行整库备份**

```
mysqldump.exe -hlocalhost -P3306 -uroot -pwoaiwo mydatabase3 > C:\Users\mengbao\Desktop\data.sql
```

![53474071781](./MySQL\1534740717819.png)

**利用 mysqldump 进行多表备份**

```
mysqldump.exe -uroot -pwoaiwo mydatabase3 my_gb my_class > C:\Users\mengbao\Desktop\data2.sql
```

![53474095487](./MySQL\1534740954876.png)



查看备份文件的具体内容 (全是sql语句)

![53474123329](./MySQL\1534741346992.png)



### 数据还原

Mysql 提供了多种方式来实现: 两种

Mysqldump 备份的数据中没有关于数据库本身的操作, 都是针对表级别的操作, 在进行数据 (sql还原), 必须指定数据库.

1. 利用 mysql.exe 客户端: 没有登陆之前, 可以是直接用该客户端进行数据还原, `Mysql.exe -hPup 数据库 < 文件位置`
2. 在 SQL 指令, 提供了一种导入 SQL 指令的方式 `Source SQL文件位置;` //必须进入到对应的数据库
3. 人为操作: 打开备份文件, 复制所有 sql 指令, 然后到 mysql.exe 客户端去黏贴执行.(不推荐)

```
mysql.exe -uroot -pwoaiwo mydatabase3 < C:\Users\mengbao\Desktop\data.sql
```

![53474213798](./MySQL\1534742137981.png)

执行导入数据之后, 我们再次查看数据库.

![53474230559](./MySQL\1534742305591.png)

```mysql
source C:\Users\mengbao\Desktop data2.sql;
```

删除数据表

![53474259219](./MySQL\1534742592197.png)

还原操作 (见鬼报错了...)

![53474301304](./MySQL\1534743070997.png)

老师的

![53474304031](./MySQL\1534743040312.png)

不行了...我还是使用第一种方式还原

```
mysql.exe -uroot -pwoaiwo mydatabaseNew < C:\Users\mengbao\Desktop\data2.sql
```

![53474333002](./MySQL\1534743330026.png)



## 用户权限管理

用户权限管理: 在不同的项目中以及给不同的角色(开发者) 不同的操作权限, 为了保证数据库数据的安全.

通常, 一个用户的密码不会长期不变, 需要经常性地变更数据库用户密码, 确保用户本身安全(mysql客户端用户)

### 用户管理

Mysql 需要客户端进行连接认证才能进行服务器操作: 需要用户信息. Mysql 中的所有的用户信息都是保存在 mysql 数据库中的 user 表中

![53474408371](./MySQL\1534744244736.png)

默认的, 在安装 Mysql 的时候, 如果不选择创建匿名用户, 那么意味着所有的用户只有一个: root 超级用户.

![53474450778](./MySQL\1534744507780.png)

在 mysql 中, 对应的用户管理中, 是由对应的 host  和 user 共同组成主键来区分用户.

user: 代表用户的用户名

host: 代表本质是允许访问的客户端 (IP 或主机地址). 如果  host 使用 *  代表所有的用户(客户端) 都可以访问.

#### 创建用户

理论上可以使用两种方式创建用户:

1. 直接使用 root 用户在 mysql.user 表中插入记录(不推荐)

2. 专门创建用户的 sql 指令

   基本语法: `create user 用户名 identified by '明文密码';`

   用户: 用户名@主机地址

   主机地址: `''` 或 `%` 匹配

   ```mysql
   #	创建一个用户
   create user 'user1'@'%' identified by '123456';
   ```

   ![53474536490](./MySQL\1534745364905.png)

   查看 mysql.user 表中是否存在新增用户

   ![53474542606](./MySQL\1534745426069.png)

   简化创建用户(谁都可以访问, 不需要密码). 不推荐

   ![53474553587](./MySQL\1534745593875.png)

   用户创建完毕, 查看用户是否可用. (直接进入 刚创建的user2 未输入密码直接进来了, 可用.)

   ![53474567321](./MySQL\1534745673211.png)

#### 删除用户

注意: mysql 中 user 是带着host本身的 (具有唯一性)

基本语法: `drop user 用户名@host;`

```mysql
drop user user2;
```

![53474587756](./MySQL\1534745877566.png)

#### 修改密码

Mysql 中提供了多种修改的方式: 基本上都是必须使用对应提供的一个系统函数: `password()`,需要靠函数对应密码进行加密处理.

1. 使用专门的修改密码的指令

   基本语法: `set password for 用户 = password('新的明文密码');`

   ```mysql
   set password for 'user1'@'%' = password('woaiwo');
   ```

   ![53474621501](./MySQL\1534746215017.png)

2. 使用更新语句 update 来修改

   基本语法: `update mysql.user set password = password('新的明文密码') where user = '' and host = '';`

   ```mysql
   #	update mysql.user set password = password('woaiwo') where user = 'user1' and host = 'localhost';
   # 	这种方式已经不行了. 因为查询结果中 已经没有显示 password 字段
   ```

   ![53474682027](./MySQL\1534746820275.png)

   ![53474679898](./MySQL\1534746798986.png)

### 权限管理

在 mysql 中将权限管理分为三类:

1. 数据权限: 增删查改 (select update delete insert); 一般用户只授予这个权限
2. 结构权限: 结构操作 (create drop)
3. 管理权限: 权限管理 (create user grant revoke); 通常只给管理员如此权限

新创建的表没有权限.

![53474690801](./MySQL\1534746908012.png)

#### 授予权限: grant

将权限分配给指定的用户

基本语法: `grant 权限列表 on 数据库/*.表名/*to 用户;` 

权限列表: 使用都好分隔, 但是可以使用 `all privileges` 代表全部权限

数据库.表名: 可以是单表(数据库名字.表名), 可以使具体某个数据库(数据库.*), 也可以整库 (\*.\*)

```mysql
#	分配查看权限给 user1 用户
grant select on mydatabaseNew.my_gb to 'user1'@'%';
```

![53474757637](./MySQL\1534747576374.png)

权限分配成功, 我们可以在 user1 用户下 查看该表. 但是也仅有查看的权限, 因为 root 只分配了 查看权限.

![53474769473](./MySQL\1534747694731.png)

如果我们尝试修改. 非常遗憾, 没有权限修改.

![53474776676](./MySQL\1534747766769.png)

#### 取消权限: revoke

权限回收: 将权限从用户手中回收

基本语法: `revoke 权限列表/all privileges from 用户`

```mysql
# 	回收查看权限从 user1 用户
revoke select on mydatabaseNew.my_gb from 'user1'@'%';
```

![53474832378](./MySQL\1534748323784.png)

#### 刷新权限: flush

Flush: 刷新, 将当前对用户的权限操作, 进行刷新, 将操作的具体内容同步到对应的表中.

基本语法: `flush privileges;`

![53474855864](./MySQL\1534748558647.png)

### 密码丢失的解决方案

如果忘记了 root 用户密码, 就需要去 找回/重置 root 用户密码.

1. 停止服务: `net stop mysql`

   ![53474922468](./MySQL\1534749224682.png)

2. 重新启动服务: `mysqld.exe --skip-grant-tables` // 启动服务器当跳过权限

   ![53474958417](./MySQL\1534749584171.png)

3. 当前启动的服务器没有权限概念: 非常危险, 任何客户端不需要任何用户信息都可以直接登录, 而且是 root 权限 (新开客户端, 使用 mysql.exe 登录即可)

   ![53474956081](./MySQL\1534749560816.png)

   ![53474970463](./MySQL\1534749704636.png)

4. 修改 root 用户密码: 指定用户名@host `update mysql.user set password = password('root') where user= 'root' and host = 'localhost';`

   ![53474983877](./MySQL\1534749838774.png)

   ![53474986833](./MySQL\1534749868339.png)

   我这里修改不了. fuck....

   我们来看老师的..

   ![53475043761](./MySQL\1534750437612.png)

5. 关闭服务器重启服务 (任务管理器关闭 mysqld.exe)

**反正密码别忘记**



## 外键

**概念**

​	如果公共关键字在一个关系中是主关键字, 那么这个公共关键字被称为另一个关系的外键. 由此可见, 外键表示两个关系之间的相关联系. 以另外一个关系的外键作主关键字的表被称为主表, 具有此外键的表被称为主表的从表. 外键又称做外关键字.

外键: foreign key

一张表 (A) 中有一个字段, 保存的值指向另外一张表 (B) 的主键

B: 主表 

A: 从表

### 外键的操作

#### 增加外键

Mysql 提供了两种方式增加外键 

1. 创建表的时候增加外键(类似主键)

   基本语法: 在字段之后增加一条语句

   `[constraint '外键名'] foreign key(外键字段) references 主表(主键)`

   ```mysql
   #	增加外键
   #	创建表时增加
   create table my_foreign(
   id int primary key auto_increment,
   name varchar(10) not null,
   class_id int,
   foreign key(class_id) references my_class(id)
   )charset utf8;
   ```

   ![53475352639](./MySQL\1534753526391.png)

   MUL :多索引, 外键本身是一个索引, 外键要求外键字段本身也是一种普通索引

   ![53475383238](./MySQL\1534753832380.png)

2. 在创建表之后增加外键

   alter table 从表 add [constraint \`外键名\`] foreign key(外键字段) references 主表(主键);

   ```mysql
   # 	修改 my_gb 表, 将 class_id 设为外键字段 自定义外键名字
   alter table my_gb add constraint `student_class_ibfk_1` foreign key(class_id) references my_class(id);
   ```

   ![53475425800](./MySQL\1534754258004.png)

   ![53475439762](./MySQL\1534754397626.png)

   外键名字可以定义

   ![53475435522](./MySQL\1534754355228.png)

#### 修改&删除外键

外键不允许修改, 执行删除后增加

基本语法: `alter table 从表 drop foreign key 外键名字;`

```mysql
#	删除外键
alter table my_gb drop foreign key student_class_ibfk_1;
```

![53475549611](./MySQL\1534755692633.png)

外键不能删除产生的普通索引, 只会删除外键自己, 如果想删除对应的索引: `alter table 表名 drop index 索引名字`

```mysql
alter table my_gb drop index student_class_ibfk_1;
```

![53475598014](./MySQL\1534755980143.png)

#### 外键基本要求

1. 外键字段需要保证与关联的主表的主键字段类型完全一致.
2. 基本属性也要相同.
3. 如果是在表后增加外键, 对数据还有一定的要求(从表数据与主表的关联关系).
4. 外键只能使用 innodb 存储引擎.: myisam 不支持.

### 外键约束

外键约束: 通过建立外键关系之后, 对主表和从表都会有一定的数据约束效率.

**约束基本概念**

1. 当一个外键产生时: 外键所在的表 (从表) 会受制于主表数据的存在从而导致数据不能进行某些不符合规范的操作 (不能插入主表不存在的数据)

   ```mysql
   #	在从表中插入一条主表中存在的数据
   insert into my_foreign values(null, '小白', 1);
   #	在从表中插入一条主表中不存在的数据
   insert into my_foreign values(null, '小黑', 5);
   ```

   ![53475707642](./MySQL\1534757076429.png)

2. 如果一张表被其它表外键引入, 那么该表的数据操作就不能随意, 必须保证从表数据的有效性 (不能随便删除一个被从表引入的记录).

   ![53475750375](./MySQL\1534757503753.png)

#### 外键约束的概念

可以在创建外键的时候, 对外键约束进行选择性的操作.

基本语法: `add foreign key(外键字段) references 主表(主键) on 约束模式;`

约束模式有三种:

1. district: 严格模式, 默认的, 不允许操作
2. cascade: 级联模式, 仪器操作, 主表变化, 从表数据跟随变化
3. set null: 置空模式, 主表变化 (删除), 从表对应记录设置为空, 前提是从表中对应的外键字段允许为空.

外键约束主要约束的对象是主表操作; 从表就是不能插入一个主表不存在的数据.

通常在进行约束使用的时候, 需要指定一个操作: update 和 delete

常用的约束模式: `on update cascade on delete set null` 更新级联, 删除置空.

```mysql
#	设置常用的约束: 更新级联, 删除置空
alter table my_gb add foreign key(class_id) references my_class(id) on update cascade on delete set null;
```

![53476020896](./MySQL\1534760208965.png)

![53476028637](./MySQL\1534760286372.png)

更新主表的内容. 展示从表的数据.

![53476045037](./MySQL\1534760450370.png)

删除主表内容, 从表设置数据为空.

![53476064452](./MySQL\1534760644520.png)

#### 约束的作用

1. 保证数据的完整性: 主表与从表数据要一致.
2. 正因为外键有非常强大的数据约束作用, 而且可能会导致数据在后台变化的不可控. 导致程序在进行设计开发逻辑的时候就没有办法去很好地把我数据 (业务). 所以外键比较少使用.



## 视图的基本操作

### 创建视图

视图本质是 SQL 指令(select语句)

基本语法: `create view 视图名字 as select 指令;` //	可以使单表数据, 也可以是连接查询, 联合查询1或子查询

```mysql
#	创建视图
create view gb_class_v as select s.*,c.class_name from my_gb as s left join my_class as c on s.class_id = c.id; 
```

![53476157344](./MySQL\1534761573444.png)

![53476163710](./MySQL\1534761637107.png)

`Show tables/show create table [view]/desc 视图名字;` 都可以操作视图(虚拟表)

![53476177498](./MySQL\1534761774980.png)

### 使用视图

视图是一张虚拟表: 可以直接把视图当做 "表" 操作, 但是视图本身没有数据. 是临时执行 select 语句的到对应的结果. 视图主要用于查询操作.

基本语法: `select 字段列表 from 视图名字 [子句];`

```mysql
#	查询视图
select * from gb_class_v;
```

![53476275842](./MySQL\1534762758422.png)

### 视图修改

视图修改: 本质是修改视图对应的查询语句

基本语法: `alter view 视图名字 as 新的 select 指令;`

```mysql
alter view gb_class_v as select * from my_gb as s left join my_class as c using(class_id);
```

### 删除视图

基本语法: `drop view 视图名字;`

```mysql
drop view gb_class_v;
```

执行删除视图语句. 视图就被从数据库中删除了.



## 事务安全

**事务概念**

​	事务是访问并可能更新数据库中各种数据项的一个 **程序执行单元**. 事务通常由高级数据库操作语言或编程语言书写的用户程序执行所引起. 事务由事务开始和事务结束之间执行的全体操作组成.

**基本原理** 

Mysql 允许将事务统一进行管理 (存储引擎 INNODB), 将用户所做的操作, 暂时保存起来, 不直接放到数据表 (更新), 等到用户确认结果之后再进行操作.

![53476406531](./MySQL\1534764065314.png)

事务在 mysql 中通常是自动提交的, 但是也可以使用手动事务.

### 自动事务

自动事务: autocommit, 当客户端发送一条 sql 操作(写操作: 增删改) 给服务器的时候, 服务器的时候, 服务器在执行之后, 不用等待用户反馈结果, 会自动将结果同步到数据表.

证明:  利用两个客户端, 一个客户端执行 SQL 指令, 另外一个客户端查看执行结果.

![53476443165](./MySQL\1534764431650.png)

自动事务: 系统做了额外的步骤来帮助用户操作, 系统时通过变量来控制的. Autocommit.

我们可以通过指令 `Show variables like 'autocommit%';` 查看

```mysql
show variables like 'autocommit%';
```

![53476462569](./MySQL\1534764625693.png)

**关闭自动事务**

关闭之后, 系统就不再帮助用户提交结果了.

执行指令 `set autocommit = off;`

```mysql
set autocommit = off;
```

![53476472645](./MySQL\1534764726456.png)

验证

![53476483964](./MySQL\1534764839645.png)

一旦自动事务关闭, 那么就需要用户提供是否同步的命令.

事务没有提交的对比查看: 在执行事务的客户端中, 系统在进行数据查看的时候会利用事务日志中保存的数据对数据进行加工

![53476519573](./MySQL\1534765195738.png)

**Commit**: 提交 (同步到数据库: 事务也会被清空)

![53476532776](./MySQL\1534765327760.png)

**Rollback**: 回滚 (清空之前的操作, 不要了)

![53476552295](./MySQL\1534765624433.png)

通常我们不会关闭自动事务, 否则操作太麻烦了. 因此我们只会在需要使用事务处理的时候, 才会进行操作(手动事务).

让我们开启自动事务, 开心地执行数据库写操作吧.

![53476587405](./MySQL\1534765874059.png)

### 手动事务

手动事务: 不管是开始还是过程还是结束, 都需要用户 (程序员), 手动发送事务发送指令.

手动事务对应的命令:

1. `start transaction;` //  开启事务, 从这条语句开始, 后面的所有语句都不会直接写入到数据表 (保存在事务日志中)
2. 事务处理: 多个写指令构成
3. 事务提交: `commit/rollback;`, 到这个时候, 所有的事务才算结束.

**开启事务**

```mysql
#	开启事务
start transaction;
```

![53476611534](./MySQL\1534766115341.png)

**执行事务**

将多个连续的但是是一个整体的 sql 指令, 逐一执行

1. 事务1: 新增数据

   ![53476634311](./MySQL\1534766343118.png)

2. 事务2: 更新数据

   ![53476682175](./MySQL\1534767062447.png)

#### 提交事务

确定提交: commit, 数据写到数据表(清空)

提交前:

![53476716708](./MySQL\1534767167086.png)

执行 `commit;` (事务提交)命令后

![53476730577](./MySQL\1534767305778.png)

#### 回滚事务

回滚操作: rollback, 所有数据无效并清空

![53476552295](./MySQL\1534765624433.png)

#### 回滚点

回滚点: savepoint, 当一系列事务操作时, 而其中的步骤如果成功了, 没有必要重新来过. 可以在某个点(成功), 设置一个记号 (回滚点), 如果后面又失败, 那么可以回到这个记号位置.

增加回滚点: `savepoint 回滚点名字;` //  字母数字和下划线构成

回到回滚点: `rollback to 回滚点名字;` //  记号(回滚点) 之后的所有操作没有了

注意: 在一个事务处理中, 如果有很多个步骤, 可以设置多个回滚点. 但是如果回到了前面的回滚点, 后面的回滚点就失效了.

演示

```mysql
#	开始事务
start transaction;
#	提交事务
commit;
#	增加回滚点
savepoint sp1;
#	回滚到指定标记
rollback to sp1;
```

1. 增加回滚点

   ![53477009009](./MySQL\1534770090099.png)

2. 出现错误步骤(假设)

   ![53477011327](./MySQL\1534770113275.png)

3. 回到正确点: 回滚

   ![53477014997](./MySQL\1534770149971.png)

   提交事务

   ![53477018956](./MySQL\1534770189561.png)

   查看其他客户端数据情况

   ![53477023042](./MySQL\1534770230421.png)

### 事务安全(特点)

事务应该具有四个属性: **原子性 一致性 隔离性 持久性**. 这四个属性通常被称为 ACID 特性

- **原子性**(atomicity). 一个事务是一个不可分割的工作单位, 事务中包括的诸操作要么都做, 要么都不做.

  ​	事务从 start transaction 起到提交事务 (commit 或 rollback), 要么所有的操作都成功, 要么就是所有操作都失败(回滚).

- **一致性**(consistency). 事务必须是使数据库从一个一致性状态变到另一个一致性状态. 一致性与原子性密切相关的.

  ​	数据表中的数据修改, 要么是所有操作一次性修改, 要么就是根本不动.

- **隔离性**(isolation). 一个事务的执行不能被其它事务干扰. 即一个事务内部的操作及使用的数据对并发的其它事务是隔离的, 并发执行的各个事务之间不能互相干扰.

  ​	如果一个客户端在使用事务操作一个数据 (可能一行/整行) 的时候, 另外一个客户端不能对该数据进行操作.

  ![53477102754](./MySQL\1534771027545.png)

  什么时候是行被隔离, 什么时候是整表被隔离呢?

  说明: 如果条件中使用了索引 (主键), 那么系统时根据主键直接找到某条记录, 这个时候与其他记录无关, 那么只隔离一条数据; 反之, 如果说系统是通过全表检索 (每一条记录都去检查, 没有索引), 被检索的所有数据都会被锁定 (整表).

- **持久性**(durability). 持久性也称永久性. 指一个事务一旦提交, 它对数据库中的数据的改变就应该是永久性的. 接下来的其他操作或故障不应该对其有任何影响.

  ​

## 变量

Mysql 本质是一种编程语言, 需要很多变量来保存数据. mysql 中很多的属性控制都是通过 mysql 中固有的变量来实现的.

### 系统变量

系统内部定义的变量, 系统变量针对所有用户 (MySQL 客户端) 有效.

查看系统所有变量 `show variables [like 'pattern'];`

![53477159534](./MySQL\1534771595349.png)

![53477154879](./MySQL\1534771548793.png)

Mysql 允许用户使用 select **查询变量的数据值** (系统变量)

基本语法: `select @@变量名;`

```mysql
select @@autocommit;
```

![53477170917](./MySQL\1534771709173.png)

修改系统变量: 分两种修改方式

1. 局部修改 (会话级别):只针对当前自己客户端此次连接有效

   基本语法: `set 变量名 = 新值;`

   ```mysql
   set autocommit = 0;
   ```

   ![53477192976](./MySQL\1534771929767.png)

2. 全局修改: 针对所有的客户端, "所有时刻" 都有效

   基本语法: `set global 变量名 = 值;` 或 `set @@global.变量名 = 值;`

   ```mysql
   set global autocommit = 0;	# 	全局修改 自动提交
   set @@global auto_increment_increment = 2;	## 全局修改自动增长步长
   ```

   ![53477213604](./MySQL\1534772136042.png)

   全局修改之后, 所有连接的客户端并没有发现改变? 全局修改只针对新客户端生效 (正在连接的客户端无效).

   ![53477223865](./MySQL\1534772238653.png)

    如果想要本次连接对应的变量修改有效, 不能使用全局修改, 只能修改会话级别修改 (set 变量=值).

### 会话变量

会话变量也称之为用户变量, 会话变量跟 mysql 客户端是绑定的, 设置的变量, *只对当前用户使用的客户端生效*

基本语法: `set @变量名 = 值;`.

```mysql
set @name = 'hello mysql!';
```

![53477276980](./MySQL\1534772769801.png)

在 mysql 中没有比较符号 `==` , 所以用 `=` 代替比较符号, 有时候在赋值的时候, 会报错, mysql 为了避免系统分不清楚是赋值还是比较. 特意增加了一个赋值符号 `:=`. 

```mysql
set @name := 'hello mysql!'
```

 Mysql 是专门存储数据的: 允许将数据从表中取出来, 存储到变量中, 查询得到的数据必须只能是一行数据 (一个变量对应一个字段值), Mysql 没有数组.

1. 赋值且查看赋值过程: `select @变量1 := 字段1, @变量2 := 字段2 from 数据表 where 条件;`

   ```mysql
   #	错误示范: selct @变量1 = 字段1, @变量2 = 字段2 from 数据表 where 条件;	//	这里将 = 号作比较使用了.
   #	正确使用
   select @name := name, @age := age from my_gb limit 1;
   ```

   ![53477395004](./MySQL\1534773950041.png)

2. 只赋值不看过程: `select 字段1, 字段2... from 数据源 where 条件 into @变量1, @变量2...;`

   ```mysql
   select name, age from my_gb order by height desc limit 1 into @name, @age;
   ```

   ![53477413417](./MySQL\1534774134176.png)

### 局部变量

作用范围在 begin 到 end 语句块之间. 在该语句块里设置的变量, declare 语句专门用于定义局部变量.

1. 局部变量是使用 declare 关键字声明
2. 局部变量 declare 语句出现的位置一定是在 begin 和 end 之间 (begin 和 end是在大型语句块中使用: 函数/存储过程/触发器)
3. 声明语法: `declare 变量名 数据类型 [属性];`

### 变量作用域

变量作用域: 变量能使用的访问

**局部作用域**

使用 declare 关键字声明 (在结构体内: 函数/存储过/触发器), 而且只能在结构体内部使用

declare 关键字声明的变量没有任何符号修饰, 就是普通字符串, 如果在外部访问该变量, 系统会自动认为是字段.

**会话作用域**

用户定义的, 使用 @符号定义的变量, 使用 set 关键字定义 `set @变量名 = 值;`

会话作用域: 在当前用户当次连接有效, 只要在本次连接中, 任何地方都可以使用,

```mysql
set @name = '小白';
create function my_name() returns char(4)
return @name;
```

![53482083176](./MySQL\1534820831760.png)

![53482088650](./MySQL\1534820886503.png)

**全局作用域**

所有客户端所有的连接都有效:需要使用全局符号来定义

```mysql
set global 变量名 = 值;
set @@global.变量名 = 值;
```

通常, 在SQL编程的时候, 不会使用自定义变量来控制全局. 一般都是定义会话变量或者在使用局部变量来解决问题.

## 流程结构

流程结构: 代码的执行顺序

### if 分支

**基本语法**

 if 在 Mysql 中有两种基本用法

1. 用在 select 查询当中, 当做一种条件来进行判断

   基本语法: `if(条件,为真结果,为假结果)`

   ```mysql
   #	查询符合条件的 
   #	select * from my_gb age > 25;
   #	select *,if(age >= 25,'符合','不符合') as judge from my_gb where age >= 25;
   select *,if(age > 25,'符合','不符合') as judge from my_gb;
   ```

   ![53477565172](./MySQL\1534775651727.png)

2. 用在复杂的句块中 (函数/存储过程/触发器)

   基本语法: 

   ```mysql
   if 条件表达式 then
   	满足条件要执行的语句;
   End if;
   ```


**复合语法**

复合语法: 代码的判断存在两面性, 两面都有对应的代码执行.

基本语法: 

```mysql
if 条件表达式 then
	满足条件要执行的语句;
else 
	不满足条件要执行的语句;
	#	如果还有其他分支(细分), 可以在里面再使用 if 
	if 条件表达式 then
		满足条件执行的语句;
	End if;
End if;
```

### While循环

**基本语法**

循环体都是需要在大型代码块中使用.

基本语法:

```mysql
While 条件 do
	要循环执行的代码;
End while;
```

**结构标识符**

结构标识符: 为某些特定的结构进行命名, 然后为的是在某些地方使用名字.

基本语法: 

```mysql
标识名字:While 条件 do
	循环体;
End while[标识名字];
```

标识名字的存在主要是为了循环体中使用循环控制, 在 mysql 中没有 continue 和 break, 有自己的关键字替代:

itearate: 迭代, 就是以下代码不执行, 重新开始循环 (continue)

leave: 离开, 整个循环终止 (break)

```mysql
标识名字:While 条件 do
	if 条件判断 then
		-- 循环控制;
		iterate -- /leave 标识名字
	End if;
End while[标识名字];
```



## 函数

在 mysql 中, 函数分为两类: **内置函数**, **用户自定义函数**.

不管是内置函数还是用户自定义函数, 都是使用 `select 函数名(参数列表);`

### 内置函数

- 时间函数
  - from_unixtime(): 将存储的秒值, 转成 unix 时间戳. 如 from_unixtime('时间秒数')
  - date_format(时间戳, 格式): 如date_format('2018-10-27','%Y年%m月')

- 字符串函数
  - char_length(): 判断字符串的字符数.
  - length(): 判断字符串的字节数 (与字符集).
  - concat(): 连接字符串
  - instr(): 判断字符串在目标字符串中是否存在, 存在返回位置, 不存在返回 0
  - lcase(): 全部小写
  - left(): 从左侧指定位置开始截取字符串
  - ltrim(): 消除左侧对应的空格
  - mid(): 从哪找年间指定位置开始截取, 如果不指定截取长度, 直接到最后

```mysql
select char_length('你好中国'), length('你好中国');

select concat('你好', '中国'), instr('你好中国', '中国'), instr('你好中国','你');

select lcase('Hello China'), left('你好中国', 2), mid('你好中国',3);

select ltrim(' Hello China');
```

![53477967154](./MySQL\1534779671540.png)

![53477975854](./MySQL\1534779758546.png)

![53477989990](./MySQL\1534779899900.png)

![53477994654](./MySQL\1534779946543.png)

- 时间函数

  - now(): 返回当前时间, 日期 时间

  - curdate(): 返回当前日期

  - curtime(): 返回当前时间

  - datediff(): 判断两个值日时间的天数差距, 参数日期必须使用字符串格式(用引号

  - date_add(日期, interval 时间数字 type): 进行时间的增加

     Type: day/hour/minute/second

  - unix_timestamp(): 获取时间戳

  - from_unixtime(); 将事件戳转换指定日期格式

```mysql
select now(), curdate(), curtime();

select datediff('2018-01-01','2018-08-20');

select date_add('2018-08-20', interval 10 day), date_add('2018-08-20', interval 10 year), date_add('2018-08-20', interval 10 hour);

select unix_timestamp();

select from_unixtime(1234567890);
```

![53478029933](./MySQL\1534780299331.png)

![53478039491](./MySQL\1534780394918.png)

![53478050413](./MySQL\1534780504137.png)

![53478056813](./MySQL\1534780568134.png)

![53478066459](./MySQL\1534780664599.png)

- 数学函数
  - abs(): 绝对值
  - ceiling(): 向上取整
  - floor(): 向下取整
  - pow(): n的n次方
  - rand(): 获取随机数(0-1之间)
  - round(): 四舍五入函数

```, round(1.5)mysql
select abs(-1), ceiling(1.1), floor(1.1), pow(2,4), rand();
```

![53478206659](./MySQL\1534782066599.png)

- 其它函数
  - md5(): 对函数进行 md5 加密 (mysql中的 md5 与其他任何地方的md5加密出来的内容是完全相同的)
  - version(): 获取版本号
  - database(): 显示当前所在数据库
  - UUID(): 生成一个唯一标识符 (自增长), 自增长是单标唯一, UUID 是整库 (数据唯一同时空间唯一)

```mysql
select md5('woaiwo'), version(), database(), UUID();
```

![53478381442](./MySQL\1534783814425.png)

### 自定义函数

自定义函数: 用户自己定义的函数.

函数: 实现某种功能的语句块, 由多条语句组成

1. 函数内部的某条指令都是一个独立的个体: 需要符合语句定义规范: 需要语句结束符分号.
2. 函数是一个整体, 而且函数是在调用的时候才会被执行, 那么设计函数的时候, 意味着整体不能被中断.
3. Mysql 一旦见到语句结束分号, 就自动开始执行.

解决方案: 在函数定义之前, 尝试修改临时的语句结束符

基本语法: `delimiter`

修改临时语句结束符: `delimiter 新符号;` (可以使用系统非内置即可 $$).

中间为正常 sql 指令: 使用分号结束 (系统不会执行: 此时不认识分号)

使用的新符号结束

修改回语句结束符: `delimiter ;`

**创建函数**

自定义函数包含几个要素: function 关键字, 函数名, 参数(形参和实参[可选]), 确认函数返回值类型, 函数体, 返回值

函数定义的基本语法

```mysql
修改语句结束符
create function 函数名(形参) returns 返回值类型
begin
	函数体
	return 返回值;	//	数据必须与结构中定义的返回值类型一致
end
语句结束符
修改语句结束符
```

创建一个没有参数的函数

```mysql
-- 修改语句结束符
delimiter $$
-- 创建一个函数
create function my_func1() returns int
begin
	return 10;
end
-- 结束
$$
-- 修改语句结束符(改回;号)
delimiter ;
```

![53481324338](./MySQL\1534813243380.png)

并不是所有函数都需要 begin 和 end:  如果函数体本身只有一条指令 (return), 那么可以省略 begin 和 end

```mysql
-- 最简函数
create function my_func2() returns int
return 100;
```

![53481326041](./MySQL\1534813260412.png)

在 mysql 中需要为函数的形参指定数据类型 (形参本身可以有多个)

基本语法: `变量名,字段类型`

```mysql
create function my_func3(int_1 int,int_2 int) returns int
return int_1 + int_2;
```

![53481744167](./MySQL\1534817441674.png)

**查看函数**

1. 可以查看 function 状态 

   ```mysql
   show function status [like '匹配规则'];
   ```

   查看所有的函数

   ![53481773373](./MySQL\1534817733733.png)

   匹配查看

   ![53481782036](./MySQL\1534817820362.png)

2. 查看函数创建语句: `show create function 函数名字;`

   ```mysql
   show create function my_func1\G
   ```

   ![53481796249](./MySQL\1534817962495.png)

**调用函数**

自定义函数的调用与内置函数的调用是一样的: `select 函数名(实参列表);`

```mysql
select my_func1(), my_func2(), my_func3(100, 1000);
```

![53481810872](./MySQL\1534818108724.png)

**删除函数**

基本语法: `drop function 函数名;`

```mysql
drop function my_func1;
```

![53481830347](./MySQL\1534818303478.png)

![53481832342](./MySQL\1534818323420.png)

#### 注意事项

1. 自定义函数是属于用户级别的: 只有当前客户端对应的数据库中可以使用

2. 可以在不同的数据下查看对应的函数, 但是不可以调用

   ![53481876532](./MySQL\1534818765329.png)

3. 自定义函数: 通常是为了将多行代码集合到一起解决一个重复性问题

4. 函数因为必须规范返回值: 那么在函数内部不能使用 select 指令: select 一旦执行就会得到一个结果 (result set): `select 字段 into @变量;` 唯一可用.

   ```mysql
   -- 修改语句结束符
   delimiter $$
   create function my_func5(sum int) returns int
   begin
   	select sum into @lover;
   	return @lover;
   end
   -- 结束
   $$
   -- 修改语句结束符(改回;号)
   delimiter ;
   select my_func5(520);
   ```

   ![53481922430](./MySQL\1534819224301.png)

### 函数流程结构案例

需求: 从1开始, 直到用户传入的对应的值为止, 自动求和, 凡是 5 的倍数都不要.

1. 创建函数

2. 需要一个形参, 确顶要累加到什么位置

3. 需要定义一个变量来保存对应的结果 set @变量名;

   使用一个局部变量来操作: 此结果是在函数内部使用

   declare 声明变量

4. 内部需要一个循环来实现迭代累加

5. 循环内部需要进行条件判断控制: 5的倍数跳过.

```mysql
-- 创建一个自动求和函数
-- 修改语句结束符
delimiter $$
-- 创建函数
create function my_sum(end_value int) returns int
begin
	-- 声明一个变量 赋予默认值
	declare res int default 0;
	declare i int default 1;
	-- 循环处理
	mywhile:while i <= end_value do
	 	-- 判断数据是否合理
	 	if i % 5 = 0 then
			set i = i + 1;
	 		-- 5的倍数, 跳过
	 		iterate mywhile;
	 	end if;
		-- 修改变量: 累加
		set res = res + i;
		set i = i + 1;
	end while;
	return res;
end
-- 结束
$$
-- 修改语句结束符
delimiter ;
```

![53482011768](./MySQL\1534820117689.png)

定义函数结构完成, 调用函数

```mysql
select my_sum(100), my_sum(-100);
```

![53482007388](./MySQL\1534820073887.png)



## 存储过程

存储过程 (stored Proceduure) 是在大型数据库系统中, 一组为了完成**特定功能的 SQL 语句集**, 存储在数据库中, 经过**第一次编译后再次调用不需要再次编译(效率提高)**, 用户通过指定存储过程的名字并给出参数(如果该存储过程带有参数) 来执行它, 存储过程使数据库中的一个重要对象.

存储过程:  简称过程

### 与函数的区别

**相同点**

1. 存储过程和函数目的都是为了可重复地执行操作数据库的 sql 语句的集合.
2. 存储过程函数都是一次编译, 后续执行.

**不同点**

1. 标识符不同.  函数标识符为: `FUNCTION`. 过程为: `PROCEDURE`
2. 函数中有返回值, 且必须返回, 而过程没有返回值.
3. 过程无返回值类型, 不能将结果直接赋值给变量; 函数有返回值类型, 调用时, 除在 select 中, 必须将返回值给变量.
4. 函数在 select 语句中直接使用, 而过程不能: 函数是使用 select 调用, 过程不是.

### 存储过程操作

#### 创建过程

基本语法: 

```mysql
create procedure 过程名字([参数列表])
begin 
	过程体
end
结束符
```

 如果过程只有一条指令可以省略 `begin` 和 `end`

```mysql
-- 创建过程
create procedure my_pro1()
select * from my_gb;
```

![53483212244](./MySQL\1534832122449.png)

过程基本上也可以完成函数对应的所有功能

```mysql
-- 修改语句结束符
delimiter $$
create procedure my_pro2()
begin
	-- 求1到100之间德和
	declare i int default 1;
	-- declare sum int default 0; 局部变量
	set @sum = 0;
	-- 开始循环取结果
	while i < 100 do
		-- 求和
		set @sum = @sum + i;
		set i = i + 1;
	end while;
	-- 显示结果
	select @sum;
end
$$
delimiter ;
```

![53483216541](./MySQL\1534832165413.png)

#### 查看过程

基本语法: `show procedure status [like 'pattern'];`

```mysql
show procedure status\G
```

![53483249615](./MySQL\1534832496155.png)

查看过程创建语句: `show create procedure 过程名字`

```mysql
show create procedure my_pro2\G
```

![53483268138](./MySQL\1534832681382.png)

#### 调用过程

过程: 没有返回值, select 不可能调用.

调用过程有专门语法: `call 过程名([实参列表]);`

```mysql
call my_pro1();
call my_pro2();
```

![53483314908](./MySQL\1534833149088.png)

#### 删除过程

基本语法: `drop procedure 过程名;`

```mysql
drop procedure my_pro1;
```

![53483320996](./MySQL\1534833209967.png)

![53483322050](./MySQL\1534833220501.png)

### 存储过程的形参类型

存储过程也允许提供参数 (形参和实参), 存储过程的参数与函数一样 需要指定类型.

但是存储过程对参数还有额外的要求: 自己的参数分类

**in**

表示这个参数从外部传入到过程内部使用, 可以直接是数据或者保存数据的变量.

**out**

表示参数是从过程里面把数据保存到变量中, 交给外部使用: 传入的必须是变量.

如果说传入的 out 变量本身在外部有值, 在进入过程之后, 第一件事就是被清空(NULL).

**inout**

数据可以从外部传入到过程内部使用, 同时内部操作之后又会将数据返还给外部.

**参数的基本语法(形参)**

`过程类型 变量名 数据类型;`

```mysql
-- 创建三个外部变量
set @n1 = 1;
set @n2 = 2;
set @n3 = 3;

-- 修改语句结束符
delimiter $$
create procedure my_pro5(in int_1 int, out int_2 int, inout int_3 int)
begin
	-- 查看三个传入的数据的值
	select int_1, int_2, int_3;
	
	-- 修改三个变量的值
	set int_1 = 10;
	set int_2 = 30;
	set int_3 = 30;
	select int_1, int_2, int_3;
	
	-- 查看会话变量
	select @n1, @n2, @n3;
	
	-- 修改会话变量
	set @n1 = 'a';
	set @n2 = 'b';
	set @n3 = 'c';
	
	-- 查看三个会话变量
	select @n1, @n2, @n3;
end
$$
delimiter ;

-- 调用过程
call my_pro5(@n1, @n2, @n3);
```

![53483422479](./MySQL\1534834224790.png)

![53483470770](./MySQL\1534834707703.png)

分析结果

执行过程时: 除了out 类型数据会被清空, 其它正常

![53483488394](./MySQL\1534835174038.png)

过程执行完后, 查看三个临时变量值

```mysq
select @n1, @n2, @n3;
```

![53483528469](./MySQL\1534835284697.png)

分析:

![53483556198](./MySQL\1534835561989.png)



## 触发器

### **触发器概念**

**基本概念**

**触发器是一种特殊类型的存储过程**, 它不同于我们前面介绍过的存储过程.**触发器主要是通过事件进行触发而被执行的**, 而存储过程可以通过存储过程名字而被直接调用.

触发器: trigger, 是一种非常接近于js中的事件的知识. 提前给某张表的所有数据(行) 绑定一定代码. 如果该行操作满足条件(触发), 这段提前准备好的代码就会自动执行.

**作用**

1. 可在写入数据表之前, 强制检验或转换数据(保证数据安全).
2. 触发器发生错误时, 异动的结果会被撤销(如果触发器执行错误, 那么前面用户已经执行成功的操作也会被撤销: 事务安全).
3. 部分数据库管理系统可以针对数据定义语言(DDL)使用触发器, 称为 DDL 触发器.
4. 可依照特定的情况, 替换异动的指令(INSTEAD OF) (mysql 不支持).

**触发器优缺点**

**优点**

1. 触发器可以通过数据库中的相关表实现级联的更改. (如果某张表的数据改变, 可以利用触发器来实现其他表的无痕操作[用户不知道])
2. 保证数据安全: 进行安全校验.

**缺点**

1. 触发器过分的依赖, 势必影响数据库的结构, 同时增加了维护复杂程度.
2. 造成数据在程序层面不可控 (PHP 层).

### 基本操作

#### **创建触发器**

**基本语法**

```mysql
create trigger 触发器名字 触发时机 触发事件 on 表 for each row
begin

end
```

触发器对象: on 表 for each row, 触发器绑定的实质是表中的所有行, 因此当每一行发生改变的时候, 就会触发触发器

**触发时机**

触发时机: 每张表中对应的行都会有不同的状态, 当 SQL 指令发送的时候, 都会令行中数据发送改变, 每一行总会有两种状态: 数据操作前和数据操作后.

before: 在表中数据发生改前的状态

after: 在表中数据已经发生改变后的状态

**触发事件**

触发事件: mysql 中触发器针对的目标是数据发生改变, 对应的操作只有数据的写操作 (增删改).

insert: 插入数据

update: 更新操作

delete: 删除操作

**注意事项**

一张表中, 每一个触发时机绑定的触发事件对应的触发器类型只能有一个: 一张表中只能有一个对应的 after insert 触发器

因此, 一张表中最多的触发器只能有 6 个: `before insert` `before update` `before delete` `after insert` `after update` `after delete`

需求: 有两张表, 一张商品表, 一张订单表(保留商品 ID), 每次订单生成, 商品表中对应的库存就发生变化.

1. 创建两张表: 商品表和订单表

   ```mysql
   create table my_goods(
   id int primary key auto_increment,
   name varchar(20) not null,
   inv int
   )charset utf8;

   create table my_orders(
   id int primary key auto_increment,
   good_id int not null,
   goods_num int not null
   )charset utf8;

   insert into my_goods values(null, '手机', 300), (null, '笔记本', 100), (null, '平板', 50);
   ```

   ![53484493473](./MySQL\1534844934739.png)

2. 创建触发器: 如果 *订单表*  发生 *数据插入*, 对应的商品就应该减少库存

   ```mysql
   -- create trigger 名字 
   delimiter $$
   create trigger after_insert_order_t after insert on my_orders for each row
   begin
   	-- 更新商品库存
   	update my_goods set inv = inv - 1 where id = 1; 
   end
   $$
   delimiter ;
   ```

   ![53484563564](./MySQL\1534845635640.png)

#### 查看触发器

查看触发器信息: `show triggers;`

![53484552459](./MySQL\1534845524597.png)

查看触发器创建信息: `show create trigger 触发器名字;`

#### 触发触发器

想办法让触发器执行: 让触发器指定的表中对应的时机发生对应的操作即可.

1. 表为 my_orders
2. 在插入之后
3. 插入操作

#### 删除触发器

基本语法:  `drop trigger 触发器名称`

![53484569971](./MySQL\1534845699719.png)

### 触发器应用

**记录关键字**: 

- `new`
-  `old`

触发器针对的是数据表中的每条记录 (每行), 每行在数据操作前后都有一个对应的状态, 触发器在执行之前就将对应的状态获取到了, 将没有操作之前的状态 (数据) 都保存到 old 关键字中, 而操作后的状态都放到了 new 中.

在触发器中, 可以通过 old 和 new 来获取绑定表中对应的记录数据.

基本语法: `关键字.字段名`

old 和 new 并不是所有触发器都有

insert: 插入前全为空, 没有 old

delete: 清空数据, 没有 new 

**练习**: my_tab表中的name值修改, 带动 my_tab3 中的 name 修改

```mysql
delimiter $$
create trigger change_name after update on my_tab for each row
begin
	update my_tab3 set name = new.name where id = new.id;
end
$$
delimiter ;
```

![53494729687](./MySQL\1534947296873.png)

**商品自动扣除库存案例**

```mysql
create trigger 触发器名字 触发时机 触发事件 on 表 for each row
begin
end
```

```mysql
-- 自动扣除商品库存的触发器
delimiter $$
create trigger a_i_o_t after insert on my_orders for each row
begin
	-- 更新库存: new 代表着新增的订单
	update my_goods set inv = inv - new.goods_num where id = new.good_id;
end
$$
delimiter ;
```

![53484639000](./MySQL\1534846390003.png)

```mysql
-- 执行在商品库存表中插入一条数据. 验证触发器
insert into my_orders valus(null, good_id, goods_num)
```

![53484654579](./MySQL\1534846545791.png)

```mysql
-- 如果库存数量没有商品订单多怎么办?
-- 操作目标: 订单表, 操作时机: 下单前 操作事件: 判断库存
delimiter $$
create trigger b_i_o_t before insert on my_orders for each row
begin
	-- 去除库存车数据进行判断
	select inv from my_goods where id = new.good_id into @inv;
	-- 判断库存是否足够
	if @inv < new.goods_num then
		-- 中断操作: 暴力解决, 主动出错
		insert into xxx values('xxx');
	end if;
end
$$
delimiter ;
```

![53484883061](./MySQL\1534848830611.png)

**案例: navicat可视化窗口操作**

需求: 新增一个用户之后的触发 用户user_desc(详情表) 添加一条用户记录, userId 指向就 user_info 表新增用户的 id 值

![53685132506](.\MySQL\1536851325069.png)
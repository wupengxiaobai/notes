# 微信小程序

### 基本应用

**微信小程序(应用)**

- 结构 wxml

  - 遵循XML语法
  - 常用标签
    - <view> 类似 <div>
    - <text> 类似 <span>
    - <image> 类似 <img>
      - 图片在开发小程序项目的时候
        - 图片需要设置宽高(有默认宽高)
        - 图片需要设置缩放模式 mode='aspectFill'
    - <navigator> 类似 <a>
  - 常用组件 
    - swiper

- 样式 wxss

  - 尺寸单位	rpx (基于750分辨率自动计算)
  - 样式导入 `import "xxx.wxss"`

- 行为 js 

  - ECMAScript

  - wx对象(微信小程序封装的顶级对象)

    注意: 微信小程序里面没有 DOM 和 BOM 的概念

- 配置 json

  - 非常严格的 json 格式

  - **app.json 全局配置**

    - pages 配置路由

    - window 配置头部
    - tabBar 底部选项卡

**组件组成基本**

![1543578741889](.\wx\1543578741889.png)

#### wxml 高级

**数据绑定  `{{}}`**

```html
<!-- wxml -->
<view>{{message}}</view>
```

```js
//	page.js
Page({
    data: {
        message: "Hello wx!"
    }
})
```

**特别注意: **

1. 花括号和引号之间不能有空格
2. 不要直接写 checked="false", 其计算结果是一个字符串, 转成 boolean 类型后代表真值, 需要使用插值表达式来进行判断

```xml
<checkbox checked="{{false}}"></checkbox>
```

**列表渲染 wx:for='{{}}'**

```xml
<!-- wxml --> 
<view wx:for="{{array}}" wx:key="{{item.id}}">{{item}}</view>
```

```js
//	page.js
Page({
    data: {
        array: [1, 2, 3, 4, 520]
    }
})
```

**注意: 如果是多层嵌套情况, 使用  wx:for-item='xxx' 指定被遍历的每个item**

**流程判断 wx:if='{{}}'**

```xml
<!-- wxml --> 
<view wx:if="{{array}}">if</view>
<view wx:else="{{array}}">else</view>
```

**流程判断2 hidden="{{}}"**

**xml 中书写 js 代码**

```xml
<!-- wxml -->
<wxs module='foo'>
    //	这里可导出一个对象, 这个对象可以直接在界面上使用
    module.exports = {
            sum: function(a, b){
            return a + b;
        }
    }
</wxs>
<view>{{foo.sum(1,2)}}</view>
```

#### wxss 常用

```css
/* 箭头 */
.jiantou::after {
  content: '';
  position: absolute;
  top: 50%;
  right: 50rpx;
  width: 14.5rpx;
  height: 14.5rpx;
  transform: rotate(45deg) translateY(-50%);
  border: 1px solid #333;
  border-left-width: 0;
  border-bottom-width: 0;
}

/*单行省略*/
.text-over {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}


/* 透明下边框 */
.no-bt {
  border-color: transparent !important;
}
```



#### 行为 js 文件

```js
/*
	此处可以是用来模块的引入和函数的封装
*/

Page({
    /**
   * 页面的初始数据
   */
    data: {},
    /**
   * 生命周期函数--监听页面加载
   */
    onLoad: function (options) {
        //	options.scene 可以识别用户通过什么方式进入我们的小程序
        //	我们需要请求过的数据, 在该生命周期进行请求相对合适
        //	使用 wx.require() 请求数据
        wx.request({
            url: 'https://locally.uieee.com/slides',
            data: '',
            header: {},
            method: 'GET',
            dataType: 'json',
            success: function(res) {},
            fail: function(res) {},
            complete: function(res) {},
        });
    },
    /**
   * 生命周期函数--监听页面初次渲染完成
   */
    onReady: function () {},
    /**
   * 生命周期函数--监听页面显示
   */
    onShow: function () {},
    /**
   * 生命周期函数--监听页面隐藏
   */
    onHide: function () {},
    /**
   * 生命周期函数--监听页面卸载
   */
    onUnload: function () {},
    /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
    onPullDownRefresh: function () {},
    /**
   * 页面上拉触底事件的处理函数
   */
    onReachBottom: function () {},
    /**
   * 用户点击右上角分享
   */
    onShareAppMessage: function () {}
})
```

##### **事件绑定和冒泡**

1. 冒泡事件 bind 事件类型 如 `bindtap` `bindlongpress`
2. 非冒泡事件 catch 事件类型 如 `catchtap` `catchlongpress`

**常用事件类型**

| 类型      | 触发条件                     |
| --------- | ---------------------------- |
| tap       | 手指触摸后马上离开           |
| longpress | 手指触摸后, 超过 350ms再离开 |



### 常用组件

#### 视图容器

##### View

|                        | 类型    | 默认值 | 说明                                                         |
| ---------------------- | ------- | ------ | ------------------------------------------------------------ |
| hover-class            | String  | none   | 指定按下(view)去的样式类, 当hover-class="none"时,没有点击效果 |
| hover-stop-propagation | Boolean | flase  | 指定是否组织本节点的祖先节点出现点击状态                     |
| hover-start-time       | Number  | 50     | 按住后多久出现点击状态, 单位毫秒                             |
| hover-stay-time        | Number  | 400    | 手指松开后点击状态保留时间, 单位毫秒                         |

##### scroll-view

| 属性              | 类型          | 默认值 | 说明                                                         |
| ----------------- | ------------- | ------ | ------------------------------------------------------------ |
| scroll-x/scroll-y | Boolean       | false  | 允许 横向/纵向 滚动                                          |
| upper-threshold   | Number/String | 50     | 设置距离顶部/左边多远时 触发 scrolltoupper 事件              |
| lower-threshold   | Number/String | 50     | 设置距离底部/右边多远时 触发 scrolltolower 事件              |
| bindscrolltoupper | EventHandle   |        | 滚动到顶部/左边, 会触发 scrolltoupper事件                    |
| bindscrolltolower | EventHandle   |        | 滚动到底部/右边, 会触发 scrolltlower                         |
| bindscroll        | EventHandle   |        | 滚动触发, event.detail={scrollLeft,scrollTop,scrollHeight,scrollWdith,deltaX,deltaY} |

![1544002774295](.\wx\1544002774295.png)

#### 基础内容

##### icon图标

| 属性名 | 类型          | 默认值 | 说明                                                         |
| ------ | ------------- | ------ | ------------------------------------------------------------ |
| type   | String        |        | icon的类型, 有效值: success, success_no_circle, info, warn, waiting, cancel, download, search, clear |
| size   | Number/String | 23px   | icon大小                                                     |
| color  | Color         |        | icon的颜色, 同css的color                                     |

##### text 组件

| 属性名     | 类型    | 默认值 | 说明                                                         |
| ---------- | ------- | ------ | ------------------------------------------------------------ |
| selectable | Boolean | false  | 文本是否可选                                                 |
| space      | String  | false  | 显示连续空格 有效值: ensp(中文字符空格一般大小),nbsp(根据字体设置的空格带小), emsp(中文字符空格大小) |
| decode     | Boolean | false  | 是否解码                                                     |

##### progress 进度条

| 属性            | 类型        | 默认值    | 说明                                                  |
| --------------- | ----------- | --------- | ----------------------------------------------------- |
| percent         | Float       |           | 百分比0~100                                           |
| show-info       | Boolean     | false     | 进度条右侧显示百分比                                  |
| border-radius   | Number      | 0         | 圆角大小                                              |
| font-size       | Number      | 16        | 右侧百分比字体大小                                    |
| stroke-width    | Number      | 6         | 进度条线的宽度                                        |
| color           | Color       | #09bb7    | 进度条颜色(请使用 activeColor)                        |
| activeColor     | Color       |           | 已选择的进度条的颜色                                  |
| backgroundColor | Color       |           | 未选择的进度条颜色                                    |
| active          | Boolean     | false     | 进度条从左往右的动画                                  |
| active-mode     | String      | backwards | backwards:动画从头播; forwards:动画从上次结束点接着播 |
| bindactiveend   | EventHandle |           | 动画完成事件                                          |

**注意: 在 mpVue 中使用进度条外包一个div**, 控制大小

#### 表单组件

```xml
<!--常用表单-->
<input type='text'>常用表单</input>

<!--复选框/组-->
<checkbox>复选框</checkbox>
<checkbox-group bindchange="checkboxHandler" data-参数名='参数值'>
    <!--给checkbox组添加修改事件, 并使用 data-参数名='参数值' 进行参数传递 -->
    <checkbox checked>撸码</checkbox>
    <checkbox>做菜</checkbox>
</checkbox-group>

<!--单选框/组-->
<radio>单选框</radio>
<radio-group>
    <radio checked value='male'>男</radio>
    <radio value='female'>女</radio>
    <radio disabled>保密</radio>
</radio-group>

<switch checked></switch>
```

**input的一些属性**

| 属性                                 | 类型        | 默认值 | 说明                                                         |
| ------------------------------------ | ----------- | ------ | ------------------------------------------------------------ |
| type                                 | String      | text   | 有效值: text/number/idcart/digit                             |
| password                             | Boolean     | false  | 是否为密码类型                                               |
| placeholder/placeholder-style(class) | String      |        | 输入款为空时占位符/占位符样式(样式类)                        |
| focus                                | Boolean     | false  | 自动焦点                                                     |
| auto-focus                           | Boolean     | false  | (讲讲废弃, 直接使用 focus) 自动聚焦, 拉起键盘                |
| bindinput                            | EventHandle |        | 键盘输入时触发 event.detail = {value, cursor, keyCode}，keyCode 为键值 |
| bindFocus                            | EventHandle |        | 输入框聚焦时触发                                             |
| bindblur                             | EventHandle |        | 输入款失去焦点时触发                                         |
| bindconfirm                          | EventHandle |        | 点击完成按钮时触发                                           |

```js
//	事件接收参数
checkboxHandler(e){
	console.log(e.detail);	//	获取表单值
    console.log(e.target.dataset['参数名']);	//	获取传递参数值
}
```

**mpVue中复选等**

![1544110339097](.\wx\1544110339097.png)

##### picker

支持五种选择器，通过mode来区分，分别是普通选择器，多列选择器，时间选择器，日期选择器，省市区选择器，默认是普通选择器。

**普通选择器: mode = selector**

| 属性名     | 类型               | 默认值 | 说明                                                         |
| ---------- | ------------------ | ------ | ------------------------------------------------------------ |
| range      | Array/Object Array | []     | mode 为 selector 或 multiSelector时, range 有效              |
| range-key  | String             |        | 当 range 是一个 Object Array 时, 通过 range-key 来选择器默认显示内容 |
| value      | Number             | 0      | 默认选择 range 中的第几个(下标0开始)                         |
| disabled   | Boolean            | false  | 是否禁用                                                     |
| bindchange | EventHandle        |        | value 改变时触发 change 事件, 通过 event.mp.detail.value/event.target/value 获取选择项对应索引 |
| bindcancel | EventHandle        |        | 取消选择或点遮罩层收齐 picker 时触发                         |

**多列选择器 mode = multiSelector**

| 属性名           | 类型                  | 默认值 | 说明                                                         |
| ---------------- | --------------------- | ------ | ------------------------------------------------------------ |
| range            | 二维数组/二维对象数组 | []     | 数组的每项表示每列的数据如[['a','b'],['c','d']]              |
| range-key        | String                |        | 当 range 是二维 Object Array时, 通过 range-key 来指定 Object 中 key 的值作为选择器显示内容 |
| value            | Array                 | []     | 每一项表示选择了 range 对应项中的第几个                      |
| bindchange       | EventHandle           |        | value 改变触发 cahnge 事件                                   |
| bindcolumnchange | EventHandle           |        | 某一列的值改变时触发 columnchange 事件                       |
| bindcancel       | EventHandle           |        | 取消选择时触发                                               |

**时间选择器: model = time**

**日期选择器: mode = date**

**省市区选择器: model=region**

注意: 在修改显示内容的时候要修改整个数组(使用setData)才能达到界面数据同时更新的效果

##### button

[参考](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)

| 属性      | 类型    | 默认值  | 说明                                                   |
| --------- | ------- | ------- | ------------------------------------------------------ |
| type      | String  | default | default/primary/warn 只有defalut时才可以设置背景的颜色 |
| plain     | Boolean | false   | 按钮是否镂空, 背景色透明                               |
| loading   | Boolean | false   | 文字前是否带 loading 图标                              |
| open-type | String  |         | 微信开放能力(转发)                                     |
| disabled  | Boolean | false   | 是否禁止选中                                           |



#### swiper组件

```html
<swiper indicator-dots="{{indicatorDots}}"
  autoplay="{{autoplay}}" interval="{{interval}}" duration="{{duration}}">
  <block wx:for="{{imgUrls}}">
    <swiper-item>
      <image src="{{item}}" class="slide-image" width="355" height="150"/>
    </swiper-item>
  </block>
</swiper>
<button bindtap="changeIndicatorDots"> indicator-dots </button>
<button bindtap="changeAutoplay"> autoplay </button>
<slider bindchange="intervalChange" show-value min="500" max="2000"/> interval
<slider bindchange="durationChange" show-value min="1000" max="10000"/> duration
```



#### tabBar组件

属性说明: 

| 属性            | 类型     | 是否必填 | 默认值 | 描述                            |
| --------------- | -------- | -------- | ------ | ------------------------------- |
| color           | HexColor | 是       |        | tab 上的文字默认颜色            |
| selectedColor   | HexColor | 是       |        | tab上的文字选中时颜色           |
| backgroundColor | HexColor | 是       |        | tab 的背景色                    |
| borderStyle     | String   | 否       | black  | tabber上边款的颜色(black/white) |
| list            | Array    | 是       |        | tab的列表, 至少2个, 最多5个     |
| position        | String   | 否       | bootom | 可选值 bottom, top(无图标)      |

其中 list 接受一个数组, 数组中的每个项都是一个对象, 属性值如下

| 属性             | 类型   | 是否必填 | 说明                                                         |
| ---------------- | ------ | -------- | ------------------------------------------------------------ |
| pagePath         | String | 是       | 页面路径, 必须在pages中先定义                                |
| text             | String | 是       | tab上按钮文字                                                |
| iconPath         | String | 否       | 图片路径, icon 大小限制为40kb, 建议尺寸81px*81px(position 为 top时,该参数无效) |
| selectedIconPath | String | 否       | 选中时图片路径, 其它说明如上iconPath相同                     |



### 常用 API

#### 本地存储

- **设置本地存储** 

  - 同步设置 **`wx.setStorageSync(string key, Object data)`**

  - 异步设置 **`wx.setStorage(Object object)`**

    ```js
        wx.setStorage({
            key:"key",
            data:"value"
        })
    
        try {
            wx.setStorageSync('key', 'value')
        } catch (e) {}
    ```

- **获取本地存储** 

  - 异步获取 **`wx.getStorage(Object object)`** 

  - 同步获取 **`wx.getStorageSync(String)`**

    ```js
    wx.getStorage({
        key: 'key',
        success (res) {
            console.log(res.data)
        }
    })
    ```

#### 用户授权

**获取用户信息**

- **wx.getUserInfo()** 获取用户信息(调用前需要用户授权)

- 用户授权使用 button 组件 `<button open-type="getUserInfo" bindgetuserinfo="onGotUserInfo">获取用户信息</button>`

  mpVue 中授权演示如下: 

  ```html
  <button open-type="getUserInfo" @getuserinfo="handleGetUserInfo">授权登录</button>
  ```

  ```js
  handleGetUserInfo() {
      let _this = this;
      wx.getUserInfo({
          success(data) {	//	授权成功
              if (data.rawData) {
                  _this.isShow = true;
                  _this.userInfo = data.userInfo;
              }
          },
          fail(data) {	//	授权失败
              wx.showToast(
                  {
                      title: "授权失败",
                      icon: "none"
                  },
                  1500
              );
              _this.isShow = false;
          }
      });
  }
  ```

#### 加载动画

**头部加载动画**

- **wx.showNavigationBarLoading(Object object)** 开始

- **wx.hideNavigationBarLoading(Object object)** 关闭

**提示框加载动画**

- **wx.showLoading(Object object)**	开启
- **wx.hideLoading(Object object)**     关闭

**提示框**

- **wx.showToast(Object object)** 
- **wx.hideToast(Object object)**

#### **下拉事件监听**

- **wx.startPullDownRefresh(Object object)** 开启(或者 window 配置 enablePullDownRefresh 为true即可)
- **wx.stopPullDownRefresh(Object object)** 关闭

#### 媒体相关

#### 背景音乐

- 音乐播放 **`wx.playBackgroundAudio(Object object)`**
- 音乐暂停 **`wx.pauseBackgroundAudio(Object object)`**

**音乐播放/暂停监听**

- 监听音乐播放 **`wx.onBackgroundAudioPlay(function callback)`**
- 监听音乐暂停 **`wx.onBackgroundAudioPause(function callback)`**
- 监听音乐停止 **`wx.onBackgroundAudioStop(function callback)`**

#### 显示操作菜单

- **wx.showActionSheet(Object object)**

| 属性      | 类型     | 默认值 | 描述                            |
| --------- | -------- | ------ | ------------------------------- |
| itemList  | Array    |        | 按钮的文字数组, 数组长度最大为6 |
| success   | function |        | 接口调用成功的回调函数          |
| fail      | function |        | 接口调用失败的回调函数          |
| itemColor | string   |        | 按钮文字颜色                    |

**object.success** 参数

| 属性     | 类型   | 说明                                  |
| -------- | ------ | ------------------------------------- |
| tapIndex | number | 用户点击的按钮序号, 从上到下, 从0开始 |

```js
wx.showActionSheet({
    itemList: ['A', 'B', 'C'],
    success (res) {
        console.log(res.tapIndex)
    },
    fail (res) {
        console.log(res.errMsg)
    }
})
```

#### 上传/下载

**下载** 

`wx.downloadFile(Object object)`

| 属性     | 类型     | 说明                                        |
| -------- | -------- | ------------------------------------------- |
| url      | string   | 下载资源的url(必填)                         |
| header   | Object   | HTTP请求的 Header, Header中不能设置 Referer |
| filePath | string   | 指定文件下载后存储的路径                    |
| success  | function | 成功回调                                    |
| fail     | function | 失败回调                                    |

**object.success 回调函数参数**

| tempFilePath | 临时文件路径, 如果没有传入filePatch 指定临时文件, 则下载后的文件会存储到一个临时文件 |
| ------------ | ------------------------------------------------------------ |
| statusCode   | 开发者服务区返回的 HTTP 状态码                               |

**返回值**

`DownloadTask`	 一个可以监听下载进度变化的事件

**上传相关**

**chooseImage** 接口获取到一个本地资源的临时文件路径后, 可以通过此接口将本地资源上传到指定服务器.

| count      | number   | 9                          | 最多可以选择的图片张数             |
| ---------- | -------- | -------------------------- | ---------------------------------- |
| sizeType   | Array    | ['original', 'compressed'] | 所选图片尺寸(原图/压缩图)          |
| sourceType | Array    | ['album', 'camera']        | 所选图片来源(从相册选图, 使用相机) |
| success    | function |                            | 成功回调                           |

success 回调参数

| tempFilePaths | Array | 图片的本地临时文件路径列表 |
| ------------- | ----- | -------------------------- |
| tempFiles     | Array | 图片的本地临时文件列表     |



**uploadFile(Object)** 文件上传 将本地资源上传到开发者服务器,. 客户端发起一个 HTTPS POST请求, 其中 content-type为 multipart/form-data

| url      | String   | 必须 | 开发者服务器url                                              |
| -------- | -------- | ---- | ------------------------------------------------------------ |
| filePath | String   | 必须 | 要上传你文件资源的路径                                       |
| name     | String   | 必须 | 文件对应的 key, 开发者在服务器端通过key可以获取到文件的二进制内容 |
| header   | Object   |      | HTTP 请求 Header, header 中不能设置 Refere                   |
| success  | Function |      | 接口调用成功的回调函数                                       |

```js
wx.chooseImage({
    count: 9,
    sizeType: ["original", "compressed"], //  尺寸
    sourceType: ["album", "camera"], //  来源
    success: res => {
        let [tempFilePaths, tempFiles] = [res.tempFilePaths, res.tempFiles];
        this.uploadImageArr = this.uploadImageArr.concat(tempFilePaths);	
        //  tempFilePaths 就是本地存储图片的临时路径, 此处做保存, 用于方便遍历显示到界面上

        //  执行上传值服务端
        /* const uploadTask = wx.uploadFile({
            url: "http://example.weixin.qq.com/upload", // 仅为示例，非真实的接口地址
            filePath: tempFilePaths[0],
            name: "file",
            formData: {
              user: "test"
            },
            success(res) {
              const data = res.data;	//	服务器返回的数据
              const statusCode = res.statusCode	//	服务器返回http状态码
              // do something
            }
          });
          uploadTask.onProgressUpdate(res => {
            console.log("上传进度", res.progress);
            console.log("已经上传的数据长度", res.totalBytesSent);
            console.log(
              "预期需要上传的数据总长度",
              res.totalBytesExpectedToSend
            );
          }); */
    },
    fail() {}
});
```

### 常用封装

#### js的封装

**请求的封装**

```js
//  请求封装
module.exports = function(url, method, data) {
  return new Promise((resolve, reject) => {
    wx.request({
      url: url,
      data: data,
      method: method,
      header: {
        "Content-Type": 'json'
      },
      dataType: 'json',
      success: resolve,
      fail: reject
    })
  })
}
```

#### css 封装

```css

```



# 小程序API*

## 基础

### wx.canIUse(string schema)

判断小程序的API, 回调,参数,组件等是否在当前版本可用

- `${API}.${method}.${param}.${options}` 或者 `${component}.${attribute}.${option}` 

  参数说明:  

  - ${API} 代表 API 名字

  - ${method} 代表调用方式, 有效值为 return, success, object, callback

  - $(param) 代表参数或者返回值
  - ${options} 代表参数的可选值

  - ${component} 代表组件名字

  - ${attribute} 代表组件熟悉

  - ${option} 代表组件熟悉的可选值

  示例  `wx.canIUse('showToast.object.image')`

###系统

##### wx.getSystemInfoSync

##### wx.getSystemInfo

获取客户端系统信息, 返回值如下

| brand/model              | string | 手机品牌/型号     |
| ------------------------ | ------ | ----------------- |
| pixelRatio               | number | 设备像素比        |
| screenWidth/screenHeight | number | 屏幕宽度/高度     |
| windowWidth/windowHeight | number | 可使用窗口宽/高度 |
| language                 | string | 微信设置的语言    |
| version                  | string | 微信版本号        |
| system                   | string | 操作系统版本      |
| platform                 | string | 客户端平台        |

### 更新

##### wx.getUpdateManager()

获取**全局唯一**的版本更新管理器，用于管理小程序更新

##### UpdateManager

用来管理更新, 可以通过 wx.getUpdateManager 接口获取实例

方法如下: 

 -	UpdateManager.applyUpdate() 强制小程序重启并使用新版本.  下载完成(onUpdateReady 回调) 调用
	-	UpdateManager.onCheckForUpdate(callback) 监听像微信后台请求检查更新结果事件. 小程序启动时自动检查更新, 无需主动调用
			UpdateManager.onUpdateReady(callback) 小程序下载成功后回调
		UpdateManager.onUpdateFailed(callback) 小程序更新失败回调

```js
//  更新唯一凭证
let updateManager = wx.getUpdateManager()
// 查看是否有新版本
updateManager.onCheckForUpdate((res) => {
    console.log(res.hasUpdate)
})
//  有新版本则自动触发
updateManager.onUpdateReady(() => {
    wx.showModel({
        title: '更新提示',
        content: '新版本已准备哈, 是否重启',
        success(res) {
            if (res.confirm) {
                //  强制小程序重启使用新版
                updateManager.applyUpdate()
            }
        }
    })
})
//  更新失败回调
updateManager.onUpdateFailed(function() {
    console.log('更新失败')
})
```

### 小程序

#### 生命周期 

###### wx.getLaunchOptionsSync

获取小程序启动时的参数, 返回值 Object(启动参数)

| path         | string | 启动小程序的路径                                             |
| ------------ | ------ | ------------------------------------------------------------ |
| scene        | number | 启动小程序的场景值(1020 公众号profile页相关小程序列表, 1035公招自定义菜单, 1036 App分享卡片, 1037小程序打开小程序, 1038 从另一个小程序返回, 1043 公众号模板消息) |
| query        | Object | 启动小程序的 query 参数                                      |
| shareTicket  | string |                                                              |
| referrerInfo | Object | 来源信息. 从另一个小程序, 公众号或 App进入小程序时返回. 否则为 {} (appId 来源的 appId; extraData 来源的小程序传来的数据, scene=1037/1038时支持) |

#### 应用级别事件

###### wx.offPageNotFound(callback)

取消监听小程序要打开的页面不存在事件

callback 打开的页面不存在事件的回调函数

###### wx.onPageNotFound(callback)

监听小程序要打开页面不存在事件

callback 小程序打开的页面不存在事件的回调函数

**注意: 我们可以在回调中使用页面重定向, 但是必须在回调中同步处理**

###### wx.offError(callback)

取消监听小程序错误事件, callback 错误事件的回调

###### wx.onError(callback)

监听小程序错误事件. 如脚本错误或 API 调用报错等. 改时间与 App.onError 的回调时机与参数一致

callback 回调函数, 参数 error 错误信息, 包含堆栈

###### wx.offAppShow(callback)

取消件套小程序切前台事件

###### wx.onAppShow(callback)

监听小程序切前台事件. 改时间与 App.onShow 回调参数一致

参数 res 结构

| path         | string | 小程序切前台的路径                                           |
| ------------ | ------ | ------------------------------------------------------------ |
| scene        | number | 小程序切前台的场景值                                         |
| query        | Object | 小程序切前台的query参数                                      |
| shareTicket  | string | 更多转发信息                                                 |
| referrerInfo | Object | 来源信息(appId 来源 的appId; extraData 来源传递来的数据. scene=1037/1038时支持) |

部分版本在无 referrerInfo 的时候会返回 undefined, 使用 `options.referrerInfo && options.referrerInfo.appId` 进行判断

###### wx.offAppHide(callback)

取消监听小程序切后台事件, 回调

###### wx.onAppHide(callback)

监听小程序切后台事件, 与 App.onHide 回调时机一致.

### 定时器

##### setTimeout(callback, number delay, any rest)

设定一个定时器, 在定时到期以后执行注册的回调函数

参数

​	callback  回调函数

​	number delay 延迟时间, 单位ms

​	any rest 附加参数, 作为参数传递给回调函数

返回值 number 定时器的编号, 该值传递给 clearTimeout 来取消定时器

##### clearTimeout(timeoutID)

取消由 setTimeout 设置的定时器

##### setInterval()

设定一个定时器, 按照指定的周期来执行注册回调

##### clearInterval()

取消由 setInterval 注册的定时器

### 调试

##### wx.setEnableDebug(Object object)

设置是否打开调试开. 

- enableDeBug 是否打开调试
- success 成功回调函数
- ...

##### wx.getLogManager(number level)

获取日志管理器对象.

- number level 取值 0/1, 取值为0表示会把 APP, Page 的生命周期函数和 wx命名空间下的函数调用写入入职, 取1则不会, 默认 0.

###### 返回值

LogManager 日志管理器实例

​	方法

 - LogManager.debug() 写 debug 日志
 - LogManager.info() 写 info 日志
 - LogManager.log() 写 log 日志
 - LogManager.warn() 写 warn 日志

使用说明 最多保存 5M 的日志内容, 超过旧内容会被删除.

用户可以通过使用 \<Button\> 组件的 open-type='feedback' 来上传打印的日志. 开发者可以通过小程序管理后台左侧菜单 "客服反馈" 页面查看

基础库默认把 App, Page 的生命周期函数和 wx 命名空间下的函数调用写入日志

#### 云开发控制台 console

云开发提供了一个控制台用于可视化管理云资源, 控制台包含以下几大模块

- 概览: 查看云资源的总体使用情况
- 用户管理: 查看小程序的用户访问记录
- 数据库: 管理数据库集合, 记录, 权限设置, 索引设置
- 存储管理: 管理云文件, 权限设置
- 云函数: 管理云函数, 查看调用日志. 监控记录
- 统计分析: 查看云资源详情使用统计

在用户管理中会显示使用云能力的小程序的访问用户列表, 默认以访问时间倒序排列, 访问时间的触发点是在小程序端调用 wx.cloud.init 方法, 其中 traceUser 参数值为 true  

```js
wx.cloud.init({
    traceUser: true
})
```



## 路由

#### wx.navigateBack(Object object)

- delta 回退多少步数, 超过步数则回到index
- success 成功回调

#### wx.navigateTo(Object object)

- url 跳转地址
- success 成功回调
- ...

#### wx.reLaunch(Object object)

关闭所有页面并指定跳转某页面

- url 指定跳转页面地址
- success 成功回调

#### wx.redirect(Object object)

关闭当前页面,并指定跳转某一页面

- url 跳转页面地址
- success 成功回调

#### wx.switchToTab(Object object)

指定跳转某一 tabBar 项

- url 指定跳转 tabBar 地址



## 界面

### 交互

##### wx.showLoading(Object object)

- title 加载提示
- mask 是否涵盖隐藏层, 默认false
- success 成功回调

##### wx.hideLoading() 加载

关闭加载loading

##### wx.showToast(Object object) 轻提示

- title 提示内容
- icon 提示体表
- mask 是否涵隐藏层

##### wx.hideToast() 隐藏轻提示

- success 成功回调
- ...

##### wx.showModel(Object object) 模态框

- title 标题
- content 内容
- cancelText 取消文本
- cancelColor 取消文本字体颜色
- confirmText 确认文本
- confirmColor 确认文本字体颜色
- success() 成功回调
  - 参数 res 根据res, 是可以确定点击了取消还是点击了确认

##### wx.showActionSheet(Object object)

显示操作菜单

- itemList 操作列表项
- success 成功回调 参数 res.tapIndex 选择菜单项索引

### 导航栏

##### wx.hideNavigationBarLoading(Object object)

当前页面隐藏导航条加载动画

- success 成功回调
- ...

##### wx.setNavigationBarColor(Object object)

设置页面顶部导航颜色

- fontColor 前景颜色值(按钮, 标题, 状态栏颜色, 支持 #ffffff, #000000)
- backgroundColor 背景颜色值, 有效值为十六进制颜色
- animation 动画效果
  - duration 动画变化时间, 默认0
  - timingFunc 动画变化方式, 默认 linear
    - linear easeIn easeOut easeInOut
- success 成功回调

##### wx.setNavigationBarTitle(Object object)

设置当前页面顶部导航标题

- title 标题文本
- success 成功回调
- ....

##### wx.showNavigationBarLoading()

在当前页面显示导航条加载动画

- success 成功回调

### 背景

##### wx.setBackgroundColor(Object object)

动态设置窗口的背景色

- backgroundColor 窗口的背景色, 必须是十六进制
- success 成功回调

##### wx.setBackgroundTextStyle(Object object)

动态设置下拉背景字体, loading 图的演示

- textStyle 必填 下拉背景字体, loading 样式
  - dark	
  - light

### Tab Bar

##### wx.hideTabBar(Object object)

隐藏 tabBar

- animation 是否需要动画效果, 默认false
- success 成功回调
- ...

##### wx.showTabBar(Object object)

显示 tabBar

- animation 是否需要动画效果, 默认false
- success 成功回调
- ...

##### wx.setTabBarStyle(Object object)

动态设置 tabBar 的整体样式

- color	tab文字默认颜色HexColor
- selectedColor      tab被选中时文字颜色HexColor
- backgroundColor     tab的背景色HexColor
- borderStyle   tabBar上边框的颜色, 支持 black/white
- success  成功回调
- ...

##### wx.setTabBarItem(Object object)

动态设置 tabBar 某一项的内容

- index tabBar 项目索引
- text    tab 上的按钮文字
- iconPtah  图片路径, 大小限制 40kb, 建议尺寸 81px*81px, 不支持网络图片
- selectedIconPath 选中时图片路径
- success  接口调用成功的回调函数
- ..

##### wx.showTabBarRedDot(Object object)

显示 tabBar 某一项的右上角的红点

- index 索引
- success 成功回调
- ....

##### wx.hideTabBarRedDot(Object object)

隐藏 tabBar 某一项右上角红点

- index 索引
- success 成功回调
- ....

##### wx.setTabBarBarBadge(Object object)

给 tabBar 某一项右上角添加文本

- index	索引	
- text        文本内容

##### wx.removeTabBarBadge(Object object)

移除 tabBar 某一项右上角的文本

- index 索引
- success 成功回调
- ...

### 下拉刷新

##### wx.startPullDownRefresh(Object object)

开始下拉刷新. 调用后出发下拉刷新动画, 效果与用户手动刷新一致

- success 成功回调

##### wx.stopPullDownRefresh()

停止当前页面下拉刷新

- success 成功回调

### 滚动

##### wx.pageScrollTo(Object object)

将页面滚动到目标位置

- scrollTop 滚动到页面的目标位置, 单位 px
- duration 滚动动画的时长, 单位 ms
- success 成功回调
- ...

### 动画

##### wx.createAnimation(Object object)

创建一个动画实例 animation. 调用实例的方法来描述动画, 最后通过动画实例的 export 方法导出动画数据传递给组件的 animation 属性

- duration 动画持续时间
- timingFunction 动画的效果, 默认 linear
- delay 延迟时间
- transformOrigin '50% 50% 0' 动画开始基点

###### 返回值  Animation

动画对象

- Animation.export() 导出动画队列

  export 方法每次调用后会清掉之前的动画操作

-  Animation.step() 表示一组动画完成.

  可以在一组动画中调用任意多个动画方法, 一组动画的所有动画会同时开始, 一组动画完成后才会进行下一组动画的开始.

#### 自定义组件

##### wx.nextTick(callback)

延迟一部分操作到下一个时间片再执行

#### 菜单

##### wx.getMenuButtonBoundingClientRect()

获取菜单按钮布置信息

#### 置顶

##### wx.setTopBarText(Object object)

动态设置置顶栏文字内容. 只有当前小程序被置顶时能生效.

- text 文本内容
- success 成功回调

### 窗口

##### wx.offWindowResize(callback)

取消监听窗口尺寸变化事件

- callback 尺寸变化事件回调

##### wx.onWindowResize(callback)

监听窗口尺寸变化

- callback 
  - 参数 res.size 
    -  windowWidth
    -  windowHeight

## 网络

### 发起请求

##### wx.request(Object object)

- url 开发者服务器地址
- data 请求参数
- header 设置请求头 默认 application/json
- method 请求方法 默认 get
  - OPTIONS HTTP 请求 OPTIONS
  - GET  HTTP请求GET
  - HEAD  HTTP请求 HEAD
  - POST HTTP 请求 POST
  - ... 
- dataType 返回数据格式
  - json 返回的数据为 JSON , 返回后会对数据进行一次 JOSN.parse
  - 其它  不对返回的内容进行 JSON.parse
- responseType 响应数据类型
  - text	响应的数据为文本
  - arraybuffer 响应的数据为 ArrayBuffer
- success 成功回调
  - data  开发者服务返回的数据
  - statusCode 开发者服务器返回的 HTTP 状态码
  - header 开发者服务器返回的 HTTP Response Header
- ...

data 参数说明

最终发送给服务器的数据是 String类型, 如果传入的data不是String, 会被转换, 规则如下:

- GET 方法的数据, 转成 query (q=xx&m=xxx&..)
- POST 方法且header['content-type']为 application/json 的数据, 会对数据进行 JSON 序列化
- POST 方法且 header['content-type'] 为 application/x-www-form-urlencoded 的数据, 会将数据转换成 query(encodeURIComponent(k)=encodeURIComponent(v)&encodeURIComponent(k)=encodeURIComponent(v)..)

示例代码

```js
let RequestTask = wx.request({
    url: 'test.php', // 仅为示例，并非真实的接口地址
    data: {
        x: '',
        y: ''
    },
    header: {
        'content-type': 'application/json' // 默认值
    },
    success(res) {
        console.log(res.data)
    }
})
```

返回值 RequestTask

- RequestTask.abort() 

  中断请求任务

- onHeadersReceived(callback)

  监听 HTTP Response Header 事件, 比请求完成事件更早

- offHeadersReceived(callback) 取消监听

### 下载

##### wx.downloadFile(Object object)

下载文件资源到本地. 客户端直接发起一个 HTTPS GET请求, 返回文件的本地临时路径

注意: 请在服务端响应的 header 中指定合理的 Content-Type 字段, 以保证客户端正确处理文件类型

- url 下载资源的URL路径
- header HTTP请求的 Header, Header中不能设置 Referer
- filePath 指定文件下载后存储的路径
- success 成功回调
  - tempFilePath  临时文件路径, 如果没有传入 filePath 指定文件存储路径, 则下载后的文件会存储到一个临时文件
  - statusCode 开发者服务器返回的 HTTP 状态码
- ....

###### 返回值 DownloadTask

一个可以监听下载进度变化事件和取消下载的对象

- DownloadTask.abort() 中断下载任务
- DownloadTask.onProgressUpdate(callback) 监听下载进度变化事件

		callback 返回值 res

		- progress 下载进度百分比
		
		- totalBytesWritten 已经下载的数据长度, 单位 bytes
		
		- totalBytesExpectedToWrite 预期需要下载的数据总长度, 单位 Bytes

```js
let DownloadTask = wx.downloadFile({
    url: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1545303501290&di=fdd08c353d8c0c4c44afca807aa9a1d7&imgtype=0&src=http%3A%2F%2Fpic.58pic.com%2F00%2F95%2F76%2F78bOOOPIC49.jpg',
    success: (res) => {
        if (res.statusCode == 200) {
            console.log(res.tempFilePath)
            this.setData({
                'imgUrl': res.tempFilePath
            })
        }
    }
})
RequestTask.onProgressUpdate(function(res) {
    console.log(res)
})
```

- onHeadersReceived(callback)

监听 HTTP Response Header 事件. 比请求完成事件更早

参数 res.http 属性是开发者服务区返回的 HTTP Response Header

### 上传

##### wx.uploadFile(Object object)

将本地资源上传到服务器. 客户端发起一个 HTTPS POST 请求, 其中 content-type 为 multipart/form-data

- url	开发者服务区地址
- filePath 要上传文件资源路径
- name 文件对应的key, 开发者在的服务端可以通过 key 获取文件的二进制内容
- header HTTP 请求 Header
- formData HTTP 请求中其他额外的 form data
- success 成功回调
  - res.data 开发者服务区返回的数据
  - res.statusCode 开发者服务区返回的 HTTP 状态码
- ...

示例代码

```js
wx.chooseImage({
    success(res) {
        const tempFilePaths = res.tempFilePaths
        wx.uploadFile({
            url: 'https://example.weixin.qq.com/upload', // 仅为示例，非真实的接口地址
            filePath: tempFilePaths[0],
            name: 'file',
            formData: {
                user: 'test'
            },
            success(res) {
                const data = res.data
                // do something
                }
        })
    }
})
```

###### 返回值 UploadTask

UploadTask 一个可以监听上传进度的事件和取消上传的对象

- UploadTask.abort() 中断上传任务

- UploadTask.onProgressUpdate(callback)

  监听上传进度变化事件

- UploadTask.offProgressUpdate(callback)

  取消监听上传进度条变化事件
- UploadTask.onHeadersReceived(callback)

  监听 HTTP Response Header 事件, 比请求完成事件更早

```js
uploadTask.onProgressUpdate((res) => {
    console.log('上传进度', res.progress)
    console.log('已经上传的数据长度', res.totalBytesSent)
    console.log('预期需要上传的数据总长度', res.totalBytesExpectedToSend)
})

uploadTask.abort() // 取消上传任务
```

### WebSocket

##### wx.connectSocket(Object object)

创建一个 WebScoket 连接

- url  开发者服务器 wss 接口地址
- header 请求头设置
- protocols 子协议数组

- success 成功回调
- ...

###### 返回值 SocketTask

WebSocket 任务管理, 可以通过 wx.connectSocket() 接口创建返回

方法

- SocketTask.send(Object object) 通过 WebSocket 连接发送数据
- SocketTask.close(Object object) 关闭 WebSocket 连接
- SocketTask.onOpen(callback) 监听 WebSocket 连接打开事件
- SocketTask.onClose(callback) 监听 WebSocket 连接关闭事件
- SocketTask.onError(callback) 监听 WebSocket 错误事件
- SocketTask.onMessage(callback) 监听 WebSocket 接收到服务器的消息事件

##### wx.onSocketError(callback)

监听 WebSocket 错误事件

- callback WebSocket错误事件的回调

##### wx.onSocketMessage(callback)

监听 WebSocket 接受到服务器的消息事件

回调参数 res.data 服务器返回的消息

##### wx.onSocketClose(callback)

监听 WebSocket 连续关闭事件

- callback WebSocket 连续关闭事件的回调函数

##### wx.onSocketOpen(callback)

监听 WebSocket 连续打开事件

- callback 参数 res.header 连接成功的 HTTP 响应头

##### wx.sendSocketMessage(Object object)

通过 WebSocket 连接发送数据, 需要先 wx.connectSocket, 并在 wx.onSocketOpen 回调之后才能发送

- data   string/ArrayBuffer 需要发送的内容
- success 成功回调
- ...

```js
const socketOpen = false
const socketMsgQueue = []
wx.connectSocket({
    url: 'test.php'
})

wx.onSocketOpen(function (res) {
    socketOpen = true
    for (let i = 0; i < socketMsgQueue.length; i++) {
        sendSocketMessage(socketMsgQueue[i])
    }
    socketMsgQueue = []
})

function sendSocketMessage(msg) {
    if (socketOpen) {
        wx.sendSocketMessage({
            data: msg
        })
    } else {
        socketMsgQueue.push(msg)
    }
}
```

##### wx.closeSocket(Object object)

关闭 WebSocket 连接

- code	默认值1000(正常关闭连接)

- reason   可读字符串, 表示连接被关闭的原因. 字符串必须不长于123字节的 UTF-8文本
- success 成功回调
- ...

### mDns

##### wx.onLocalServiceResolveFail(callback)

监听 mDNS 服务解析失败的事件

- callback 回调

##### wx.onLocalServiceDiscoveryStop(callback)

监听 mDNS 服务停止搜索的事件

##### wx.onLocalServiceLost(callback)

监听 mDNS 服务离开的事件

- callback

  参数 res.serviceType	服务的类型

  参数 res.serviceName  服务的名称

##### wx.onLocalServiceFound(callback)

监听 mDNS 服务发现的事件

- callback

  参数 res.serviceType 服务的类型

  参数 res.serviceName 服务的名称

  参数 res.ip	服务的 ip 地址

  参数 res.port 服务的端口

## 数据缓存

##### wx.getStorageInfo(Object object)

异步获取当前 storage 的相关信息

- success 成功回调
  - keys 当前 storage 中所有的 key
  - currentSize 当前占用的空间大小
  - limitSize 限制的空间大小
- ...

##### wx.getStorageInfoSync()

是wx.getStorageInfo 同步版本

- keys  当前 storage 中所有的 key
- currentSize  当前占用的空间大小 KB
- limitSize  限制空间大小

实例代码

```js
wx.getStorageInfo({
    success(res) {
        console.log(res.keys)
        console.log(res.currentSize)
        console.log(res.limitSize)
    }
})

try {
    const res = wx.getStorageInfoSync()
    console.log(res.keys)
    console.log(res.currentSize)
    console.log(res.limitSize)
} catch (e) {
    // Do something when catch error
}
```

##### wx.clearStorage(Object object)

清理本地数据缓存

- success()
- ...

##### wx.clearStorageSync()

wx.clearStorage() 的同步版本

示例 

```js
wx.clearStorage()

try {
    wx.clearStorageSync()
} catch (e) {
    // Do something when catch error
}
```

##### wx.removeStorage(Object object)

从本地缓存中移除指定 key

- key 本地缓存中指定key
- success 成功回调

##### wx.removeStorageSync()

wx.removeStorage() 的同步版本

示例

```js
wx.removeStorage({
    key: 'key',
    success(res) {
        console.log(res.data)
    }
})

try {
    wx.removeStorageSync('key')
} catch (e) {
    // Do something when catch error
}
```

##### wx.setStorage(Object object)

将数据存储在本地缓存中指定的 key 中. 会覆盖原来 key 对应的内容. 数据存储生命周期跟小程序本身一致, 除非用户主动删除或查过一定时间被自动清理, 否则数据都一直可用. 单个 key 允许存储最大数据长度为 1MB, 所有数据存储上线为 10MB

- key 本地存储中指定的 key
- data 需要存储的内容, 支持原生类型, Date 及能通过 JSON.stringify 序列化的对象
- success 成功回调
- ...

##### wx.setStorageSync(key, data)

wx.setStorage() 的同步版本

```js
wx.setStorage({
    key: 'key',
    data: 'value'
})

try {
    wx.setStorageSync('key', 'value')
} catch (e) { }
```

##### wx.getStorage(Object object)

从本地缓存中异步获取指定 key 的内容

- key  本地缓存中的指定key
- success 读取成功回调
  - 参数 res.data     本地缓存指定 key 对应的内容

```js
wx.getStorage({
    key: 'key',
    success(res) {
        console.log(res.data)
    }
})

try {
    const value = wx.getStorageSync('key')
    if (value) {
        // Do something with return value
    }
} catch (e) {
    // Do something when catch error
}
```

## 媒体

### 地图

##### wx.createMapContext(mapId, this)

- mapId 		<map>组件的 id
- this                  在自定义组件下,当前组件示例的 this, 用来操作组件内 <map> 组件

###### 返回值 MapContext

MapContext 实例, 可以通过 wx.createMapContext 获取

mapContext 通过 id 跟一个 <map> 组件绑定, 操作对应 <map> 组件

方法

- MapContext.getCenterLocation(Object object)

  获取当前地图中心的经纬度, 返回 gcj02 坐标系, 可以用于 wx.opnLoaction()

  - success 成功回调
    - res.longitude 经度
    - res.latitude  纬度
  - ...

- MapContext.moveToLocation()

  将地图中心移动到当前定位点. 需要配合 map 组件的 show-loaction 使用

- MapContext.translateMarker(Object object)

  平移 Marker, 带动画

  - markerId 指定 marker
  - destination 指定移动目标点
    - longitude 经度
    - latitude  纬度
  - autoRotate 移动过程是否旋转
  - rotate 旋转角度
  - duration 动画持续时长
  - animationEnd 动画结束回调
  - success 成功回调

- MapContext.includePoints(Object object) 

  缩放视野展示所有经纬度

  - points 显示在可视区内坐标点列表
    - longitude 经度
    - latitude 纬度
  - success 成功回调
  - ..

- MapContext.getRegion()

  获取当前地图的视野范围

  - success 
    - res.southwest 西南角经纬度
    - res.northeast 东北角经纬度

- MapContext.getScale()

  获取地图的缩放级别

  - success 
    - res.scale 缩放值

### 图片

##### wx.compressImage()

压缩图片接口, 可选压缩质量

- src 图片路径(相对路径, 临时文件路径, 存储文件路径)
- quality 压缩质量 数值越小, 质量越低, 压缩率越高 (仅支持 jpg)
- success 成功回调

```js
wx.compressImage({
  src: '', // 图片路径
  quality: 80 // 压缩质量
})
```

##### wx.saveImageToPhotosAlbum(Object object)

调用钱需要 用户授权 scope.writePhotosAlbum

保存图片到系统相册

- filePath 图片文件路径
- success 成功回调

```js
wx.saceImageToPhotosAlbum({
    success(res){}
})
```

##### wx.getImageInfo(Object object)

获取图片信息, 网络图片需要先配置 download 域名才能生效

- src 图片路径
- success 成功回调
  - res.width 图片原始宽度
  - res.height 图片原始高度
  - res.path 图片的本地路径
  - res.orientation 拍照时设备方向
    - up 默认(手机横持拍照)
  - res.type 图片格式

##### wx.previewImage(Object object)

在新页面中全屏预览图片. 预览过程中用户可以进行保存, 发送给好友等操作

- urls  Array.<string>需要预览的图片链接列表, 必须
- current  urls的第一张 当前显示图片的链接
- success 成功回调

##### wx.chooseImage(Object object)

从本地相册选择图片或使用相机拍照

- count 最多可选择图片张数, 默认9
- sizeType 所选图片尺寸, 默认 ['original', 'compressed']
  - original
  - compressed
- sourceType 选择图片来源 ['album', 'camera']
  - album 从相册选图
  - camera 使用相机照相
- success 成功回调
  - 参数 res.tempFilePaths
  - 参数 res.tempFiles
    - 属性 path 本地临时文件路径
    - 属性 size 本地临时文件大小

示例 

```js
wx.chooseImage({
    count: 1,
    sizeType: ['original', 'compressed'],
    sourceType: ['album', 'camera'],
    success(res) {
        // tempFilePath可以作为img标签的src属性显示图片
        const tempFilePaths = res.tempFilePaths
        }
})
```

### 视频

##### wx.saveVideoToPhotosAlbum(Object object)

调用前需要 用户授权 scope.writePhotosAlbum

保存视频到系统相册

- filePath 视频文件路径
- success 成功回调
- ...

```js
wx.saveVideoToPhotosAlbum({
    filePath: 'wxfile://xxx',
    success(res) {
        console.log(res.errMsg)
    }
})
```

##### wx.chooseVideo(Object object)

拍摄视频或从手机相册选视频

- sourceType 视频选择的来源 默认 ['album', 'camera']
  - album 从相册中选择视频
  - camera 使用相机拍摄视频
- compressed 是否压缩所选择的视频文件
- maxDuration 拍摄视频最长时间. 单位 s
- camera 
  - back 启用后置摄像头
  - front 启用前置摄像头
- success 成功回调
  - tempFilePath 选定视频临时文件路径
  - duration  选定视频时间长度
  - size 选定数据量大小
  - height 选定视频的高度
  - width 选定视频宽度

```js
wx.chooseVideo({
    sourceType: ['album', 'camera'],
    maxDuration: 60,
    camera: 'back',
    success(res) {
        console.log(res.tempFilePath)
    }
})
```

##### wx.createVideoContext(id, this)

创建 video 上下文 VideoContext 对象

- id  <video> 组件的id
- this  当前组件实例的this, 以操作组件内 <video> 组件

###### 返回值

VideoContext

VideoContext 实例, 可以通过 wx.createVideoContext 获取

videoContent 通过 id he一个 <vidoe> 组件绑定, 操作对应的 <video> 组件

- VideoContext.play() 播放视频
- VideoContext.pause() 暂停视频
- VideoContext.stop() 跳转到指定位置
- VideoContext.seek(number position) 跳转指定位置
- VideoContext.sendDanmu(Object data) 发送弹幕
- VideoContext.playbackRate(number rate) 设置播放倍速
- VideoContext.requestFullScreen(Object object) 进入全屏
- VideoContext.exitFullScreen() 退出全屏
- VideoContext.showStatusBar() 显示状态栏(ios全屏下有效)
- VideoContext.hideStatusBar() 隐藏状态栏(ios有效)

### 音频

##### wx.stopVoice(Object object)

结束播放语音

- success 成功回调

##### wx.pauseVoice(Object object)

暂停正在播放的语音, 再次调用 wx.playVoice 播放同一个文件时, 会从暂停处开始播放, 如果想要从头开始播放, 需要先调用 wx.stopVoice

- success 成功回调

##### wx.playVoice(Object object)

开始播放语音. 同时只允许一个语音文件还没播放完

- filePath 需要播放的语音文件的文件路径
- duration 指定录音时长, 到达指定录音时长后自动停止录音
- success 成功回调

```js
wx.startRecord({
    success(res) {	//用户授权成功
        const tempFilePath = res.tempFilePath
        wx.playVoice({
            filePath: tempFilePath,
            complete() { }
        })
    }
})
```

##### wx.setInnerAudioOption(Object object)

设置 InnerAudioContext 的播放选项, 设置之后对当前小程序全局生效

- mixWithOther 是否与其他影片混播, 设置为 true 之后, 不会终止其他应用或微信内的音乐, 默认 true
- obeyMuteSwitch (ios生效) 是否遵循静音开关, 设置为false时, 即使在静音模式下, 也能播放声音. 默认 true
- success 成功回调

##### wx.getAvailableAudioSources(Object object)

获取当前支持的音频输入源

- success

  参数 res.audioSources Array.<string> 支持的音频输入源列表, 可在 [RecorderManager.start()](https://developers.weixin.qq.com/miniprogram/dev/api/RecorderManager.start.html) 接口中使用

  ​	合法值: auto 自动设置, 所有平台适用

##### wx.createInnerAudioContext()

创建内部 audio 上下文 InnerAudioContext 对象

###### 返回值 InnerAudioContext

- InnerAudioContext.onCanplay(callback) 监听音频进入可以播放状态的事件
- InnerAudioContext.offCanplay(callback) 取消监听音频进入可以播放状态的事件
- InnerAudioContext.onPlay(callback) 监听音频播放事件
- InnerAudioContext.offPlay(callback) 取消监听音频播放事件
- InnerAudioContext.onPause(callback) 监听音频暂停事件
- InnerAudioContext.offPause(callback) 取消监听音频播放事件
- InnerAudioContext.onStop(callback) 监听音频停止事件
- InnerAudioContext.offStop(callback) 取消监听音频停止事件
- InnerAudioContext.onEnded(callback) 监听音频自然播放至结束的事件
- InnerAudioContext.offEnded(callback) 取消监听音频自然播放到结束的事件
- InnerAudioContext.onTimeUpdate(callback) 监听音频播放进度更新事件
- InnerAudioContext.offTimeUpdate(callback) 取消监听音频播放进度更新事件
- InnerAudioContext.onError(callback) 监听音频播放错误事件
- InnerAudioContext.offError(callback) 取消监听音频播放错误事件
  - 回调参数 res.errCode
    - 10001 系统错误
    - 10002 网络错误
    - 10003 文件错误
    - 10004 格式错误
    - -1         未知错误
- InnerAudioContext.offError(callback) 取消监听音频播放错误事件
- InnerAudioContext.onWaiting(callback) 监听音频加载中事件, 音频因为数据不足, 需要停下来加载时触发
- InnerAudioContext.onSeeking(callback) 监听音频进行跳转操作事件
- InnerAudioContext.offSeeking(callback) 取消监听音频进行跳转操作的事件
- InnerAudioContext.onSeeked(callback) 监听音频完成跳转操作的事件
- InnerAudioContext.offSeeked(callback) 取消监听音频跳转完成事件
- InnerAudioContext.paly() 播放
- InnerAudioContext.pause() 暂停, 再次播放会从暂停处开始播放
- InnerAudioContext.stop() 停止, 再播放会从头开始
- InnerAudioContext.seek(number postion) 跳转到指定位置
  - 参数 number position 跳转的时间. 单位s, 精确到小数点后3位, 即支持 ms级别精度
- InnerAudioContext.destroy() 销毁当前实例

##### wx.createAudioContext(id, this)

创建 audio 上下文 AudioContext 对象

- id <audio> 组件的 id

###### 返回值 AudioContext

- AudioContext.setSrc(string src) 设置音频地址
- AudioContext.play() 播放音频
- AudioContext.pause() 音频暂停
- AudioContext.seek(number position) 音频跳转到指定位置, 单位s

### 背景音频

##### wx.onBackgroundAudioStop(callback) 

监听音乐停止事件

##### wx.onBackgroundAudioPause(callback)

监听音乐暂停事件

##### wx.onBackgroundAudioPlay(callback)

监听音乐播放事件

##### wx.stopBackgroundAudio(Object object)

停止播放音乐

- access 成功回调
- ...

示例 wx.stopBackgroundAudio()

##### wx.seekBackgroundAudio(Object object)

控制音乐播放进度

- position 音乐位置 单位 s
- success 成功回调
- ...

实例 wx.seekBackgroundAudio({  position: 30})

##### wx.pauseBackgroundAudio(Object object)

暂停播放音乐

- success 成功回调
- ...

##### wx.playBackgroundAudio(Object object)

使用后台播发器播放音乐. 对于微信客户端来说, 只能同时有一个后台音乐在播放. 当用户离开小程序后, 音乐将停止播放; 当用户在其他小程序占用了音乐播放器, 原有的小程序内的音乐将停止播放

- dataUrl 音乐链接(支持m4a, aac, mp3, wav)
- title 音乐标题
- coverImgUrl 封面URL
- success 成功回调
- ...

```js
wx.playBackgroundAudio({
    dataUrl: '',
    title: '',
    coverImgUrl: ''
})
```

##### wx.getBackgroundAudioPlayerState(Object object)

获取后台音乐播放状态

- success 接口调用成功回调
  - res.duration 选定音频长度(s), 只有在音乐播放中时返回
  - res.currentPosition 选定音频的播放位置(s)
  - res.status 播放状态
    - 0 暂停中
    - 1 播放中
    - 2 没有音乐播放
  - res.downloadPercent 音频下载进度百分比
  - res.dataUrl 歌曲数据链接
- ...

##### wx.getBackgroundAudioManager()

获取 全局唯一 的背景眼音频管理器, 小程序切入后台, 如果音频处于播放状态, 可以继续播放, 但是后台状态不能通过调用 api 操作音频的播放状态

微信客户端 6.7.2 开始, 如果需要在小程序后台继续播放音频, 需要在 app.json 中配置 requiredBackgroundModes 属性, 正式版需要通过审核

###### 返回值

BackgroundAudioManager

- BackgroundAudioManager.play() 播放音乐
- BackgroundAudioManager.pause() 暂停播放
- BackgroundAudioManager.seek() 跳转到指定位置
- BackgroundAudioManager.stop() 停止音乐
- BackgroundAudioManager.onCanplay() 监听背景音频进入可播放状态事件, 不保证后面可流畅播放
- BackgroundAudioManager.onWaiting() 监听音频加载中事件, 当音频因为数据不足, 需要停下来加载时会触发
- BackgroundAudioManager.onError() 监听背景音频播放错误事件
- BackgroundAudioManager.onPlay() 监听背景音频播放事件
- BackgroundAudioManager.onPause() 监听背景音频暂停事件
- BackgroundAudioManager.onTimeUpdate() 监听背景音频播放进度更新事件
- BackgroundAudioManager.onStop() 监听背景音频停止事件
- BackgroundAudioManager.onNext() 监听用户在系统音乐面板点击下一曲事件(IOS)
- BackgroundAudioManager.onPrev() 监听用户在系统音乐面板点击上一曲事件(IOS)

### 实时音视频

##### wx.createLivePusherContext()

创建 live-pusher 上下文 LivePusherContext 对象

###### 返回值 LivePusherContext

LivePusherContext实例, 可通过 wx.createLivePusherContext 获取

livePusherContext 与页面内唯一的 <live-pusher> 组件绑定, 操作对应的  <live-pusher> 组件

- LivePusherContext.start() 播放推流
- LivePusherContext.stop() 停止推流
- LivePusherContext.pause() 暂停推流
- LivePusherContext.resume() 回复推流
- LivePusherContext.switchCamera() 切换前后摄像头
- LivePusherContext.snapshot() 快照
- LivePusherContext.toggleTorh() 切换
- LivePusherContext.playBUG(object object) 播放背景音乐
- LivePusherContext.stopBGM() 停止背景音
- LivePusherContext.pauseBUG() 暂停背景音
- LivePusherContext.resumeBUG() 回复背景音
- LivePusherContext.setBUGMVolume(Object object) 设置背景音量

##### wx.createLivePlayerContext(id, this)

创建 live-player 上下文 LivePlayerContext 对象

- id <live-player> 组件 id 
- this 自定义组件下当前组件实例的 this, 以操作<live-player>组件

###### 返回值 LivePlayerContext

- LivePlayerContext.play(Object object) 播放
  - success 成功回调
  - ...
- LivePlayerContext.stop(Object object) 停止
  - success 成功回调
  - ...

- LivePlayerContext.mute(Object object) 静音
  - success 成功回调
  - ...
- LivePlayerContext.pause(Object object) 暂停推流
  - success 成功回调
  - ...
- LivePlayerContext.resume(Object object) 恢复
  - success 成功回调
  - ...
- LivePlayerContext.requestFullScreen(Object object) 进入全屏
  - 参数属性
    - direction 设置全屏时的方向, 默认 0
      - 0 正常横向
      - 90 屏幕逆时针90度
      - -90 屏幕顺时针90度
    - success 成功回调

LivePlayerContext.exitFullScreen(Object object) 退出全屏

- success 成功回调
- ...

### 录音

##### wx.stopRecord()

停止录音

##### wx.startRecord(Object object)

开始录音, 当主动调用 wx.stopRecord, 或者录音超过1分钟时自动结束录音. 当离开小程序时, 此接口无法调用

- success 成功回调

  参数 res.tempFilePath 录音文件的临时路径

- ..

示例

```js
wx.startRecord({
    success(res) {
        const tempFilePath = res.tempFilePath
        }
})
setTimeout(function () {
    wx.stopRecord() // 结束录音
}, 10000)
```

##### wx.getRecorderManager()

获取全局唯一的录音管理器 RecorderManager

###### 返回值 RecorderManager

- RecorderManager.start(Object object) 开始录音
  - duration  默认60000, 录音时长, 单位 ms, 最大值600000ms
  - sampleRate 采样率, 默认 8000
  - numberOfChannels 默认2 录音通道数
  - encodeBitRate 默认48000 编码码率
  - format 默认aac 音频格式
    - mp3
    - aac
  - frameSize 指定帧大小
  - audioSource 指定录音的音频输入源, 可通过 wx.getAvailableAudioSources() 获取当前音频源

- RecorderManager.pause() 暂停录音
- RecorderManager.resume() 继续录音
- RecorderManager.stop() 停止录音
- RecorderManager.onStart(callback) 监听录音开始事件
- RecorderManager.onResume(callback) 监听录音继续事件
- RecorderManager.onPause(callback) 监听录音暂停事件
- RecorderManager.onStop(callback) 监听录音结束事件
  - 回调函数参数属性 res.tempFilePath 录音文件的临时路径
- RecorderManager.onFrameRecorded(callback) 监听已录制完指定帧大小的文件事件. 如果设置了 frameSize, 则会回调此事件
  - 回调函数参数属性
    - frameBuffer  录音分片数据
    - isLastFrame 当前帧是否正常录音前的最后一帧
- RecorderManager.onError(callback) 监听录音错误事
  - 回调参数res.errMsg 错误信息
- RecorderManager.onInterruptionBegin(callback) 监听录音因为受到系统占用而被终端开始事件, 以下场景会触发此事件: 微信语音聊天, 微信视频聊天, 此事件触发后, 录音会被暂停, pause 事件于此事件后触发
- RecorderManager.onInterruptionEnd(callback) 监听录音中断结束事件. 受到 interruptionBegin 事件之后, 小程序内所有录音都会暂停, 收到此事件之后才可再次录音成功.

示例代码

```js
const recorderManager = wx.getRecorderManager()

recorderManager.onStart(() => {
  console.log('recorder start')
})
recorderManager.onPause(() => {
  console.log('recorder pause')
})
recorderManager.onStop((res) => {
  console.log('recorder stop', res)
  const {tempFilePath} = res
})
recorderManager.onFrameRecorded((res) => {
  const {frameBuffer} = res
  console.log('frameBuffer.byteLength', frameBuffer.byteLength)
})

const options = {
  duration: 10000,
  sampleRate: 44100,
  numberOfChannels: 1,
  encodeBitRate: 192000,
  format: 'aac',
  frameSize: 50
}

recorderManager.start(options)
```

### 相机

##### wx.createCameraContext()

创建 camera 上下文 CameraContext 对象

###### 返回值 CameraContext

cameraContext 与页面内唯一的 <camera> 组件绑定, 操作对应的 <camera> 组件.

方法

- CameraContext.takePhoto(Object object) 拍摄照片
  - quality 成像质量 string
    - high 高质量
    - normal 普通质量
    - low 低质量
  - success 成功回调
    - 回调参数 res.tempImagePath 照片文件临时路径
  - ...
- CameraContext.startRecord(Object object) 开始录像
  - timeoutCallback(callback) 超过30s或页面 onHide 时会结束录像
    - 回调参数 res
      - tempThumbPath  封面照片文件的临时路径
      - tempVideoPath 视频的文件的临时路径
  - success 成功回调
  - ...
- CameraContext.stopRecord(Object object) 结束录像
  - success 成功回调
    - 参数 res
      - 属性 tempThumbPath 分秒图片文件的临时路径
      - 属性 tempVideoPath 视频的文件的临时路径

### 字体

##### wx.loadFontFace(Object object)

动态加载网络字体. 文件地址需为下载类型

注意:

1. 引入中文字体，体积过大时会发生错误，建议抽离出部分中文，减少体积，或者用图片替代
2. 字体链接必须是https（ios不支持http)
3. 字体链接必须是同源下的，或开启了cors支持，小程序的域名是`servicewechat.com`
4. canvas等原生组件不支持使用接口添加的字体
5. 工具里提示 Faild to load font可以忽略

- family 定义的字体名称
- source 字体资源的地址, 建议格式为 TTF 和 WOFF
- desc  object可选字体描述符
  - style	字体样式(normal/italic/oblique)
  - weight    字体粗细(normal/bold/100-900)
  - variant  设置小写大写字母的字体显示文本
- success 调用成功回调
- ...

## 位置

##### wx.openLocation(Object object)

使用微信内置地图查看位置

 参数

- latitude 纬度 -90~90, 负表示南纬 使用 gcj02国测坐标系
- longitude 纬度 -180~180 负表示西经
- scale 缩放比例 5~18
- name 位置名
- address 地址的详细说明
- success 成功回调
- ...

##### wx.getLocation(Object object)

调用需要用户授权 scope.userLocation

获取当前的地理位置, 速度. 当用户离开小程序后, 此接口无法调用

参数

- type string 默认wgs84, wgs84返回 gps 坐标, gcj02 返回可用于 wx.openLocation 的坐标
- altitude 传入true会返回高度信息, 由于获取高度需要较高精度, 会减慢接口返回速度
- success 成功回调
  - 回调参数 res
    - latitude 纬度
    - longitude 精度
    - speed 速度 m/s
    - accuracy 位置的精确度
- ...

示例

```js
wx.getLocation({
    type: 'gcj02', // 返回可以用于wx.openLocation的经纬度
    success(res) {
        const latitude = res.latitude
        const longitude = res.longitude
        wx.openLocation({
            latitude,
            longitude,
            scale: 18
        })
    }
})
```

##### wx.chooseLocation(Object object)

打开地图选择位置. 调用前需要用户授权 scope.userLocation

参数

- success 接口调用成功回调
  - 回调参数 res
    - name 位置名称
    - address 详细地址
    - latitude 纬度
    - longitude 经度
- ...

```js
wx.chooseLocation({
    success(res) {
        console.log(res)
    }
})
```

## 转发

##### wx.showShareMenu(Object object)

显示当前页面转发按钮

- withShareTicket 是否使用 shareTicket 的转发详情
- success 成功回调
- ...

##### wx.hideShareMenu(Object object)

隐藏转发按钮

- success 成功回调
- ....

##### wx.getShareInfo(Object object)

获取转发详细信息

- shareTicket  string 必填 shareTicket
- timeout 超时时间
- success 成功回调
  - 参数 res 
    - errMsg 错误信息
    - encryptedData 包括敏感数据在内的完整转发信息的加密数据
    - iv 加密算法初始向量
- ...

##### wx.updateShareMenu(Object object)

更新转发属性

- withShareTicket 是否使用带 shareTicket 的转发详情
- isUpdatableMessage  是否是动态消息
- activityId 动态消息的 activityId, 通过 createActivityId 接口获取
- templateInfo 动态消息的模板信息
  - parameterList 参数列表
    - name 参数名
    - value 参数值
- success 成功回调
- ...

## 文件

##### wx.getFileSystemManager()

获取全局唯一的文件管理器

###### 返回值 FileSystemManger

- FileSystemManager.access(Object object) 判断文件/目录是否存在

  - path 文件路径
  - success 成功回调
    - res.errMsg 错误信息 fail no such file or directory ${path}
  - ...

  FileSystemManager.accessSync(path)  同步版本

- FileSystemManager.appendFile(Object object) 在文件结尾追加内容

  - filePath 追加内容的文件路径

  - data  要追加的文本或二进制数据流(string/ArrayBuffer)

  - encoding 指定写如文件的字符编码, 默认 utf8

    - 合法值: ASCII base64 binary hex  ucs2/ucs-2/utf16le/utf-16le  utf-8/utf8  latin1

  - success 成功回调

  - fail 失败回调

    - res.errMsg 错误信息

    | fail no such file or directory, open ${filePath}          | 指定的 filePath 文件不存在           |
    | --------------------------------------------------------- | ------------------------------------ |
    | fail illegal operation on a directory, open "${filePath}" | 指定的 filePath 是一个已经存在的目录 |
    | fail permission denied, open ${dirPath}                   | 指定的 filePath 路径没有写权限       |
    | fail sdcard not mounted                                   | 指定的 filePath 是一个已经存在的目录 |

    FileSystemManager.appendFileSync(filePath, data, encoding) 同步版本

- FileSystemManager.saveFile(Object object) 保存临时文件到本地. 会移动临时文件, 调用成功后, tempFilePath不可用

  - tempFilePath 临时文件路径

  - filePath 要存储的文件路径

  - success 成功回调

    - res.savedFilePath 存储后的文件路径

  - fail 失败回调

    - res.errMsg 错误信息

    | fail tempFilePath file not exist            | 指定的 tempFilePath 找不到文件 |
    | ------------------------------------------- | ------------------------------ |
    | fail permission denied, open "${filePath}"  | 指定的 filePath 路径没有写权限 |
    | fail no such file or directory "${dirPath}" | 上级目录不存在                 |

  - ...

    FileSystemManager.saveFileSync(tempFilePath, filePath) 同步版本

- FileSystemManager.getSavedFileList(Object object) 获取该小程序已保存的临时文件列表

  - success 成功回调
    - 回调参数 res.fileList 文件数组
  - ...

- FileSystemManager.removeSavedFile(Object object) 删除该小程序下已保存的本地缓存文件

  - filePath 需要删除的文件路径
  - success 成功回调
  - fail 失败回调
    - res.errMsg 合法值: fail file not exist 指定 tempFilePath 找不到文件
  - ...

- FileSystemManager.copyFile(Object object) 复制文件

  - srcPath 源文件路径, 只可以是普通文件

  - destPath 目标文件路径

  - success 成功回调

  - fail 失败回调

    - res.errMsg 错误信息

    | fail permission denied, copyFile {srcPath} -> ${destPath}  | 指定目标文件路径没有写权限                   |
    | ------------------------------------------------------------ | -------------------------------------------- |
    | fail no such file or directory, copyFile {srcPath} -> ${destPath} | 源文件不存在，或目标文件路径的上层目录不存在 |

  - ...

    copyFileSync(srcPath, destPath) 同步版本

- FileSystemManager.getFileInfo(Object object) 获取该小程序下的本地临时文件或本地缓存文件信息

  - filePath 读取的文件路径
  - success 成功回调

- FileSystemManager.mkdir(Object object) 创建目录

  - dirPath 创建的目录路径

  - success 成功回调

    mkdirSync(dirPath) 同步版本

- FileSystemManager.readFile(Object object) 读取本地文件内容

  - filePath 要读取的文件的路径

  - encoding 指定读取文件的字符集编码, 不传以 ArrayBuffer 格式读取文件的二进制内容

  - success 成功回调

    - res.data 文件内容(string/ArrayBuffer)

  - ... 

    readFileSync(filePath, encoding) 同步版本

- FileSystemManager.readdir(Object object) 读取目录内文件列表

  - dirPath 要读取的目录文件

  - success 成功回调

    - 回调参数 res.files 指定目录下的文件名数组

    FileSystemManager.readdirSync(dirPath) 同步版本, 返回值 files 文件名数组

- FileSystemManager.rename(Object object) 重命名文件, 可以把文件从 oldPath 移动到 newPath

  - oldPath 源文件路径, 可以是普通文件或目录

  - newPath 新文件路径

  - success 成功回调

  - ...

    FileSystemManager.renameSync(oldPath, newPath) 同步版本

- FileSystemManager.rmdir() 删除目录

  - dirPath 要删除的目录路径

  - recursive 是否递归删除目录, ture 则删除该目录和该目录下的所有子目录及文件, 默认 false

  - success 成功回调

    FileSystemManager.rmdirSync(disPath, recursive) 同步版本

- FileSystemManager.stat(Object object) 获取 Stats 对象

  - path 文件/目录 路径
  - recursive 是否递归获取目录下的每个文件的 Stats 信息
  - success 成功回调
    - 返回值res.stats 当 recursive 是 false 时, res.stats 是一个 States 对象, 反之为 Object , key 以 Path为根路径的相对路径, value 是 该路径对应的 Stats 对象
  - ...

- FileSystemManager.unlink(Object object) 删除文件

  - filePath 删除的文件路径

  - success 成功回调

  - ...

    FileSystemManager.unlinkSync(fIlePath) 同步版本 

- FileSystemManager.unzip(Object object) 解压文件

  - zipFilePath 源文件路径, 只可以使 zip 压缩文件
  - targetPath 目标目录路径
  - success 成功回调

- FileSystemManager.writeFile(Obejct object) 写文件

  - filePath  要写入的文件路径

  - data 写入的文本或二进制数据

  - encoding 指定写入文件的字符集编码(默认utf8)

  - success 成功回调

  - ...

    FileSystemManager.writeFileSync(filePath, data, encoding) 同步版本

###### Stats 

- Stats.isDirectory() 判断当前文件是否是一个目录
- Stats.isFile() 判断当前文件是否是一个普通文件

##### wx.getFileInfo(Obejct object)

获取文件信息

- filePath 本地文件路径
- digestAlgorithm  默认值 md5 计算文件摘要的算法
  - md5 算法
  - sha1 算法
- success 成功回调
  - size 文件大小, 单位字节
  - sigest 按照传入的 digestAlgorithm 计算得出的文件摘要
- ...

示例

```js
wx.getFileInfo({
    filePath: "/temp/t1.txt",
    digestAlgorithm: "sha1",
    success(res) {
        console.log(res.size)
        console.log(res.digest)
    }
})
```

##### wx.getSavedFileInfo(Object object)

获取本地文件的文件信息. 此接口只能用于获取已保存到本地的文件, 若需要获取临时文件信息, 使用 wx.getFileInfo()

- filePath 文件路径
- success 成功回调
  - 回调参数res
    - size  文件大小
    - createTime 文件保存时的时间戳, 从 1970/01/01 08:00:00 到该时刻的秒数
- ...

##### wx.getSavedFileList(Object object)

获取该小程序已保存的本地缓存文件列表

- success 成功回调
  - 参数 res.fileList 文件数组, 每一项是一个fileItem
    - filePath 文件路径
    - size 文件大小
    - createTime 创建时间戳

##### wx.removeSavedFile(Object object)

删除本地缓存文件

- filePath  需要删除的文件路径
- success 成功回调
- ...

##### wx.openDocument(Obejct object)

新开页面打开文档

- filePath 文件路径, 可通过 downloadFile 获取
- fileType 文件类型, 指定文件类型打开文件
  - 支持 doc docx xls xlsx ppt pptx pdf 等格式
- success 成功回调
- ...

示例

```js
wx.downloadFile({
    // 示例 url，并非真实存在
    url: 'http://example.com/somefile.pdf',
    success(res) {
        const filePath = res.tempFilePath
        wx.openDocument({
            filePath,
            success(res) {
                console.log('打开文档成功')
            }
        })
    }
})
```

##### wx.saveFile(Object object)

保存文件到本地. 注意的是 saveFile 会把临时文件移动. 所以调用成功后传入的临时文件路径将不可用

- tempFilePath  需要保存的文件的临时路径
- success 成功回调
  - 返回值 res.savedFilePath 存储后的文件路径  
- ...

示例

```js
wx.chooseImage({
    success(res) {
        const tempFilePaths = res.tempFilePaths
        wx.saveFile({
            tempFilePath: tempFilePaths[0],
            success(res) {
                const savedFilePath = res.savedFilePath
                }
        })
    }
})
```

## 开放接口

### 登录

##### wx.login(Object object)

调用接口获取登录凭证(code). 通过凭证进而换区用户登录状态信息, 包括用户的唯一标识(openid) 及本次登陆的会话密匙(session_key) 等. 用户数据的加解密通讯需要依赖会话密匙完成

- timeout 超时时间, 单位 ms
- success 调用成功的回调函数
  - 回调参数 res.code 用户登录凭证, 有效期五分钟, 开发者需要在开发者服务器厚爱调用 code2Session, 使用 code 换取 openid 和 session_key 等信息
- fail 调用失败回调
- ...

##### code2Session

登录凭证校验, 通过 wx.login() 接口获得临时登录凭证 code 后传到开发者服务器调用此接口完成登录流程. 本接口应在后台服务器调用

请求地址 `GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code`

- appid 小程序 appid
- secret 小程序 appSecret
- js_code 登录时获取的 code
- grant_type 授权类型, 此处只需要填写 authorization_code

###### 返回值 Object

返回的 JSON 数据包

- oppid 用户唯一标识
- session_key 会话密匙
- unionid 用户在开放平台的唯一标识, 在满足 UnionID 下发条件的情况会返回
- errcode 错误码
  - -1 系统繁忙, 开发者稍后再试
  - 0 请求成功
  - 40029 code 无效
  - 45011 频率限制, 每个用户每分钟100次
- errmsg 错误信息

##### wx.checkSession(Object object) 检查登录状态是否过期

通过 wx.login 接口获得的用户登录行状态拥有一定的时效性. 用户越久未登录小程序, 用户登录状态越有可能失效. 反之, 如果用户一直在使用小程序, 则用户登录状态一直保持有效. 具体时效逻辑由微信维护. 我们只要调用 wx.checkSession 接口检测当前用户登录状态是否有效.

登录状态过期后开发者可以再调用 wx.login 获取新的用户登录状态. 调用成功说明当前 session_key 未过期, 调用失败说明 session_key 已经过期.

- success 成功回调
- fail 失败的回调

```js
wx.checkSession({
    success() {
        // session_key 未过期，并且在本生命周期一直有效
    },
    fail() {
        // session_key 已经失效，需要重新执行登录流程
        wx.login() // 重新登录
    }
})
```

### 小程序跳转

##### wx.navigateToMiniProgram(Object object) 

打开另外一个小程序

- appId 要打开的小程序 appId
- path  打开的页面路径, 空表示打开首页
- extraData 需要传递个目标小程序的数据, 目标小程序可以再 App.onLaunch, App.onShow 中获取到该数据
- envVersion 默认值 release(正式版) 要打开的小程序版本, 仅在当前小程序为开发版或测试版时该参数有效, 如果当前小程序时是正版, 则打开的小程序必须是正版
- success 成功回调
- ...

使用限制: 需要用户触发跳转, 需要用户确认跳转, 每个小程序可跳转的其他小程序数量限制为不超过10 个

```js
wx.navigateToMiniProgram({
    appId: '',
    path: 'page/index/index?id=123',
    extraData: {
        foo: 'bar'
    },
    envVersion: 'develop',
    success(res) {
        // 打开成功
    }
})
```

##### wx.navigateBackMiniProgram(Object object)

返回到上一个小程序, 只有在当前小程序是被其他小程序打开时可以调用成功

- extraData 需要返回给上一个小程序的数据, 可在 App.onShow 中获取到这份数据
- success 成功回调
- ...

### 账号信息

##### wx.getAccountInfoSync()

获取当前账号信息

返回值 Object

- miniProgress 小程序账号信息
  - appId 小程序 appId
- plugin 插件账号信息

  - appId 插件 id
  - version 插件版本号

### 用户信息

##### wx.getUserInfo(Object object)

调用前需要 用户授权 scope.userInfo

获取用户信息

- withCredentials 是否带上登录信息, 默认 false, 如果为true, 要求此前有吊用过 wx.login 且登录状态未过期, 此时返回的数据会包含 encryptedData, iv等敏感信息; 为 false时, 不要求有登录登录状态

- lang 显示用户信息的语言 默认 en

  - en / zh_CN / zh_TW

- success 成功回调

  - userInfo 用户信息对象, 不包含 openId 等敏感信息
  - rawData 不包含敏感信息的恩怨史数据字符串, 用于计算签名
  - signature 使用 sha1 (rawData+sessionkey) 得到字符串, 用于校验用户信息
  - encryptedData 包括敏感数据在内的完整用户信息的加密数据
  - iv 加密算法的初始向量

  接口调整说明: 在用户未授权的情况下调用此接口, 将不再出现授权弹窗, 会直接进入 fail 回调, 在用户已授权的情况下调用此接口, 可成功获取用户信息.

示例:

```js
//	必须在用户已授权的情况下调用
wx.getUserInfo({
  success(res) {
    const userInfo = res.userInfo
    const nickName = userInfo.nickName
    const avatarUrl = userInfo.avatarUrl
    const gender = userInfo.gender // 性别 0：未知、1：男、2：女
    const province = userInfo.province
    const city = userInfo.city
    const country = userInfo.country
  }
})
```

encryptedData 解密后为以下json结构

```json
{
  "openId": "OPENID",
  "nickName": "NICKNAME",
  "gender": GENDER,
  "city": "CITY",
  "province": "PROVINCE",
  "country": "COUNTRY",
  "avatarUrl": "AVATARURL",
  "unionId": "UNIONID",
  "watermark": {
    "appid": "APPID",
    "timestamp": TIMESTAMP
  }
}
```

示例代码: 如果只是展示用户头像昵称, 可以使用 <open-data /> 组件

```html
<!-- 如果只是展示用户头像和昵称, 可以使用 <open-data /> 组件 -->
<open-data type="userAvatarUrl"></open-data>
<open-data type="userNickName"></open-data>

<!-- 需要使用 button 来授权登录 -->
<button 
        wx:if="{{canIUse}}"
        open-type="getUserInfo"
        bindgetuserinfo="bindGetUserInfo"
        >授权登录</button>
<wiew wx:else>请升级微信版本</wiew>
```

```js
Page({
    data: {
        canIUse: wx.canIUse('button.open-type.getUserInfo')
    },
    onLoad() {
        // 查看是否授权
        wx.getSetting({
            success(res) {
                if (res.authSetting['scope.userInfo']) {
                    // 已经授权，可以直接调用 getUserInfo 获取头像昵称
                    wx.getUserInfo({
                        success(res) {
                            console.log(res.userInfo)
                        }
                    })
                }
            }
        })
    },
    bindGetUserInfo(e) {
        console.log(e.detail.userInfo)
    }
})
```

##### getPaidUnionId 

本接口应在后端服务器调用

用户支付完成后, 获取该用户的 UnionId, 无需用户验证

注意: 调用前需要用户完成支付, 且在支付后的五分钟内有效

请求地址: `GET https://api.weixin.qq.com/wxa/getpaidunionid?access_token=ACCESS_TOKEN&openid=OPENID`

请求参数: 

- access_token 接口调用凭证
- openid 支付用户唯一标识
- transaction_id 微信支付订单号
- mch_id 微信支付分配的珊瑚好, 和商户订单号配合使用
- out_trade_no 微信支付商户订单号, 和商户号配合使用

###### 返回值 Object

返回的 JSON 数据包

unionid 用户唯一标识, 调用成功后返回

errcode 错误码

ermsg 错误信息 

​	-1 系统繁忙 0 请求成功 40003 openid错误 89002 没有绑定开发平台账号 89300 订单无效

使用说明: 

 1. 微信支付订单号 (transaction_id)

    ```
    https://api.weixin.qq.com/wxa/getpaidunionid?access_token=ACCESS_TOKEN&openid=OPENID&transaction_id=TRANSACTION_ID
    ```

	2. 微信支付商户订单号和微信支付商户号(out_trade_no 及 mch_id)

    ```
    https://api.weixin.qq.com/wxa/getpaidunionid?access_token=ACCESS_TOKEN&openid=OPENID&mch_id=MCH_ID&out_trade_no=OUT_TRADE_NO
    ```

##### UserInfo 

用户信息

属性 

​	string nickName 用户昵称

 	string avatarUrl 用户头像图片的 URL, URL 最后一个数值代表正方形头像大小, 用户没有头像时,此项为空, 如果用户更换头像, 原有头像 URL 将失效

​	number gender 用户性别  0未知 1男性 2女性

​	string country 用户所在国家

​	string province 用户所在省份

​	string city 用户所在城市

​	string language 显示国家省份城市所用的语言

### 接口调用凭证

##### getAccessToken

本接口应在后端服务器调用

获取小程序全局唯一后台接口调用凭据 (access_token). 调用各后台接口都需要使用 access_token, 开发者需要进行妥善保存. 请求地址方式如下

```
GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET
```

请求参数说明

​	grant_type 填写 client_credential

​	appid 小程序唯一凭证, 即 AppID 需要已成为开发者, 且账号没有异常状态

​	secret 小程序唯一凭证密匙, 及 AppSecret, 获取方式同 appid

###### 返回值 JSON 数据包

​	access_token 获取到的凭证

​	expire_in 凭证有效期, 单位 s, 目前是 两小时以内

​	errcode 错误码 合法值 

​		-1 系统繁忙  

​		0 请求成功 

​		40001 AppSecret错误或者 AppSecret 不属于该小程序

​		40002 确保 grant_type 字段值为 client_credential

​		40013 不合法的 AppID

​	errmsg 错误信息

返回数据示例

正确 : {"access_token": "ACCESS_TOKEN", "expires_in": 7200}

错误: {"errcode": 40013, "errmsg": "invalid appid"}

###### access_token 的存储和更新

- access_token 的存储至少需要保留 512 个字符空间
- access_token 的有效期目前为 2小时, 需要定时刷新, 重复获取将导致上次获取 access_token 失效
- 建议开发者使用中控服务器统一获取和刷新 access_token, 其它业务逻辑服务器所使用的 access_token 均来自该中控服务器.
- access_token 的有效期通过返回值 expire_in 来传达, 中控服务器需要依据该有效期提前刷新, 建议提前5分钟
- access_token 有效期可能在未来会有调整, 所以中控服务器不仅要内部主动定时刷新, 还需要提供被刷新 access_token 的接口, 这样便于业务服务器在调用 API 调用数值 access_token 已超时情况下, 触发 access_token 的刷新流程.

### 数据上报

##### wx.reportMonitor(string name, number value)

自定义业务数据监控上报接口

- name 监控ID, 在 [小程序管理后台] 新建数据指标后获得
- value 上报数值, 经处理后会在 [小程序管理后台] 上展示每分钟的上报总量

使用说明: 使用前, 需要在 [小程序管理后台-运维中心-性能检测-业务数据监控] 中新建监控事件, 配置监控描述与告警类型, 每一个监控事件对应唯一的监控 ID, 开发者最多可以创建 128 个监控事件

示例: `wx.reportMonitor('1', 1)`

### 数据分析

#### wx.reportAnalyTics(string eventName, Object data)

自定义分析数据上报接口. 使用前, 需要在小程序管理吼他自定义分析中新建事件, 配置好事件名与字段

- eventName 事件名
- data 上报的自定义数据
  - key 配置中的字段名
  - value 上报的数据

示例代码

```js
wx.reportAnalytics('purchase', {
    price: 120,
    color: 'red'
})
```

#### 访问留存

##### getAnalysisDailyRetain

本接口应在后端服务器调用

获取用户访问小程序日留存

请求地址: 

```
POST https://api.weixin.qq.com/datacube/getweanalysisappiddailyretaininfo?access_token=ACCESS_TOKEN
```

请求参数

​	access_token 接口调用凭证

​	begin_date 开始日期. 格式yyyymmdd

​	end_date 结束日期, 限定查询1条数据, 允许设置的最大值为昨天. 格式 yyyymmdd

###### 返回值 Object

​	ref_date 日期

​	visit_uv_new 新增用户留存

​		key 标识 0开始, 表示当天, 1表示1天后, 以此类推

​		value key对应日期的新增用户数/活跃用户数

​	visit_uv 活跃用户留存. 值同上

请求数据示例		

```json
{
    "begin_date": "20170313",
    "end_date": "20170313"
}
```

返回数据示例

```json
{
    "ref_date": "20170313",
    "visit_uv_new": [
        {
            "key": 0,
            "value": 5464
        }
    ],
    "visit_uv": [
        {
            "key": 0,
            "value": 55500
        }
    ]
}
```

##### getAnalysisMonthlyRetain

本接口应在后端服务器调用

获取用户访问小程序月留存

请求地址

```
POST https://api.weixin.qq.com/datacube/getweanalysisappidmonthlyretaininfo?access_token=ACCESS_TOKEN
```

参数及返回值同上一致

##### getAnalysisWeeklyRetain

本接口应在后端服务器调用

获得用户访问小程序周留存

请求地址

```
POST https://api.weixin.qq.com/datacube/getweanalysisappidweeklyretaininfo?access_token=ACCESS_TOKEN
```

参数返回值与上一致

#### getAnalysisDailySummary

本接口应在后端服务器调用

获取用户访问小程序服务器调用

请求地址

```
POST https://api.weixin.qq.com/datacube/getweanalysisappiddailysummarytrend?access_token=ACCESS_TOKEN
```

请求参数与上一致

###### 返回值 Object 

- ref_date 日期格式 yyyymmdd
- list  数据列表
  - index 分布类型
    - access_source_session_cnt 访问来源分布
    - access_staytime_info 访问时长分布
    - access_depth_info  访问深度的分布
  - item_list 分布数据列表
    - key 场景 id
    - value 该场景 id 访问 pv
    - access_source_visit_uv 该场景范围 uv

#### getAnalysisVisitPagefa

本接口应在后端服务器调用

访问页面, 目前只提供按 page_visit_pv 排序的  top200

```
POST https://api.weixin.qq.com/datacube/getweanalysisappidvisitpage?access_token=ACCESS_TOKEN
```

### 支付

##### wx.requestPayment(Object object)

发起微信支付 [微信支付接口文档](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=1_1)

- timeStamp 当前时间戳

- nonceStr 随机字符串, 长度32字符以下

- package 统一下单接口返回的 prepay_id 参数值, 提交格式如: prepay_id = ***
- signType 签名算法, 默认 MD5
  - MD5 / HMAC-SHA256
- paySign 前面, 具体前面方案键 小程序接口文档
- success 成功回调
- ...

示例代码

```js
wx.requestPayment({
    timeStamp: '',
    nonceStr: '',
    package: '',
    signType: 'MD5',
    paySign: '',
    success(res) { },
    fail(res) { }
})
```

### 授权

##### wx.authorize(Object object)

提前当用户发起授权请求. 调用后会立即弹窗询问用户是否同意授权小程序使用某项功能或获取用户某些数据, 但不会实际调用对应接口, 如果用户之前以及同意授权, 则不出现弹窗, 直接返回成功 [用户授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)

- scope  需要获取权限的 scope [scope列表](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)
- success 成功回调
- ...

注意：wx.authorize({scope: "scope.userInfo"})，无法弹出授权窗口，请使用 <button open-type="getUserInfo"/>

示例代码

```js
// 可以通过 wx.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope
wx.getSetting({
    success(res) {
        if (!res.authSetting['scope.record']) {
            wx.authorize({
                scope: 'scope.record',
                success() {
                    // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问
                    wx.startRecord()
                }
            })
        }
    }
})
```

### 设置

##### wx.openSetting(Objedct object)

调起客户端小程序设置界面, 返回用户设置的操作结果. 设置界面只会出现小程序已经向用户请求过的权限

注意: 2.3.0 版本开始, 用户发生点击行为后, 才可以跳转打开设置页, 管理授权信息

- success 成功回调
  - authSetting 用户授权结果
- ...

```js
wx.openSetting({
    success(res) {
        console.log(res.authSetting)
        // res.authSetting = {
        //   "scope.userInfo": true,
        //   "scope.userLocation": true
        // }
    }
})
```

##### wx.getSetting(Object object)

获取用户的当前设置, 返回值中只会出现小程序向用户请求过的权限

- success 成功回调
  - res.authSetting 用户授权结果
- ...

```js
wx.getSetting({
    success(res) {
        console.log(res.authSetting)
        // res.authSetting = {
        //   "scope.userInfo": true,
        //   "scope.userLocation": true
        // }
    }
})
```

##### AuthSetting

用户授权设置信息

- scope.userInfo 是否授权用户信息, 对应接口 wx.getUserInfo
- scope.userLocation 是否授权地理位置, 对应接口 wx.getLocation, wx.chooseLoaction
- scope.address 是否授权通讯地址, 对应接口 wx.chooseAddress
- scope.invoiceTitle 是否授权获取发票, 对应接口 wx.chooseInvoice
- scope.werun 是否授权微信运动步数, 对应接口 wx.getWeRunData
- scope.record 是否授权录音功能, 对应接口 wx.startRecord
- scope.writePhotosAlbum 是否授权保存到相册  wx.saveImageToPhotosAlbum, wx.saveVideoToPhotosAlbum
- scope.camera 是否授权摄像头, 对应 <camera /> 组件

### 客服消息

##### customerTyping 

本接口应在后端服务器调用

下发客服当前输入状态给用户

请求地址及方式

```
POST https://api.weixin.qq.com/cgi-bin/message/custom/typing?access_token=ACCESS_TOKEN
```

参数

- access_token 接口调用凭证
- touser 用户的 OpenID
- command命令
  - Typing 对用户发"正在输入"状态
  - CancelTyping 取消度用户的 "正在输入"状态

返回的 JSON 数据包

- errcode 错误码
  - 45072 command 字段取值不对
  - 45080 下发输入状态, 需要之前30s内核用户有过消息交互
  - 45081 已经在输入状态, 补课重复下发
- errmsg 错误信息

请求数据示例

```
{
	"touser": "OPENID",
	"command": "Typing"
}
```

##### getTempMedia 

获取客服消息内的临时素材, 

```
GET https://api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&media_id=MEDIA_ID
```

##### sendCustomerMessage

发送客服消息给用户

```
POST https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=ACCESS_TOKEN
```

##### uploadTempMedia

把媒体文件上传到微信服务器.目前仅支持图片, 用于发送客服消息或被动回复用户消息

### 模板消息

### 统一服务消息

### 动态消息

### 插件管理

### 收货地址

##### wx.chooseAddress

调用前需要用户授权

获取用户收货地址, 调起用户编辑收货地址原生界面, 并在编辑完成后返回用户选择的地址.

- success 成功回调
  - 回调参数 res 下的属性
    - userName 收货人姓名
    - postalCode 右边
    - provinceName 国标收货地址第一级地址
    - cityName 
    - countyName
    - detailInfo 详细收货地址信息
    - nationalCode 收货地址国家码
    - telNumber 收货人手机号码
    - errMsg 错误信息
- ...

示例

```js
wx.chooseAddress({
    success(res) {
        console.log(res.userName)
        console.log(res.postalCode)
        console.log(res.provinceName)
        console.log(res.cityName)
        console.log(res.countyName)
        console.log(res.detailInfo)
        console.log(res.nationalCode)
        console.log(res.telNumber)
    }
})
```

### 卡卷

### 发票

##### wx.chooseInvoiceTitle(Object object)

调用之前需要 用户授权 scope.invoiceTitle

选择用户的发票抬头

- success 成功回调
  - 返回参数 res
    - type 抬头类型
      - 0 单位
      - 1 个人
    - title 太透名称
    - taxNumber 抬头税号
    - companyAddress 单位地址
    - telephone 手机号码
    - bankName银行名称
    - bankAccount 银行账号
    - errMsg 错误信息
- ...

##### wx.chooseInvoice(Object object)

调用钱需要用户授权 scope.invoice

选择用户已有的发票

- success 成功回调
  - res.invoiceInfo 用户选中的发票列表
    - cardId 所选发票卡卷的 cardId
    - encryptCode 所选发票卡卷的加密 code 
    - publisherAppId 发票方的 appId
- ....

### 附件的小程序

##### addNearbyPoi 

接口后端服务器调用

添加地点

请求地址&方式&参数说明

```
POST https://api.weixin.qq.com/wxa/addnearbypoi?access_token=ACCESS_TOKEN
```

- 请求参数
  - access_token 接口调用凭据
  - related_name 经营资质主体
  - related_credential 经营资质证件号
  - related_address 经营资质地址
  - related_proof_material 相关证明材料

###### 返回值 JSON 数据包

- errmsg 错误信息
- errcode 错误码
- data 返回数据 

### 二维码

### 内容安全

### 生物认证

### 微信运动

## 设备

### iBeacon

##### wx.onBeaconServiceChange(callback)

监听 iBeacon 服务状态变化事件

回调返回值res

- available 服务目前是否可用
- discovering 目前是否处于搜索状态

##### wx.onBeaconUpdate(callback)

监听 iBeacon 设备更新事件

返回值 res.beacons 当前搜索到的所有 iBeacon 设备

##### wx.getBeacons(Object object)

获取所有已搜索到的 iBeacon 设备

- success 成功回调
  - res.beacons 设备列表
- ...

##### wx.stopBeaconDiscovery(Object object)

停止搜索附件的设备

- success 成功回调
- ...

错误信息

| 错误码 | 错误信息                      | 说明             |
| ------ | ----------------------------- | ---------------- |
| 0      | ok                            | 正常             |
| 11000  | unsupport                     | 系统或设备不支持 |
| 11001  | bluetooth service unavailable | 蓝牙服务不可用   |
| 11002  | location service unavailable  | 位置服务不可用   |
| 11003  | already start                 | 已经开始搜索     |

##### wx.startBeaconDiscovery(Object object) 

开始搜索附件的 iBeacon 设备

- uuids 蓝牙设备广播 uuid 列表
- success 成功回调
- ...

##### IBeaconInfo 

属性

-  uuid 设备广播的 uuid
- major 设备的id
- minor 设备的 次id
- proximity 设备距离的枚举值
- accuracy 设备的距离
- rssi 设备的信号强度

### Wi-Fi

##### wx.stopWifi(Object object)

关闭 Wi-Fi 模块

- success 成功回调 
- ...

错误

代码示例

```js
wx.stopWifi({
    success(res) {
        console.log(res.errMsg)
    }
})
```

##### wx.startWifi(Object object) 

初始化 Wi-Fi 模块

- success 成功回调
- ...

##### wx.setWifiList(Object object)

设置 wifiList 中 AP 的相关信息

- success

### 加速计

### 电量

##### wx.getBatteryInfo(Object object)

获取设备电量

- success 成功回调
  - 参数res.level 设备电量, 1-100
  - isCharging 是否正在充电

### 剪贴板

### 罗盘

### 联系人

##### addPhoneContact(Object object)

添加手机联系人

- firstName 联系人名字
- photoFilePath 头像本地路径
- nickname 昵称
- lastname 姓氏
- middleName 中间名
- remark 备注
- mobilePhoneNumber 手机号
- weChatNumber 微信号
- addressCountry 联系地址国家
- success 成功回调
- ...

### 陀螺仪

### 方向

### 网络

##### wx.onNetworkStatusChange(callback)

监听网络状况变化事件

参数 res 属性

- isConnected 当前是否有网络连接
- networkType 网络类型
  - wifi
  - 2g/3g/4g
  - unknown Android 下不常见的网络类型
  - none 无网络

##### wx.getNetworkType(Object object)

获取网络类型

- success 成功回调
  - res.networkType 网络类型
- ...

```js
wx.getNetworkType({
    success(res) {
		const networkType = res.networkType
	}
})
```

### 电话

##### wx.makePhoneCall(Object object)

拨打电话

- phoneNumber 需要拨打的电话号码
- success 成功回调

```js
wx.makePhoneCall({
    phoneNumber: '18958849752xxx'
})
```

### 扫码

##### wx.scanCode(Object object) 

调起客户端扫码界面进行扫码

- onlyFromCamera 是否只能从相机扫码, 不允许从相册选择图片
- scanType ['barCode', 'qrCode'] 扫码类型
- success 成功回调
  - result 所扫码的内容
  - scanType 所扫码的类型
  - charSet 所扫码的字符集
  - path 所扫的吗为当前小程序的合法二维码时, 会返回此字段, 内容是二维码携带的 path
  - rawData 原始数据, base64 编码

示例

```js
// 允许从相机和相册扫码
wx.scanCode({
    success(res) {
        console.log(res)
    }
})

// 只允许从相机扫码
wx.scanCode({
    onlyFromCamera: true,
    success(res) {
        console.log(res)
    }
})
```



### 震动

##### wx.vibrateLong(Object object) 

使手机发生较长事件的震动 400ms

- success 成功回调
- ...

##### wx.vibrateShort(Object object)

使手机发生较短事件震动(15ms) iphone7/7Plus以上及Android机型生效

- success	成功接口

### 性能

##### wx.onMemoryWarning(callback)

监听内存不足警告事件

当 IOS/Android 向小程序进程发出内存警告时, 触发该事件. 触发该事件不以为小程序被杀, 大部分情况下仅仅是警告, 开发者可以在收到通知后回收一些不必要资源避免进一步加剧内存紧张

```js
wx.onMemoryWarning(function () {
    console.log('onMemoryWarningReceive')
})
```

### 低功耗蓝牙

### 蓝牙

### NFC

### 屏幕

##### wx.getScreenBrightness(Object object)

获取屏幕亮度

success 成功回调

参数  res.value 屏幕亮度

##### wx.setScreenBrightness(Object object)

设置屏幕亮度

- value 屏幕亮度值 0~1, 0 最暗, 1最亮
- success 接口调用成功的回调
- ...

##### wx.setKeepScreenOn(Object object)

设置是否保持常亮状态. 仅在小程序生效

- keepScreenOn 是否保持屏幕常亮, 必填


- success 成功回调

##### wx.onUserCaptureScreen(callback)

监听用户主动截图事件. 用户使用系统按键截屏时触发

## Worker

### wx.createWorker(scriptPath)

创建一个 Worker 线程. 目前限制最多只能创建一个 Worker

- string scriptPath worker 入口文件的绝对路径

###### 返回值 Worker

-  Worker.postMessage(Object message) 向主线程/Worker 线程发送的消息
  -  参数 Object message 需要发送的消息, 必须是一个可序列化的 JavaScript key-value形式对象

示例代码

```js
//	worker 线程中
worker.postMessage({
    msg:'hello 线程'
})
//	主线程中
const worker = wx.createWorker('workers/request/index.js')
worker.postMessage({
    msg: 'hello from main'
})
```

##### Worker.onMessage(callback)

监听主线程向当前线程发送的消息的事件

回调函数参数 res.message 主线程向当前线程发送的消息

##### Worker.terminate() 

结束当前 Worker 线程, 仅限在 worker 对象上调用

## 第三方平台

##### wx.getExtConfig(Object object)

获取第三方平台自定义的数据字段

##### wx,getExtConfigSync(Object object)

- success 调用成功回调
  - extConfig 第三方平台自定义的数据
- ...

本接口暂时无法通过 wx.canIUse 判断是否兼容, 开发者需要自行判断 wx.getExtConfig 是否存在来兼容

示例代码

```js
if (wx.getExtConfig) {
    wx.getExtConfig({
        success(res) {
            console.log(res.extConfig)
        }
    })
}
```

## WXML

### wx.createSelectorQuery()

返回一个 SelectorQuery 对象实例

```js
const query = wx.createSelectorQuery()
query.select('#text').boundingClientRect()
query.selectViewport().scrollOffset()
query.exec(function (res) {
    res[0].top // #the-id节点的上边界坐标
    res[1].scrollTop // 显示区域的竖直滚动位置
    console.log(res)
})
```

### wx.createIntersectionObserver(this, options)

创建并返回一个 IntersectionObserver 对象实例. 在自定义组件中, 可以使用 this.createIntersectionObserver([options]) 来代替

- this 自定义组件实例
- options 选项
  - thresholds 一个数值数组, 包含所有阈值
  - initialRatio 初始化相交比例, 如果调用时检测到相交比例与这个值不相等且达到阈值,则会触发一次监听器的回调函数
  - observeAll 是否同时观测多个目标节点

###### 返回值 IntersectionObserver

- IntersectionObserver.relativeTo(selector, margins) 

  - selector 选择器
  - margins 用来扩展/收缩参数节点在布局区域的边界
    - left 节点布局区域的左边界
    - right/top/bottom ...

- IntersectionObserver.relativeToViewport(margins)

  指定页面显示区域作为参照区域之一

  示例代码: 如果目标节点(.target-class)进入显示区域以下 100 px 时, 就会触发回调

  ```javascript
  Page({
      onLoad() {
          wx.createIntersectionObserver().relativeToViewport({bottom: 100}).observe('.target-class', (res) => {
              res.intersectionRatio // 相交区域占目标节点的布局区域的比例
              res.intersectionRect // 相交区域
              res.intersectionRect.left // 相交区域的左边界坐标
              res.intersectionRect.top // 相交区域的上边界坐标
              res.intersectionRect.width // 相交区域的宽度
              res.intersectionRect.height // 相交区域的高度
          })
      }
  })
  ```

- IntersectionObserver.abserve(targetSelector, callback)

   指定目标节点并开始监听相交变化情况

  - targetSelector 选择器

  - callback 监听相交状态变化的回调函数

    - res.intersectionRatio 相交比例
    - res.intersectionRect 相交区域的边界

    - res.boundingClientRect 目标边界
    - relativeRect 参照区域的边界

- IntersectionObserver.disconnect()

  停止监听, 回调函数不再触发

### NodesRef

用于获取 WXML 节点信息的对象

##### NodesRef.fields(fields)

获取节点的相关信息, 需要获取的字段在 fields 中指定. 返回值是 nodesRef 对应的 selectorQuery

- id 是否返回节点 id
- dataset 是否返回节点 dataset
- rect 是否返回节点布局位置
- size 是否返回节点尺寸
- scrollOffset 是否返回节点的 scrollTop/left 节点必须是 scroll-view/viewport
- properties 指定属性名列表, 返回节点对应属性名的当前属性值
- computedStyle 指定样式名列表, 返回节点对应样式名的当前值
- context 是否返回节点对应的 Context 对象

注意: computedStyle 的优先级高于 size, 同时存在 

```js
Page({
    getFields() {
        wx.createSelectorQuery().select('#the-id').fields({
            dataset: true,
            size: true,
            scrollOffset: true,
            properties: ['scrollX', 'scrollY'],
            computedStyle: ['margin', 'backgroundColor'],
            context: true,
        }, function (res) {
            res.dataset // 节点的dataset
            res.width // 节点的宽度
            res.height // 节点的高度
            res.scrollLeft // 节点的水平滚动位置
            res.scrollTop // 节点的竖直滚动位置
            res.scrollX // 节点 scroll-x 属性的当前值
            res.scrollY // 节点 scroll-y 属性的当前值
            // 此处返回指定要返回的样式名
            res.margin
            res.backgroundColor
            res.context // 节点对应的 Context 对象
        }).exec()
    }
})
```

##### SelectorQuery NodesRef.boundingClientRect(NodesRef.boundingClientRectCallback)

添加节点的布局位置的查询请求, 相对于显示位置, 以像素为单位, 功能类似于 DOM 的 getBoundingClientRect. 返回 NodesRef 对应的 SelectorQuery

- 回调函数, 在执行 SelectorQuery.exec 方法后, 节点信息会在 callback 中返回
  - id 节点ID
  - dataset 节点的 dataset
  - l/r/b/t 边界坐标
  - w/h 节点的宽高

###### 返回值 SelectorQuery

```js
Page({
    getRect() {
        wx.createSelectorQuery().select('#the-id').boundingClientRect(function (rect) {
            rect.id // 节点的ID
            rect.dataset // 节点的dataset
            rect.left // 节点的左边界坐标
            rect.right // 节点的右边界坐标
            rect.top // 节点的上边界坐标
            rect.bottom // 节点的下边界坐标
            rect.width // 节点的宽度
            rect.height // 节点的高度
        }).exec()
    },
    getAllRects() {
        wx.createSelectorQuery().selectAll('.a-class').boundingClientRect(function (rects) {
            rects.forEach(function (rect) {
                rect.id // 节点的ID
                rect.dataset // 节点的dataset
                rect.left // 节点的左边界坐标
                rect.right // 节点的右边界坐标
                rect.top // 节点的上边界坐标
                rect.bottom // 节点的下边界坐标
                rect.width // 节点的宽度
                rect.height // 节点的高度
            })
        }).exec()
    }
})
```



##### SelectorQuery NodesRef.scrollOffset(NodesRef.scrollOffsetCallback)

添加节点的滚动位置查询请求, 以像素为单位, 节点必须是 scroll-view 或者 viewport 返回 NodesRef 对应的 SelectorQuery

- 回调函数, 在执行 SelectorQuery.exec 方法后, 节点信息会在 callback 中返回
  - 回调返回值 res
    - id 节点的ID
    - dataset 节点的 dataset
    - scrollLeft/scrollTop 节点水平/竖直 滚动位置

###### 返回值 SelectorQuery

```js
Page({
    getScrollOffset() {
        wx.createSelectorQuery().selectViewport().scrollOffset(function (res) {
            res.id // 节点的ID
            res.dataset // 节点的dataset
            res.scrollLeft // 节点的水平滚动位置
            res.scrollTop // 节点的竖直滚动位置
        }).exec()
    }
})
```

##### SelectorQuery NodesRef.context(NodesRef.contextCallback)

添加节点的 Context 对象查询请求. 支持 VideoContext, CanvasContext, LivePlayerContext 和 MapContext 的获取

- 回调函数在执行 SelectorQuery.exec 方法后, 返回节点信息
  - 回调参数 res
    - context  节点对应的 Context 对象 

###### 返回值 SelectorQuery

```js
Page({
    getContext() {
        wx.createSelectorQuery().select('.the-video-class').context(function (res) {
            console.log(res.context) // 节点对应的 Context 对象。如：选中的节点是 <video> 组件，那么此处即返回 VideoContext 对象
        }).exec()
    }
})
```

### SelectorQuery

查询节点信息的对象

方法

##### SelectorQuery.in(Component component)

将选择器的选取范围修改为自定义组件 component 内. (初始选择器竞选去页面范围节点)

##### SelectorQuery.select(selector)

在当前页面下选择第一个匹配选择器 selector 的节点, 返回 NodesRef 对象实例, 用于获取节点信息

##### SelectorQuery.selectAll(selector) 

在当前页面下选取匹配选择的器 selector 的所有节点

##### SelectorQuery.selectViewport()

选择显示区域, 可以用于获取显示区域的尺寸, 滚动位置等信息

##### SelectorQuery.exec(callback)

执行所有的请求, 请求结果按请求次序构成数组, 在callback 的第一个参数中返回

# 组件*

## 视图容器

### view

视图容器

- hover-class    指定按下的样式类, 当hover-class="none" 时, 没有点击效果
- hover-stop-propagation 指定是否阻止本节点的祖先节点出现点击状态(冒泡)
- hover-start-time  按住多久后出现点击态, ms
- hover-stay-time 松开后点击态保留时长

### scroll-view 

可滚动视图区域

- scroll-x  允许横向滚动
- scroll-y  允许纵向滚动
- upper-threshold  距离顶部/左边多少距离触发 scrolltoupper 事件
- lower-threshold 距离底部/右边多少距离触发 scrolltolower 事件
- scroll-top 设置竖向滚动条位置
- scroll-left 设置横向滚动条位置
- scroll-into-view 值为某一子元素的 id(不能以数字开头), 设置哪个方向滚动. 则在哪个方向滚动到该元素
- scroll-with-animation  设置滚动条位置时使用动画过渡
- enable-back-to-top IOS点击顶部状态栏, 安卓双击标题栏时, 滚动条返回顶部, 只支持竖向
- bindscrollupper 滚动到顶部/左边, 会触发 scrolltoupper 事件
- bindscrolltolower 滚动到底部/右边, 会触发 scrolltolower 事件
- bindscroll 滚动时触发

### swiper 

滑块视图容器

- indicator-dots  是否显示面板指示点
- indicator-color  指示点颜色
- indicator-active-color 指示点选中颜色
- autoplay 是否自动切换
- current 当前所在滑块 index
- current-item-id 当前所在滑块的 item-id, 不能与 current 同时指定
- interval 自动切换时间间隔
- duration 滑动动画时长
- circular 是否采用衔接滑动(循环)
- vertical 滑动方向是否为纵向
- previous-margin 前边距. 可用于露出前一项的一小部分, 接收 px 和 rpx
- next-margin 后边距, 可用于露出后一项的一小部分
- display-multiple-items 同时显示的滑块数量
- skip-hidden-item-layout 是否跳过未显示的滑块布局, true 则可优化复杂情况下的滑动性能
- bindchange current 改变时触发函数
- bindtransition    swiper-item 位置发生变化时会触发 transition 事件
- bindanimationfinish    动画结束时, 触发animationfinish 事件

### movable-view

可移动的视图容器, 在页面中可以拖拽滑动

- direction  移动方向, all/vertical/horizontal/none
- inertia 是否带有惯性
- out-of-bounds 超出可视区后是否还可以移动
- x 定义x轴方向的偏移量, 如果x轴不在可移动范围内, 会自动移动到可移动方
- y 定义 y 轴方向的偏移量, 同上
- damping 阻尼系数, 用于控制 x/y 改变时的动画和过界动画回弹的动画, 值越大移动地越快
- friction 摩擦系数, 用于控制惯性滑动的动画, 值越大摩擦力越大, 滑块越快停止, >0
- disabled 是否禁用
- scale 是否支持双指缩放, 默认缩放瘦小生效区域是在移动视图容器内
- scale-min 定义缩放倍数最小值
- scale-max 定义缩放倍数最大值
- scale-value 定义缩放倍数 0.5-10
- animation 是否使用动画
- bindchange 拖动过程中触发的事件
- bindscale 缩放过程中触发的事件

两个特殊事件

- htouchmove 初次手指触摸后移动为横向的移动, 如果 catach 此事件, 以为这 touchmove 也被 catch
- vtouchmove 初次手指触摸后移动为纵向的移动

**注意** movable-view 必须在 <movable-area /> 组件中, 且必须是直接子节点

#### movable-area

movable-view 的可移动区域

- scale-area 当里面的 movable-view 设置为支持双指缩放时, 设置此值可将缩放手势生效区域修改为整个 movable-area

movable-area 必须设置 width 和 height属性

当movable-view 小于 movable-area 时, movable-view 的移动范围是在 movable-area 内

当movable-view 大于 movable-area时, movable-view 的移动范围必须包含 movable-area (x, y 方向分开考虑)

### cover-view

覆盖在原生组件上的文本视图

覆盖在原生组件之上的文本视图, 可覆盖的原生组件包括 map/ video/ canvas/ camera/ live-player /live-pusher 只支持嵌套 cover-view 和 cover-image, 可以在 cover-view 上使用 button

- scroll-top 设置顶部滚动偏移量, 在设置了 scroll-y: scroll成为滚动元素之后生效

### cover-image

覆盖在原生组件之上的图片视图, 可覆盖的原生组件同 cover-view, 支持嵌套在 cover-view 中

- src 图片路径, 暂不支持 base64
- bindload 图片加载成功时触发
- binderror 图片加载失败时触发

## 基础内容

### icon

图标

- type  icon的类型, 有效值: success/ success_no_circle/ info/ warn/ waiting / cancel /download/ search / clear
- size  icon的大小, 单位px
- color icon颜色, 同 css 的color

```html
<icon type="success" size="56rpx" color="#368" />
```

### text

文本

- selectable  文本是否可选, 默认 false
- space 显示连续空格, 默认 false
  - ensp 中文字符空格一半大小
  - emsp 中文字符空格大小 
  - nbsp 根据字体设置空格大小
- decode 是否解码, 默认 false

decode 可以解析的有 `&nbsp;` `&lt;` `&gt;` `&amp;` `&apos;`  `&emsp;` `&ensp;`

<text> 组件内只支持 \<text> 嵌套

除了文本能借你到哪以外的其他节点都无法长按选中

### rich-text

富文本

### progress

进度条

- percent 百分比 0 ~ 100
- show-info 进度条右侧显示百分比
- border-radius 进度条圆角大小
- font-size  文字大小
- stroke-width 进度条宽度
- color 已选择进度条颜色(推荐使用 activeColor)
- activeColor 已选择进度条颜色
- backgroundColor 未选择进度条颜色
- active 动画从左万往右的动画
- active-mode backwards 动画从头开始  forwards 动画从上次结束点继续
- bindactiveend 动画完毕事件

## 表单组件

### button

按钮

- size	按钮大小, 默认default
  - defalut 默认大小
  - mini 小尺寸
- type 按钮样式类型
  - default 白色
  - primary 绿色
  - warn 红色
- plain 按钮是否镂空, 背景色透明
- disabled 是否禁用
- loading 名称齐纳是否带 loading 图标
- form-type 用于 <form>组件, 点击分别触发 <form> 组件的 submit/reset 事件
  - submit 提交表单
  - reset 重置表单
- open-type 微信开放能力
  - contact 打开客服会话, 如果用户在会话中点击消息卡片返回小程序, 可以从 bindcontact 回调中获得具体信息
  - share 触发用户转发
  - getUserInfo 获取用户信息, 可以从bindgetuserinfo 回调中获得用户信息
  - getPhoneNumber 获取用户手机号, 可以从bindgetphonenumber回调中获得用户信息
  - launchApp 打开 APP, 可以通过 app-parameter 属性设定向 APP 传的参数
  - openSetting 发开授权设置页
  - feedback 打开 "意见反馈" 页面, 用户可以提交反馈内容并伤处你日志, 开发者可以登录小程序管理后台进入左侧菜单客服反馈页面获取到反馈内容 
- hover-class 指定按钮按下去的样式类, 当为none时没有点击态效果
- hover-stop-propagation 指定是否阻止本节点的祖先节点出现点击态
- hover-start-time 按住后多久出现点击态
- hover-stay-time 手指松开后点击态保留时间
- lang 指定返回用户信息的语言, zh_CN 简体中文 (open-type="getUserInfo")

- bindgetuserinfo 用户点击该按钮时, 会返回获取到的用户信息, 回调的 detail 数据与 wx.getUserInfo 返回的一致 (open-type="getUserInfo")
- session-form 会话来源 (open-type="contact")
- send-message-title 会话内消息卡片标题  (open-type="contact")
- send-message-path 会话内消息卡片点击跳转小程序路径 (open-type="contact")
- send-message-img 截图, 会话内消息卡片的图片 (open-type="contact")
- send-message-card 会话内消息卡片 (open-type="contact")
- bindcontact 客服消息回调  (open-type="contact")
- bindgetphonenumber 获取用户手机号回调 (open-type="getPhoneNumber")
- app-parameter 打开APP时, 向 APP 传递的参数 (open-type="launchApp")

- binderror 使用开放能力时, 发生错误的回调 (open-type="launchApp")
- bindopensetting 再打开授权设置页后回调 (open-type="openSetting")

##### 注意: 

1. button-hover 默认值为`{background-color: rgba(0,0,0,/1); opacity: 0.7;}`
2. bindgetphonenumber 自 1.2.0 开始支持, 低版本无法使用 canIUse 进行检测, 建议使用基础库版本进行判断
3. 在 bindgetphonenumber 等返回加密信息的回调中调用 wx.login 登录, 可能会刷新登录态, 此时服务器使用 code 换区的 sessionKey 不是加密时使用的 sessionKey, 导致解密失败. 建议开发者提前进行 login, 或者在回调中先使用 checkSession 进行登录态检查, 避免 login 刷新登录态
4. button 可作为原生组件的子节点嵌入, 以便在原生组件上使用 open-type 的能力

### checkbox-group

多项选择器, 有多个 checkbox 组成

- bindchange <checkbox-group> 中选项发生改变是触发 change 事件, detail = { value: [选项中checkbox 的value 值]}

##### checkbox 多选项目

- value <checkbox> 标识, 选中时触发 <checkbox-group> 的change事件, 并携带本身value
- disabled 是否禁用
- checked 当前是否选中, 可用来设置默认选中
- color checkbox 的颜色, 同 css 的 color

### form

表单, 将组件中用书输入的 <switch> <input> <checkbox> <radio> <picker> 提交

当点击 <form> 表单中 form-type 为 submit 的 <button> 组件时, 会将表单的 value 值进行提交, 需要给表单指定 name 值作为提交标识(key)

- report-submit 是否返回 formId 用于发送模板消息
- bindsubmit 携带 form 中的数据触发 submit 事件, `event.detail = {value: {'name':'value'}, formId: ''}`
- bindreset 表单重置时触发 reset 事件

### input

输入框. 该组件是原生组件

- value 输入框初始内容
- type   input 的类型
  - text 文本输入键盘
  - number 数字输入键盘
  - idcard 身份证输入键盘
  - digit 带小数点的数字键盘
- password 是否密码类型
- placeholder 输入框为空时占位符
- placeholder-style 指定 placeholder 样式
- placeholder-class 指定 placeholder 的样式类
- disabled 是否禁用
- maxlength 最大输出长度, -1表示不限制
- cursor-spacing 指定光标与键盘的距离, 单位 px. 取input 距离底部的距离和cursor-spacing 指定距离的最小值作为贯标与键盘的距离
- focus 自动聚焦, 拉起键盘
- confirm-type 设置键盘右下角的文字, 仅在 type = 'text' 时生效
  - send 右下角按钮为 "发送"
  - search 右下角按钮为 "搜索"
  - next 右下角按钮为 "下一个"
  - go 右下角按钮为 "前往"
  - done 右下角按钮为 "完成"
- confirm-hold 点击键盘有效较按钮时是否保持键盘不收起
- cursor 指定 focus 时光标位置
- selection-start 光标起始位置, 自动聚焦时有效, 需要与 selection-end 配合使用
- selection-end 光标结束位置
- adjust-position 键盘弹起时, 是否自动上推页面, 默认 true
- bindinput 键盘输入时触发, `event.detail` keyCode为键值, 处理函数可以直接 return 一个字符串, 将替换成输入框的内容
- bindfocus 输入框聚焦时触发  event.detail
- bindblur 输入框失去焦点时触发  event.detail
- bindconfirm 点击完成按钮时触发  event.detail

### label 

用来改进表单组件可用性, 使用 for 找到 对应id, 或将控件放到该标签下, 点击时就触发对应控件.

for 优先级高于内部控件, 内部若多个控件则触发第一个

目前可以绑定的控件有 <button> <checkbox> <radio> <switch>

- for 绑定控件的id

### picker

从底部弹起的滚动选择器, 支持5种选择器, 使用 mode 控制, 默认是普通选择器

##### 普通选择器 mode = selector

- range 默认[], mode 为 selector/multiSelector时, range有效
- range-key 当 range是一个 Object Array时, 可以通过 range-key 来指定 Object 中 key 的值作为选择器显示内容
- value 默认0, value的值表示选择了 range 中的第几个(下标0开始)
- bindchange value改变时触发 change 事件 detail.value
- disabled 是否禁用
- bindcancel 取消选择或点遮罩层收起 picker 时触发

##### 多列选择器: model = multiSelector

- range  二维 Array/二维 Object Array. mode 为 select/multiSelector 时有效, 二维数组, 长度表示多少列, 数组每项表示每列数据, 如 [['a','b'], ['c','d']] / [[{id:1, name:'美丽'},{id:2,name:'善良'},{id:3,name:'么么哒'}],[{id:1, gender:'女'}, {id:0,gender:'男'},{id:2,name:'保密'}] **这里的对象数组我有点懵!!**
- bindchange value 改变时触发change事件
- bindcolumnchange 某一列的值改变时触发 columnchange函数 detail.column 表示第几列 detail.value 表示变更值的下标
- bindcancel 取消选择时触发

##### 时间选择器 mode = time

- value 表示选中事件 hh:mm
- start 表示有效时间范围开始, 字符串格式为 "hh:mm"
- end 表示有效时间范围的结束
- bindchange value改变时触发 change 事件 detail.value
- bindcancel 取消选择时触发
- disabled 是否禁用

##### 日期选择器 mode = date

- value 表示选中的日期 格式 "YYYY-MM-DD"
- start 有效日期范围的开始
- end 有效日期范围的结束
- fields 有效值 year,montgh,day 表示选择器的粒度, 默认 day
- bindchange value 改变时触发change 事件 
- bindcancel 取消选择时触发
- disabled 是否禁用

##### 省市选择器 mode = region

- value 表示选中的省市区, 默认选中每一列第一个值
- custom-item 可为每一列的顶部添加一个自定义项
- bindchange value 改变时触发 change 事件, detail.code 表示区划分代码, postcode 是邮政
- disabled 是否禁用

### picker-view

嵌入页面的滚动选择器

- value NumberArray 数组中的数字依次表示 picker-view 内的 picker-view-column 选择的第几项(0开始), 数字大于可选长度时, 选择最后一项
- indicator-style 设置选择器中间选中框的样式
- indicator-class 设置选择器黄总监选中框的样式类
- mask-style 设置蒙层样式
- mask-class 设置蒙层样式类
- bindchange 滚动选择时, value 改变时触发change事件 event.detail
- bindpickstart 滚动选择开始时候触发事件
- bindpickend 滚动选择结束时触发事件

其中仅能放置 <picker-view-column /> 组件

### radio-group

单项选择器, 内部由多个 <radio> 组成

- bindchange  组件内部发生改变触发 change 函数

##### radio

单选项目

- value <radio> 标识. 当 <radio> 选中时, <radio-group> 的 change 事件会携带 <radio> 的 value
- checked 当前是否选中
- disabled 是否禁用
- color <radio>颜色, 同 css 的 color

### slider

滑动选择器

- min 最小值
- max 最大值
- step 步长
- disabled 是否禁用
- value 当前值
- color 背景条颜色(使用backgroundColor)
- selected-color 已选择的颜色(activeColor)
- activeColor 已选择的颜色
- backgroundColor 背景条颜色
- block-size 滑块大小, 取值范围 12-28
- block-color 滑块颜色
- show-value 是否显示当前 value
- bindchange 完成一次拖动后触发的事件, event.detail
- bindchanging 拖动过程中触发的事件 event.detail

### switch 

开关选择器

- checked	是否选中
- disabled 是否禁用
- type 样式
  - switch
  - checkbox
- bindchange checked 改变时触发函数
- color switch 颜色

### textarea

多行输入框, 该组件是原生组件

- value 输入框的内容
- placeholder 输入框空时占位符
- placeholeder-style 指定占位符样式
- placeholder-class 指定占位符样式类
- disabled 是否禁用
- maxlength 最大长度
- focus textarea聚焦, 键盘拉起
- auto-height 是否自动增高
- fixed 如果textarea 是一个  position:fixed 的区域, 需要显示指定属性 fixed 为 true
- cursor-spacing 指定光标与键盘的距离 取光标底部距离与cursor-spacing 指定的距离最小值作为光标与键盘的距离
- cursor 指定 focus 时光标的位置
- show-confirm-bar 是否显示键盘上方带有 "完成" 按钮一栏
- selection-start 光标起始位置, 自动聚焦时有效, 需要 selection-end配合
- selection-end 光标结束为止
- adjust-position 键盘弹起时, 是否自动上推页面
- bindfocus 输入框聚焦时触发 event.detail.height 表示键盘高度
- bindblur 输入框失去焦点时触发
- bindlinechange 输入框行数变化时调用
- bindinput 键盘输入时, 触发 input 事件
- bindconfirm 点击完成时 触发 confirm 事件

## 导航

### navigator

页面链接

- target 在哪个目标上发生跳转, 默认当前小程序, 可选值 self/miniProgram
- url 当前小程序内跳转链接
- open-type 跳转方式
  - navigate 对应 wx.navigateTo /wx.navigateToMiniProgram
  - redirect 对应 wx.redirectTo 关闭某个页面, 跳转到 非 tab 页面
  - switchTab 对应 wx.switchTab 打开 tab 页面, 关闭非 tab 页面
  - reLaunch 对应 wx.reLaunch 关闭所有页面, 打开某
  - navigateBack 对应 wx.navigateBack
  - exit 推出小程序  target 为 'miniProgram' 时有效
- delta 当open-type为 'navigateBack' 有效, 表示回退层数
- app-id 当target 为 'miniProgram' 时有效, 表示要打开的小程序 appId
- path 当target 为 'miniProgram' 时有效, 表示打开页面路径, 空则打开首页
- extra-data 当target 为 'miniProgram' 时有效, 表传递给小程序的数据, 在 App.onLaunch() App.onShow() 获取
- version 当 target="minProgram" 时有效, 要打开的小程序版本
  - develop 开发版
  - trial 体验版
  - release 正式版
- hover-class 指定点击时的样式类, none表示没有点击效果
- hover-stop-propagation 指定是否阻止本节点的祖先节点出现点击态
- hover-start-time 按住多久出现点击态
- hover-stay-time 手指松开后点击态保留时间
- bindsuccess 当 target = 'miniProgram' 时有效, 跳转小程序成功
- bindfail 同上, 跳转失败
- bindcomplete 同上, 跳转完成

使用限制

1. 需要用户确认跳转 

   在跳转至其他小程序前, 将统一增加弹窗, 询问是否跳转, 用户确认后才可以跳转至其他小程序, 如果 用户点击取消, 则回调 fail cancel

2. 每个小程序可以跳转的其他小程序数量限制为不超过10 个

   开发者提交新版小程序代码时, 如果使用了跳转/其他小程序功能, 则需要在代码配置中声明将要跳转的小程序名单, 限制不超过10个, 否则无法通过审核.名单在发布新版本时更新, 不支持动态修改. 

### functional-page-navigator

仅在插件中有效, 用于跳转到插件功能页

- version 跳转到小程序版本, 有效值 develop(开发版), trial(体验版), release(正式版) **线上版本必须设置为 release** 
- name 跳转到功能页
  - loginAndGetUserInfo 用户信息功能页
  - requestPayment 支付功能页
- args 功能页参数, 参数格式与具体功能页相关
- bindsuccess 功能页返回, 且操作成功时触发, detail 格式与具备功能页相关
- bindfail 功能页返回, 且操作失败时触发

## 媒体组件

### audio

音频, 建议使用更强的 wx.createInnerAudioContext 接口

- id audio 组件唯一标识符
- src 播放音频资源地址
- loop 是否循环播放
- controls 是否显示默认控件
- poster 默认控件上音频封面图片资源地址
- name 默认控件上音频名字 
- author 默认控件上音频作者
- binderror 当发生错误时触发 error 事件 detail.errMsg
  - 1 获取资源被用户禁止
  - 2 网络错误
  - 3 解码错误
  - 4 不合适资源
- bindplay 当开始/继续播放时触发 play 事件
- bindpause 当暂停播放时触发 pause 事件
- bindtimeupdate 当播放进度改变时触发的 timeupdate 事件
- bindended 播放到末尾时触发 ended 事件

### image

图片 

- src 图片资源地址
- mode 图片缩放, 裁剪模式
  - scaleToFill 不包吃纵横比缩放, 完全拉伸直至填满 image 元素
  - aspectFit 保持纵横比缩放图片. 图片长边能完全显示出来
  - aspectFill 保持纵横比缩放图片. 只保证图片的短边能够完全显示出来. 截取
  - top 不缩放图片, 只显示图片的顶部区域
  - ...
- lazy-load 图片懒加载, 只针对 page 与 scroll-view 下的 image 有效
- binderror 当发生错误时, 发布到 AppService 的事件名
- bindload 当图片加载完毕时, 发布到 AppService 的事件名 event.detail.heigh/width

注意: image组件默认宽度 300px, 高255px; image组件中二维码/小程序码不支持长按识别. 仅在 wx.previewImage 中支持长按识别

### video

视频. 该是原生组件

- src  要播放视频的资源地址
- initial-time 指定视频初始播放位置
- duration 指定视频时长
- controls 是否显示默认播放控件
- danmu-list 弹幕列表
- danmu-btn 是否显示弹幕按钮
- enable-danmu 是否显示弹幕列表
- autoplay 自动播放
- loop 循环播放
- muted 静音播放
- page-gesture 非全屏模式下, 是否开启亮度与音量调节手势
- direction 设置全屏是视频的方向, 不指定则根据宽高比自动判断  0正常竖向 90频密逆时针90度 -90品目顺时针90度
- show-progress 是否显示进度条, 如果不设置, 宽度大于240时显示
- show-fullscreen-btn 是否显示全屏按钮
- show-play-btn 是否显示视频底部控制栏播放按钮
- show-center-play-btn 是否显示视频中间的播放按钮
- enable-progress-gesture 是否开启控制进度手势
- objectFit 当视频大小与 video 容器大小不一致时, 视频的表现是形式. contain:包含 full填充 cover 覆盖
- poster 视图封面的图片网络资源地址
- bindplay 开始/继续播放时触发 play 事件
- bindpause 暂停播放触发 pause 事件
- bindended 播放到末尾时触发 ended 事件
- bindtimeupdate 播放进度条发生变化时触发 
- bindfullscreenchange 视频进入和退出全屏时触发
- bindwaiting 时出现缓冲时触发
- binderror 视频播放出错时触发
- bindprogress 加载进度变化时触发, 只支持一段加载

<video> 默认宽度300px 高度225

### camera

系统相机 , 该组件是原生组件

需要用户授权 scope.camera

- mode 有效值nomal/scanCode
- device-position 前置/后置 front, back
- flash 闪光灯
- bindstop 摄像头在非正常终止时触发(退出后台)
- binderror 用户不允许使用摄像头时触发
- bindscancode 扫码识别成功时触发, mode = scanCode 时有效

相关api: wx.createCameraContext

同一个页面只能插入一个camera 组件

### live-player

实时视频播放. 该组件是原生组件

暂只针对国内主体如下类目的小程序开放. 需要先通过类目审核, 再在小程序管理后台, "设置" - "接口设置" 中自助开通该组件权限

- 社交 
  - 直播
- 教育
  - 在线机构
- 医疗
  - 互联网医院, 公立医院
- 政务民生
  - 所有二级类目
- 金融
  - ....
  - ​

属性信息

-  src 音频地址. 目前只支持 flev rtmp 格式
- mode live(直播), RTC (实时通话, 该模式时延迟更低)
- autoplay 自动播放
- muted 是否静音
- orientation 画面方向
- object-fit 填充模式: contain, fillCrop
- min-cache 最小缓冲区, 单位s
- max-cache 最大缓冲区
- bindstatechange 播放状态变化事件
- bindfullscreenchange 全屏变化事件
- binnetstatus 网络状态通知

相关api: wx.createLivePlayerContext

### live-pusher

实时视频录制, 该组件时原生组件

需要用户授权 scope.camera / scope.record

## 地图

### map 

地图, 该组件是原生组件, 个性化地图能力可在小程序后台 "设置-开发者工具-腾讯位置服务" 申请开通. 设置 subkey后, 小程序内的地图组件均会使用该底图效果

个性化底图暂不支持工具中测试

- longitude 中心经度
- latitude 中心纬度
- scale 缩放级别 5-18
- markers 标记点
  - 标记点用于在地图上显示标记的位置
    - id 标记id marker点击事件回调会返回此 id, 建议每个 marker 设置上 Number 类型的 id 保证更新marker时有更好的性能
    - latitude 纬度
    - longitude 经度
    - title 标记点名
    - zIndex 显示层级
    - iconPath 显示的图标
    - rotate 旋转的角度
    - alpha 标注的透明度
    - width 标注图标宽度
    - height 标注图标高度
    - callout 自定义标注点上方的气泡窗口
      - content 文本
      - color 文本颜色
      - fontSize 文字大小
      - borderRadius 边框圆角
      - borderWdith 边框宽度
      - borderColor 边框颜色
      - bgColor 背景色
      - padding 文本边缘留白
      - display  BYCLICK 点击显示/ALWAYS 常显
      - textAlign 文本对齐方式. 有效值 left/right/center
    - label 为标注点旁边增加标签
    - anchor 经纬度在标注图标的锚点
    - ...
- polyline 路线
- polygons 多边形
- circles 圆
- controls 控件(即废弃, 建议使用 cover-view)
- include-points 缩放视野以包含所有给定的坐标点
- show-location 显示带有方向的当前定位点
- subkey 个性化底图使用key 
- enable-3D 显示 3d 楼快
- show-compass 限制指南针
- enable-overlooking 开启俯视
- enable-zoom 是否支持缩放
- enable-scroll 是否支持拖动
- enable-rotate 是否支持旋转
- bindmarkertap 点击标记点时触发, 返回 marker 的 id
- bindcallouttap 点击标记点对于的气泡时触发, 返回同上
- bindcontroltap 点击控件时触发, 返回 control 的id
- bindregionchange 视野发送变化时触发
- bindtap 点击地图触发
- bindupdated 地图渲染完成触发
- bindpoitap 点击地图 poi 点时触发

## 画布

### canvas

画布, 该组件是原生组件

- canvas-id canvas 组件的唯一标识符
- disable-scroll  默认false, 在canvas 中移动时且有绑定手势事件, 禁止屏幕滚动以及下拉刷新
- bindtouchstart  手势触摸事件开始
- bindtouchmove 手势触摸后移动
- bindtouchend 手势触摸动作结束
- bindtouchcancel 收拾出没动作被打断, 如来电等
- bindlongtap 手指长按 500ms触发 触发长按事件后进行移动不会触发屏幕的滚动
- binderror 错误事件

canvas 默认宽度 300 225 

同一页面中的 canvas-id 不可重复, 如果使用一个已经出现过的 canvas-id, 该 canvaas 标签对应的画布将被隐藏并不再正常工作

相关 api : wx.createCanvasContext

## 开放能力

### open-data

用于展示微信开放的数据

- type 开放数据类型
  - groupName 拉取群名称
  - userNickName y用户昵称
  - userAvatarUrl 用户头像地址
  - userGender 用户性别
  - userCity  用户所在城市
  - userProvince 用户所在省份
  - userCountry  用户所在国家
  - userLanguage 用户的语言
- open-gid 当type 为 groupName 时生效, 群 id
- lang type='user*' 时生效, 以何种语言展示 userInfog

关于open-gid的获取, 使用 wx.getShareInfo

### web-view

web-view 组件时一个可以用来承载网页的容器, 会自动铺满整个小程序页面. 个人和海外类型小程序暂不支持

- src web-view 指向网页链接. 可打开关联公众号的文章, 其他网页需要登录小程序管理后台配置业务域名
- bindmessage 网页向小程序 postMessage 时, 会在特定时机(小程序后退, 组件销毁, 分享) 触发并收到消息
- bindload 网页加载成功时触发此事件
- binderror 网页加载失败时触发此事件

示例

```html
<!-- 指向公众平台首页的 web-view -->
<web-view src="https://mp.weixin.qq.com"></web-view>
```

相关接口: 

<web-view> 网页中可以使用 JSSDK 提供的捷库返回小程序页面, 支持的接口有

| 接口名                      | 说明                 | 最低版本                                                     |
| --------------------------- | -------------------- | ------------------------------------------------------------ |
| wx.miniProgram.navigateTo   | 参数与小程序接口一致 | [1.6.4](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.navigateBack | 参数与小程序接口一致 | [1.6.4](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.switchTab    | 参数与小程序接口一致 | [1.6.5](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.reLaunch     | 参数与小程序接口一致 | [1.6.5](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.redirectTo   | 参数与小程序接口一致 | [1.6.5](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.postMessage  | 向小程序发送消息     | [1.7.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.getEnv       | 获取当前环境         | [1.7.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

相关接口2

<web-view> 网页中经支持以下 JSSDK 接口

- 判断客户段是否支持js  checkJSApi

- 图像接口
  - 拍照或上传 chooseImage
  - 预览图片 previewImage
  - 上传图片 uploadImage
  - 下载图片 downloadImage
  - 获取本地图片 getLocallmgData
- 音频接口
  - 开始录音 startRecord
  - 停止录音 stopRecord
  - 监听录音自动停止 onVoiceRecordEnd
  - 播放语音 playVoice
  - 暂停播放 pauseVoice
  - 停止播放 stopVoice
  - 监听语音播放完毕 onVoicePlayEnd
  - 上传接口 uploadVoice
  - 下载接口 downloadVoice

- 智能接口
  - 识别音频 translateVoice
- 设备信息
  - 获取网络状态 getNetworkType
- 地理位置
  - 使用内置地图打开地点 openLocation
  - 获取地理位置 getLocation
- 摇一摇周边 
  - 打开ibeacon startSearchBeacons
  - 关闭ibeacon stopSearchBeacons
  - 监听ibeacon onSearchBeacons
- 微信扫一扫
  - 调起微信扫一扫 scanQRCode
- 微信卡卷 
  - 拉取使用微信卡劵列表 chooseCard
  - 批量增加卡劵接口 addCard
  - 查看微信卡包的卡卷 openCard
- 长按识别 
  - 小程序圆形码

相关接口3

用户分享时可获取当前 <web-view> 的URL, 即在 onShareAppMessage 回调中返回 webViewUrl 参数.

相关接口4

在网页内可通过 window.__wxjs_environment 变量判断是否在小程序环境, 建议在 WeixinJSBridgeReady 回调中使用, 也可以使用 JSSDK 提供的 getEnv 接口

相关接口5

从卫星7.0.0开始, 可以通过判断 userAgent 中包含 miniProgram 来判断小程序 web-view 环境

### ad

广告, 目前暂时以邀请制开放申请

- unit-id  广告单元id, 可以在小程序管理后台的流量主模块新建
- bindload  广告加载成功的回调
- binderror 广告发生错误触发事件

监听到 error 回调后, 开发者可以正对性的处理, 比如隐藏广告组件的父容器, 以保证用户体验, 但是不要移除广告组件, 否则无法收到 bindload 的回调

### official-account

用户扫码打开小程序时, 开发者可以在小程序内配置公众号关注组件, 方便用户快捷关注公众号,可嵌套在原生组件中	

1. 使用组件前, 需要前往小程序管理后台, 在 "设置" -> "接口设置" -> "公众号关注组件" 中设置要展示的公众号

设置的公众号主体要和小程序主体一致

2. 在一个小程序的生命周期内, 只有从以下场景进入小程序, 才具有展示引导关注公众号组件的能力
   - 当小程序从扫我二维码场景(1011)打开时
   - 当小程序从扫小程序码场景 (1047) 打开
   - 当小程序从聊天顶部场景(1089) 中[最近使用]内打开时, 若小程序之前未被销毁, 则该组件保持上一次打开小程序时的状态
   - 当从其他小程序返回小程序(1038)时, 若之前未被销毁, 则该组件保持上一次打开状态
3. 组件限定最小宽度为 300px 高度为定值 84ox
4. 每个页面只能配置一个该组件

- bindload 组件加载成功时触发

- binderror 组件加载失败时触发

  detail 对象

  - status 状态码
    - -2 网络错误
    - -1 数据解析从未
    - 0 加载错误
    - 1 小程序关注公众号功能被封禁
    - 2...
  - errMsg 错误信息

示例代码

```html
<official-account></official-account>
```

## 原生组件说明

小程序中的部分组件是由客户端创建的原生组件, 这些组件有

- camera
- canvas
- input
- live-player
- live-pusher
- map
- textarea
- video

### 原生组件的使用限制

因为原生组件脱离在 webView 渲染流程外, 所以

- 原生组件的层级是最高的, 所以页面中的其他组件无论 z-index 多少, 都无法改在原生组件上
  - 后插入的原生组件可以覆盖之前的原生组件
- 元素组件还无法在 scroll-view swiper picker-view movable-view 中使用
- 部分css样式无法应用于原生组件
  - 无法对原生组件使用 CSS动画
  - 无法定义原生组件位诶 position: fixed
  - 不能在父节点使用 overflow:hidden 来裁剪原生组件的显示区域
- 元素组件的事件监听不能使用 bind:eventname 的写法, 只支持 bindeventname . 原生组件也不支持 catch 和 capture 的事件绑定方式
- IOS 下原生组件不支持触摸相关事件
- 原生组件会遮挡 vConsole 弹窗弹出的调试面板

在工具上, 原生组件是用 web 组件模拟的, 因为很多情况不能很多地还原真机表现, 建议开发者使用原生组件时近来在真机上进行调试

### cover-view 和 cover-image

为了解决原生组件层级最高的限制, 小程序专门提供了 cover-view 和 cover-image 组件, 可以覆盖在部分原生组件上面. 这两个组件也是原生组件, 但是使用限制与其它原生组件有所不同

# 架构*

## 目录结构

程序包含一个描述整体的程序的 app 和 多个描述各自页面的 page

一个小程序的主体部分由三个文件组成, 必须放在小程序根目录下	

| 文件                                                         | 必需 | 作用             |
| ------------------------------------------------------------ | ---- | ---------------- |
| [app.js](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html) | 是   | 小程序逻辑       |
| [app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html) | 是   | 小程序公共配置   |
| [app.wxss](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html) | 否   | 小程序公共样式表 |

一个小程序页面由四个文件组成, 分别是

js(必须) / wxml(必须) / json / wxss

注意: 为了方便开发者减少配置项, 描述页面的四个文件必须具有相同的路径与文件名

**允许上传的文件**

在项目目录中, 以下文件会经过编译, 因此上传之后无法直接访问: .js/ app.json/ .wxml/ *.wxss(其中 wxml 和 wxss 文件仅针对 app.json 中配置了的页面) 除此之外, 只有后缀名在白名单中的文件可以被上传, 白名单如下

1. wxs
2. png/jpg/jpeg/gif/svg
3. json
4. cer
5. mp3
6. aac
7. m4a
8. wav/mp4
9. ogg
10. silk

## 配置

### 全局配置

小程序根目录下的 app.json 文件用来对微信小程序进行全局配置, 决定页面文件的路径, 窗口表现, 设置网络超时时间, 设置多 tab 等

##### app.json 配置项列表

- pages* StringArray页面路径列表

  用于指定小程序由哪些页面组成, 每一项都对应一个页面, 路径+文件名 信息, 文件名不需要写文件后缀, 框架会自动去寻找对于位置的 .json .js .wxml .wxss 四个文件进行处理

  数组的第一项代表小程序的初始页面(首页), 小程序中新增/减少页面, 都需要对 pages 数组进行修改

- window 全局的默认窗口表现

  用于设置小程序状态栏, 导航条, 标题, 窗口背景色

  - navigationBarBackgroundColor 导航栏背景颜色
  - navigationBarTextStyle 导航栏标题颜色, 仅支持black/white
  - navigationBarTitleText 导航栏标题文字内容
  - navigationStyle 导航栏样式, 仅支持 defalut(默认样式) / custom(自定义导航栏, 保留右上角胶囊按钮)
  - backgroundColor 窗口的背景颜色
  - backgroundTextStyle 下拉loading 的样式, dark/light
  - backgroundColorTop 顶部窗口的背景色 IOS 支持
  - backgroundColorBottom 底部窗口的背景色 IOS 支持
  - enablePullDownRefresh 是否开启当前页面的下拉刷新
  - onReachBottomDistance 页面上拉触底事件触发时距页面底部距离, 单位px
  - pageOrientation 屏幕旋转设置 auto/portrait

- tabBar 底部 tab 栏的表现

  如果小程序是一个多 tab 应用, 可以通过 tabBar 配置项指定 tab 栏的表现, 以及 tab 切换时显示的对应页面

  - color tab上的文字默认颜色
  - selectedColor tab上文字选中时颜色
  - backgroundColor tab 的背景色
  - borderStyle tabbar上边框颜色 black/ white
  - list tab 的列表, 至少2个, 最多5个
    - pagePath 页面路径, 必须在 pages 中先定义
    - text tab 上按钮文字
    - iconPath 图片路径, icon 大小限制为 40kb, 建议尺寸 81px*81px, 不支持网络图片
    - selectedIconPath 选中时的图片路径, icon 大小限制为 40kb, 建议使用 81px*2
  - position tabbar位置 bottom/top

- networkTimeout 网络超时时间

  各类网络请求超时时间,单位毫秒

  - request wx.request 的超时时间
  - connectSocket wx.connectSocket 的超时时间
  - uploadFile wx.uploadFile 的超时时间
  - downloadFile wx.downLoadFile 的超时时间

- debug 是否开启 debug模式, 默认关闭

  可以在开发工具中开启 debug 模式, 在开发和工具的控制台面板, 调试信息以 info 的形式给出, 其信息有Page的注册, 页面路由, 数据更新, 事件触发等, 可以帮助开发者快速定位一些常见的问题

- functionalPages 是否启用插件功能, 默认关闭

  启用插件功能页时, 插件所有者小程序必须设置为 functionalPages 为 true

- subpackages 分包结构配置

  启用分包加载时,声明项目分包结构

- workers  Worker 代码放置的目录

  使用 Worker 处理多线程任务时, worker 代码放置的目录

- requiredBackgroundModes 需要在后台使用的能力, 如 音乐播放

  声明需要后台运行的能力, 类型为数组,

  - audio 后台音乐播放

  ```js
  {
      "pages":["pages/index/index"],
      "requireBackgroundModes":["audio"]
  }
  ```

  此处申明了后台运行的借口, 开发版和体验版可以直接生效, 正式版还需要通过审核

- plugins 使用到的插件

  声明小程序需要使用的插件

- preloadRule 分包预下载规则

  声明分包预下载的规则

- resizable iPad小程序是否支持屏幕旋转, 默认关闭

- navigateToMiniProgramAppIdList 需要跳转的小程序列表, 详情 wx.navigateToMiniProgram

  当小程序需要使用 wx.navigateToMiniProgram 接口跳转到其它小程序时, 需要先在配置文件中声明需要跳转的小程序 appId 列表, 最多允许10 个

- usingComponents 全局自定义组件配置

  此处声明的自定义组件视为全局自定义组件, 在小程序内的页面或自定义组件中可以直接使用而无需再声明

- permission 小程序接口权限相关配置

  小程序接口权限相关配置, 字段类型是对象

  - scope.userLocation 位置相关权限声明
    - desc 小程序获取权限时展示的接口用途说明, 最长30字符

  ```js
  "permission": {
      "scope.userLocation": {
          "desc": "你的位置信息将用于小程序位置接口的效果展示"
      }
  }
  ```

### 页面配置

每个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置	

页面的配置只能设置 app.json 中 window配置项内容, 页面中的配置会覆盖全局 app.json 中 window 相同的配置项

##### 页面配置项列表

| 属性                         | 类型     | 默认值  | 描述                                                         | 最低版本         |
| ---------------------------- | -------- | ------- | ------------------------------------------------------------ | ---------------- |
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如 `#000000`                                 |                  |
| navigationBarTextStyle       | String   | white   | 导航栏标题颜色，仅支持 `black` / `white`                     |                  |
| navigationBarTitleText       | String   |         | 导航栏标题文字内容                                           |                  |
| navigationStyle              | String   | default | 导航栏样式，仅支持以下值： `default` 默认样式 `custom` 自定义导航栏，只保留右上角胶囊按钮 | 微信客户端 7.0.0 |
| backgroundColor              | HexColor | #ffffff | 窗口的背景色                                                 |                  |
| backgroundTextStyle          | String   | dark    | 下拉 loading 的样式，仅支持 `dark` / `light`                 |                  |
| enablePullDownRefresh        | Boolean  | false   | 是否全局开启下拉刷新。 详见 [Page.onPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#onpulldownrefresh) |                  |
| onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 [Page.onReachBottom](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#onreachbottom) |                  |
| disableScroll                | Boolean  | false   | 设置为 `true` 则页面整体不能上下滚动。 只在页面配置中有效，无法在 `app.json`中设置 |                  |
| disableSwipeBack             | Boolean  | false   | 禁止页面右滑手势返回                                         |                  |

注意: 页面的 .json 职能配置 window 相关的配置项, 已决定本页面的窗口表现, 所以无需写 window 属性

示例: 

```json
{
  "navigationBarBackgroundColor": "#ffffff",
  "navigationBarTextStyle": "black",
  "navigationBarTitleText": "微信接口功能演示",
  "backgroundColor": "#eeeeee",
  "backgroundTextStyle": "light"
}
```

## 逻辑层

小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能. 

逻辑层将数据进行处理后发送给视图层, 同时接受视图层的事件反馈

开发者缩写的所有代码最终将被打包成一份 JavaScript 文件, 并在小程序启动的时候运行, 直到小程序销毁, 这一行为类似 ServiceWorker, 所以逻辑层也被称之为 App Service

在 JavaScript 的基础上, 我们增加了一些功能, 以方便小程序的开发

- 增加 App 和 Page 方法, 进行小程序的页面的注册
- 增加 getApp 和 getCurrentPages 方法, 分别用来获取 App 实例和当前的页面栈
- 提供丰富 API , 如微信用户数据, 扫一扫, 支付等微信特有能力
- 每个页面有独立的作用域, 并提供模块化能力

**小程序框架的逻辑层并非运行在浏览器中, 因此 JavaScript 在 web 中一些能力都无法使用, 如window. document 等**

### 注册小程序

##### 小程序 App(Object)

App() 函数用来注册一个小程序

必须在 app.js 中调用, 并且只能调一次

- onLaunch 生命周期回调  ---  监听小程序初始化

  - onLaunch(Object) 小程序初始化完成触发, 全局只触发一次, 参数也可以使用 wx.getLaunchOptionsSync 获取, 参数与 wx.getLaunchOptionsSync 一致

- onShow 生命周期回调 ---- 监听小程序显示

  - onShow(Object) 小程序启动, 或从后台进入前台显示时触发, 也可以使用 onAppShow 绑定监听

- onHide 生命周期回调 ----- 监听小程序隐藏

  - onHide() 小程序从前台进入后台时触发, 也可以使用 wx.onAppHide 绑定监听

- onError 错误监听函数

  - 小程序发生脚本错误或 API 调用错误时触发, 也可以使用 wx.onError 绑定监听, 参数一致

- onPageNotFound  页面不存在监听函数

  - onPageNotFound(Object) 小程序要打开开的页面不存在时触发. 可以使用 wx.onPageNotFound 绑定监听. 参数一致

  ```js
  App({
      onPageNotFound(res) {
          wx.redirectTo({
              url: 'pages/...'
          }) // 如果是 tabbar 页面，请使用 wx.switchTab
      }
  })
  ```

- 其他 开发者可以添加任意的函数或数据到 Object 参数中, 使用 this 访问 

前台/后台 定义: 用户点击左上角关闭, 或者按了设备 Home 键离开微信, 小程序并没有直接销毁, 而是进入后台, 当再次进入小程序或再次打开小程序, 又会从后台进入前台, 需要注意: 只有当小程序进入后台一定时间, 或者系统资源占用过高, 才会被真正的销毁

##### getApp(Object)

全局的 getApp() 函数可以用来获取到小程序 App 实例.

- allowDefault 在 App 未定义时返回默认实现, 当 App 被调用时, 默认实现中定义的属性会被覆盖合并到 App中, 一般用于独立分包

```js
// other.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data
```

注意: 通过getApp() 获取实例之后, 我们不要私自调用生命周期函数

### 场景值

当前支持的场景值有

- 1001 发现栏小程序入口, [最近使用] 列表, 包含[我的小程序]列表
- 1005 顶部搜索框搜索结果页
- 1006 发现栏小程序主入口搜索框的搜索结果页
- 1007 单人聊天会话中内的小程序消息卡片
- 1008 群聊会话中的小程序消息卡片
- 1011 扫描二维码
- 1012 长按图片识别二维码
- 1013 手机相册选取二维码
- 1014 小程序模板消息
- 1017 前往体验版的入口
- 1019 微信钱包
- 1020 公众号 profile 页相关小程序列表
- 1022 聊天顶部置顶小程序入口
- 1023 安卓系统桌面图标
- 1024 小程序 profile 页
- 1025 扫描一维码
- 1026 附件小程序列表
- 1027 顶部搜索栏搜索结果页 [使用过的小程序]列表
- 1028 我的卡包
- 1029 卡劵详情页
- 1030 自动化测试下打开小程序
- 1031 长按识别一维码
- 1032 手机相册选取一维码
- 1034 维修支付完成页
- 1035 公众号自定义菜单
- 1036 App分享消息卡片
- 1037 小程序打开小程序
- 1038 从另一个小程序返回
- 1039 摇电视
- 1042 添加好友搜索框的搜索结果页
- 1043 公众号模板消息
- 1044 待 shareTicket 的小程序消息卡片
- 1045 朋友圈广告
- 1047 扫描小程序码
- 1048 长按图片识别小程序码
- 1049 手机相册选取小程序码
- 1052 卡劵的适用门店列表
- 1053 搜一搜的结果页
- 1054 顶部搜索框小程序快捷入口
- 1056 音乐播放器菜单
- 1057 钱包中的银行卡详情页
- 1058 公众号文章
- 1059 体验版小程序绑定邀请页
- 1064 微信连 Wi-Fi 状态栏
- 1067 公众号文章广告
- 1068 附近小程序列表广告
- 1069 移动应用
- 1071 钱包中银行卡列表页
- 1072 二维码收款页面
- 1073 客服消息列表下发的小程序消息卡片
- 1074 公众号会话下发的小程序消息卡片
- 1077 摇周边
- 1078 连 WiFi 成功页
- 1081 客服消息下发的文字链
- 1082 公众号会话下发的文字链
- 1084 朋友圈广告原生页
- 1089 微信聊天主界面下拉 [最近使用] 栏
- 1090 长按小程序右上角菜单唤出最近使用历史
- 1091 公众号文章商品卡片
- 1092 城市服务入口
- 1095 小程序广告组件
- 1096 聊天记录
- 1997 维修支付签约页
- 1099 页面内嵌插件
- 1102 公众号 profile 页服务预览
- 1103 发现栏小程序入口
- 1104 维修聊天主界面下拉

对于小程序, 可以在 App 的 onLaunch 和 onShow 或 wx.getLaunchOptionsSync 中获取上述场景值

### 注册页面

页面Page

**Page(Object) 构造器**

该函数用来注册一个页面, 授予 Object 类型参数, 其指定页面的初始化数据, 生命周期, 事件处理

- data 页面初始化数据对象

  data 时页面第一次渲染使用初始数据

  页面加载时, data 将会以 JSON 字符串形式由逻辑层传至渲染层, 因此, data 中的数据必须可以转成 JSON 类型: 字符串, 数字, 布尔值, 对象, 数组.

  渲染层可以通过  WXML 对数据进行绑定 {{}}

- onLoad 监听页面加载函数

  页面加载时触发, 一个页面只会调用一次, 可以在 onLoad 的参数中获取打开当前页面路径中的参数 query

- onShow 监听页面显示函数

  页面显示/切入前台时触发

- onReady 监听页面初次渲染完成函数

  页面初次渲染完成时触发, 一个页面只会调用一次, 代表页面已经准备妥当, 可以喝视图层进行交互

  注意: 对界面内容宁晋县设置的API 如 wx.setNavigationBarTitle, 请在  onReady 之后进行

- onHide 监听页面隐藏函数

  页面隐藏/切入后台时触发, 如 navigate 或 底部 tab 切换到其他页面, 小程序切入后台等

- onUnload 监听页面卸载函数

  页面卸载时触发. 如 redirectTo 或 navigateBack 到其他页面时

- onPullDownRefresh 监听用户下拉动作函数

  监听用户下拉刷新事件

  - 需要在 app.json 的 window 选项中或页面配置中开启 enablePullDownRefresh
  - 可以通过 wx.startPullDownRefresh 触发下拉刷新, 调用后触发下拉刷新动画, 效果与用户手动下拉刷新一致
  - 当处理完数据刷新后, wx.stopPullDownRefresh 可以停止当前页面的下拉刷新.

- onReachBottom 页面上拉触底事件的处理函数

  监听用户上拉触底事件

  - 可以在 app.json 的window 选项中或页面配置中设置触发距离 onReachBottomDistance.
  - 再触发距离内滑动周期, 本事件只会被触发一次

- onPageScroll(Object) 监听用户滑动页面事件

  - scrollTop 页面在垂直方向已滚动的距离

  注意: 在需要的时候才在 page 中定义此方法, 不要定义空方法. 以减少不必要的事件派发对渲染层-逻辑层通信的影响,  避免在 onPageScroll 中过于频繁执行 setData 等引起逻辑层-渲染层通信的操作. 尤其是每次传输大量数据, 会影响通信耗时.

- onShareAppMessage(Object) 用户点击右上角转发函数

  监听用户点击页面内转发按钮 (button 组件 open-type='share') 或右上角菜单 "转发" 按钮的行为, 并自定义转发内容

  注意: 只有定义了此事件处理函数, 右上角菜单才会显示 "转发" 按钮

  - form 转发事件来源 (button 页面内转发按钮; menu 右上角转发菜单)

  - target 如果 form 值是 button , 则target 是触发这次转发事件的 button, 否则为 undefined

  - webViewUrl 页面中包含 <web-view> 组件时, 返回当前 <web-view> 的 url

    该事件需要 return 一个 对象, 用于自定义转发内容, 返回内容如下

    - title 转发标题, 默认当前小程序名称
    - path 转发路径 当前页面的path, 必须是 /开头的而完整路径
    - imageUrl 自定义图片路径, 可以是本地文件路径, 代码包文件路径或者网络图片路径, 支持 PNG 及 JPG . 显示图片长度比是 5:4

    ```js
    Page({
        onShareAppMessage(res) {
            if (res.from === 'button') {
                // 来自页面内转发按钮
                console.log(res.target)
            }
            return {
                title: '自定义转发标题',
                path: '/page/user?id=123'
            }
        }
    })
    ```

- onResize 页面尺寸改变时触发函数

  小程序屏幕旋转时触发

- onTabItemTap(Object) 当前是tab页时, 点击 tab 时触发函数

  点击 tab 时触发

  - index 被点击 tabItem 的序号, 0起始
  - pagePath 被点击 tabItem 的页面路径
  - text 被点击 tablItem 的按钮文字

  ```js
  Page({
      onTabItemTap(item) {
          console.log(item.index)
          console.log(item.pagePath)
          console.log(item.text)
      }
  })
  ```

- 其他 任意函数或数据. 当前页面使用 this 访问

  组件处理函数, Page中可以定义组件事件处理函数, 在渲染层的组件中加入事件绑定, 当事件被触发时, 就会执行 Page 中定义的事件处理函数

除了 Page 作为高级用法, 页面可以像自定义组件一样使用 Component 来创建, 这样就可以使用自定义组件的特性, 比如 behaviors 等

##### route

Page.route 获取当前页面的路径 string

```js
onShow(){
    console.log(this.route)
}
```

##### setData

###### Page.prototype.setData(data, callback)

setData 函数用于将数据从逻辑层发送到视图层(异步) 同时改变对应的this.data 的值(同步)

- data 必须, 此次要改变的数据

  - 以 key:vlaue 的形式表示, 将 this.data 中的key 对应的值改成 value

  其中 key 可以以数据路径的形式给出, 支持改变数组中的某一项或对象的某一个属性, 如 array[2].message, a.b.c.d, 并且不需要再this.data中预先定义

- callback setData 引起的界面更新渲染完毕后的回调函数

注意: 

1. 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态(页面数据非实时数据)
2. 仅支持设置 JSON 化的数据
3. 单次设置的数据不能超过  1024kb, 经理避免一次设置过多的数据
4. 不要把data中的任何一项value 设为 undefined, 否则这一项将不被设置并且可能遗留潜在问题

##### 页面生命周期

![54596426047](.\wx\1545964260472.png)

### 路由

小程序中所有页面的路由全部由框架进行管理

**页面栈**

框架以栈的形式维护了当前的所有页面, 当发生路由切换时候, 页面栈表现如下

| 路由方式   | 页面栈表现                        |
| ---------- | --------------------------------- |
| 初始化     | 新页面入栈                        |
| 打开新页面 | 新页面入栈                        |
| 页面重定向 | 当前页面出栈，新页面入栈          |
| 页面返回   | 页面不断出栈，直到目标返回页      |
| Tab 切换   | 页面全部出栈，只留下新的 Tab 页面 |
| 重加载     | 页面全部出栈，只留下新的页面      |

##### getCurrentPages()

用于获取当前页面栈的实例, 以数组形式按栈的顺序给出, 第一个元素为首页, 最后一个元素为当前页

注意: 

1. 不要尝试修改页面栈, 会导致路由以及页面状态错误
2. 不要在 App.onLaunch 的时候调用 getCurrentpages, 此时 page 还没有生产

##### 路由方式

对于路由的触发方式以及页面生命周期函数如下

| 路由方式   | 触发时机                                                     | 路由前页面 | 路由后页面         |
| ---------- | ------------------------------------------------------------ | ---------- | ------------------ |
| 初始化     | 小程序打开的第一个页面                                       |            | onLoad, onShow     |
| 打开新页面 | 调用 API [`wx.navigateTo`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.navigateTo.html) 或使用组件 [``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) | onHide     | onLoad, onShow     |
| 页面重定向 | 调用 API [`wx.redirectTo`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.redirectTo.html) 或使用组件 [``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) | onUnload   | onLoad, onShow     |
| 页面返回   | 调用 API [`wx.navigateBack`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.navigateBack.html) 或使用组件[``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html)或用户按左上角返回按钮 | onUnload   | onShow             |
| Tab 切换   | 调用 API [`wx.switchTab`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.switchTab.html) 或使用组件 [``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html)或用户切换 Tab |            | 各种情况请参考下表 |
| 重启动     | 调用 API [`wx.reLaunch`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.reLaunch.html) 或使用组件 [``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) | onUnload   | onLoad, onShow     |

注意:

1. navigateTo, redirectTo 只能打开非 tabBar 页面
2. switchTab 只能打开 tabBar 页面
3. reLaunch 可以打开任意页面
4. 页面底部的 tabBar 由页面决定, 即只要是定义为 tabBar 的页面, 底部都有 tabBar
5. 调用页面路由带的参数可以在目标页面的 onLoad 中获取

###  模块化

##### 文件作用域

在 JavaScript 文件中声明的变量和函数只能在该文件中有效. 不同的文件中可以声明相同的变量和函数, 不相互影响, 通过全局函数 getApp() 可以获取全局的应用实例, 如果需要全局的数据可以在 App() 中设置

```js
// app.js
App({
    globalData:'无可睥睨'
})

// other.js
// console.log(getApp().globalData)
```

##### 模块化

可以将一些公共的代码抽离成一个单独的 js 文件, 作为一个模块, 模块通过 module.exports/exports对外暴露接口	

需要注意:

1. exports 是 module.exports 的一个引用, 因此在模块里随便更改 exports 的指向会造成引用链断开, 推荐开发者采用 module.exports 来暴露模块接口
2. 小程序目前不支持映入 node_modules ,开发者需要使用 node_modules 时候建议拷贝出相关的代码到下程序的目录中或使用小程序支持的 npm 功能

```js
//	tool.js
function sayHi(name){
    console.log('hi, '+ name + '先森')
}
function sayBey(name){
    console.log('bey, '+ name + '先森')
}
module.exports = {
    sayHi,
    sayBey
}
```

在需要使用模块的文件中, 使用 require(path) 将代码引入, 暂不支持绝对路径

```js
const tool = require('tool.js')
Page({
    helloMINA(){
        tool.sayHi('MINA')
    }
})
```

也可以使用 import 方式引入

```js
import { sayHi } from 'tool.js';
Page({
    helloMINA(){
        sayHI('MINA')
    }
})
```

### API

小程序开发框架提供丰富的微信原生 API, 可以方便地调起微信提供的能力, 如获取用户信息, 本地存储, 支付功能等

通常, 在小程序 API 有以下几种类型

##### 事件监听 API

我们约定, 以 on 开头的 API 用来监听某个事件是否触发, 如 wx.onSocketOpen, wx.onCompassChange 等

这类 API 接受一个回调函数作为参数, 当时间触发时会调用这个回调函数, 并将相关数据以参数形式传入

示例:

```js
wx.onCompassChange((res) => {
    console.log(res.direction)
})
```

##### 同步 API

我们约定, 以 Sync 结尾的API 都是同步 API, 如 wx.setStorageSync 等, 此外也有一些其他的同步 API, 如 wx.createWorker, wx.getBackgroundAudioManager 等

同步 API 的执行结果可以通过函数返回值直接获取, 执行出错会抛出异常

```js
try {
    wx.setStorageSync('key', 'value')
} catach (e) {
	console.log(e)
}
```

##### 异步 API


- success 接口成功回调
- fail 接口调用失败回调
- complete 接口调用结束回调
- 其他 接口定义的其他参数

###### 回调参数

- errMsg 错误信息, 如果调用成功返回 ${apiName}:ok
- errCode 错误码, 部分API支持, 成功返回0
- 其他 接口返回的其它数据

异步 API 的执行结果需要通过 Object 类型的参数中传入的对应的回调函数获取. 部分异步 API 也有返回值, 可以用来实现更丰富的功能, 如 wx.request wx.connectSockets 等

## 视图层

视图层 View 

框架的视图层有 WXML 与 WXSS 编写, 由组件来进行展示

将逻辑层的数据反应成视图层, 同时将视图层的事件给逻辑层

WXML 用于及描述页面结构

WXS 小程序的一套脚本语言, 结合 WXML 构建页面结构

WXSS 用于描述页面样式

组件(Components) 视图基本组成单元

### WXML

WXML(WeiXin Markup Language) 是框架设计的一套标签语言, 结合 基础组件, 事件系统, 可以构建出页面的结构

以下例子展示 WXML 具备的能力

##### 数据绑定

WXML 中的动态数据均来自对应 Page 中的 data

**简单的绑定**

数据绑定使用 Mustache 语法 `{{}}` 将变量包起来

```html
//	wxml
<view>{{message}}</view>

//page.js
data:{message: 'hello wxml'}
```

组件属性, 控制属性, 关键字 都需要在双引号之内

###### 运算

可以在 `{{}}` 内进行简单的运算, 支持的有如下几种方式

```html
<!--三元表达式 -->
<view hidden="{{flag? true : false}}">hidden</view>

<!--算数运算 -->
<view>{{a + b}} + {{c}} + d </view>

<!--逻辑判断 -->
<view wx:if="{{length>5}}"></view>

<!--字符串运算 -->
<view>{{"hello" + "MINA"}}</view>

<!--数据路径运算 -->
<view>{{obj.key}} {{arr[0]}}</view>

<!--组合 -->
<view wx:for="{{[zero, 1, 2, 3, 4, 520]}}">{{item}}</view>    [1,2,3,4,520]
<view wx:for="{{...arg1, arg2}}">{{item}}</view>  {a:1,b:2,c:3}
```



##### 列表渲染

在组件上使用 wx:for 控制属性绑定一个数组, 就可以使用数组各项数据重复渲染该组件

默认数组的当前的下标变量名 index, 数组当前项变量名为 item

```html
//	wxml
<view wx:for="{{message}}">{{item}}</view>

//	page.js
data:{message: [1,2,3,4,5,20]}
```

使用 wx:for-item 可以指定数组当前元素变量名

使用 wx:for-index 可以指定数组当前下标变量名

```html
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
    {{idx}}: {{itemName.message}}
</view>
```

###### block wx:for

类似 block wx:if , 可以将 wx:for 用在 <block/> 标签上, 一渲染一个包含多节点的结构块

```html
<block wx:for="{{[1,2,3]}}">
    <view>{{index}}</view> -- <view>{{item}}</view>
</block>
```

###### wx:key

如果列表中项目的位置会动态改变或者有新的项目添加到列表中, 并且希望列表中的项目保持自己的特征和状态(如 <input> 中的输入内容, <switch> 中的选中状态, 需要指定列表中的唯一标识符

wx:key 的值以两种形式提供

1. 字符串, 代表在 for 循环的 array 中 item 的某个 property, 该 property 的值需要是列表中唯一的字符串和数字, 且不能动态改变.
2. 保留关键字 *this 代表在 for 循环中的 item 本身, 这种表示需要 item 本身是一个唯一的字符串或者数字

当数据改变触发渲染层重新渲染的时候, 会校正带有 key 的组件, 框架会确保他们被重新排序, 而不是重新创建, 以确保使组件保持自身状态, 并且提高列表渲染时的效率

##### 条件渲染

`wx:if`

在框架中, 使用  `wx:if="{{condition}}"` 来判断是否渲染代码块

`wx:elif` 和 `wx:else` 来添加一个  else 块

```html
//	wxml
<view wx:if="{{view == 'WEBVIEW'}}">WEBVIEW</view>
<view wx:elif="{{view == 'APP'}}">APP</view>
<view wx:else>MINA</view>

// page.js
data: {view: 'MINA'}
```

###### block wx:if

因为 `wx:if` 是一个控制属性, 需要将它添加到一个标签上. 如果哟啊一次性地判断多个组件标签, 可以使用一个 <block /> 标签将多个组件包装起来, 并在上边使用 `wx:if` 控制属性

```html
<block wx:if="{{flag}}">
    <view>view1</view>
    <view>view2</view>
</block>
```

注意: <block/> 并不是一个组件, 它仅仅是一个包装元素, 不会在页面中做任何渲染, 只接受控制属性.

###### wx:if VS hidden

1. 因为 wx:if 之中的模板也可能包含数据绑定, 所以当 wx:if 的条件值切换时, 框架有一个局部渲染的过程, 因为他会确保条件块在切换时销毁或者重新渲染
2. 同时 wx:if 有惰性的, 如果在初始渲染条件为false, 框架什么也不做, 在条件第一次变成真的时候才开始局部渲染
3. 相比之下, hidden 就简单多了, 组件始终会被渲染, 只是简单的控制显示与隐藏
4. 一般来说, wx:if 有更高的切换消耗而 hidden 有更高的渲染消耗, 因此如果需要频繁切换情景下, 用hidden更好, 如果在运行时条件不大, 可能改变则 wx:if 较好

##### 模板

WXML 提供模板 (template), 可以在模板中定义代码片段, 然后在不同的地方调用.

**定义模板**

使用 name 属性, 作为模板的名字. 然后在 <template/> 内定义代码片段, 如下

```html
<template name="msgItem">
	<text>{{index}} : {{msg}}</text>
    <text>{{time}}</text>
</template>
```

**使用模板**

使用 is 属性, 声明需要的使用的模板, 然后将模板所需要的 data 传入, 如

```html
<template is="mgsItem" data="{{...iten}}" />
<!--
data : {
	iten:{
		index: 0,
		msg: '数据',
		time: '2016-09-15'
	}
}
-->
```

is 属性可以使用插值表达式, 来动态决定渲染哪个模板

```html
<template name="odd">
    <view>odd</view>
</template>
<template name="even">
    <view>even</view>
</template>

<block wx:for="{{[1, 2, 3, 4, 5]}}">
    <template is="{{item % 2 == 0 ? 'even' : 'odd'}}" />
</block>
```

**模板作用域**

模板拥有自己的作用域, 只能使用 data传入数据以及模板定义文件中的 <wxs /> 模块

```html
<!--wxml-->
<template name="staffName">
  <view>FirstName: {{firstName}}, LastName: {{lastName}}</view>
</template>

<template is="staffName" data="{{...staffA}}"></template>
<template is="staffName" data="{{...staffB}}"></template>
<template is="staffName" data="{{...staffC}}"></template>

// page.js
Page({
    data: {
        staffA: {firstName: 'Hulk', lastName: 'Hu'},
        staffB: {firstName: 'Shang', lastName: 'You'},
        staffC: {firstName: 'Gideon', lastName: 'Lin'}
    }
})
```

##### 事件

- 事件是视图层到逻辑层的通讯方式
- 事件可以将用户的行为反馈到逻辑层进行处理
- 事件可以绑定到在组件上, 当达到触发事件, 就会执行逻辑层中对应的处理函数
- 事件对象可以携带额外信息

**事件的使用方式**

- 组件中绑定一个事件处理函数
- 如 bandtap, 当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数.
- 在相应的 Page 定义中写上相应的事件处理函数, 参数 event

```html
<view bindtap="add">{{count}}</view>
<!-- page.js
    data: {
        count: 1
    },
    add(e) {
		console.log(e)
         this.setData({
            count: this.data.count + 1
         })
    }
-->
```

###### 事件详情

事件分为冒泡事件和非冒泡事件

**WXML 的冒泡事件列表**

- touchstart  手指触摸动作开始
- touchmove 手指触摸后移动
- touchcancel 手指触摸动作被打断, 如来电
- touchend 手指触摸动作结束
- tap 手指触摸后马上离开
- longpress 手触摸后, 超过 350 ms 再离开, 如果指定了事件回调函数并触发了这个事件, tap 事件将不被触发
- transitionend 在 WXSS transition 或  wx.createAnimation 动画结束后触发
- animationstart 在 一个 WXSS animation 动画开始时触发
- animationiteration 在一个 WXSS animation 一次迭代结束时触发
- animationend 在 WXSS animation 动画完成时触发

除上述之外其他组件自定义事件, 如无特殊情况都是非冒泡事件.

- <form /> 的 submit 事件
- <input /> 的 input 事件
- <scroll-view /> 的 scroll 事件

**事件绑定和冒泡**

事件绑定写法同组件的属性, 以 key, value 的形式

- key 以 bind 或 catch 开头, 然后跟上事件类型, 如 bindtap, catchtouchstart. 非原生组件中, bind 和 catch 后可以紧跟一个冒号, 其含义不变, 如 bind:tap, catch:touchstart
- value 是一个字符串, 需要对应 Page 中定义的同名函数

bind 事件绑定不会阻止事件向上冒泡, catch 事件绑定可以阻止冒泡事件向上冒泡

**事件捕获阶段**

触摸类事件支持捕获阶段, 捕获阶段位于冒泡阶段之前, 在捕获阶段中, 事件达到节点的顺序与冒泡阶段恰好相反, 需要在捕获阶段监听事件时. 可以采用 capture-bind  capture-catch 关键字, 后者将中断捕获阶段和取消冒泡阶段

##### 引用

WXML 提供两种文件引用方式 import 和 include

###### import

import 可以在该文件中使用目标文件定义的 template

在 item.wxml 中定义一个叫 item 的 template

```html
<!-- item.wxml -->
<template name="item">
    <text>{{text}}</text>
</template>
```

在 index.wxml  中引用 item.wxml, 就可以使用 item 模板

```html
<import src="item.wxml" />
<template is="item" data="{{text:'foorbar'}}" />
```

**import 的作用域**

import 有作用域的概念, 即只会 import 目标文件中定义的 template, 而不会 import 目标文件中 import 的template

###### include

include 可以将目标文件除了 <template /> <wxs /> 外整个代码引入. 相当于拷贝到 include 位置

### WXSS

wxss 时一套样式语言, 用于描述 wxml 的组件样式.

wxss 用来决定 wxml 的组件如何显示

为了适应广大前端开发者, wxss 具有css大部分的特性, 同时为了更适合开发微信小程序, wxss 对 css 进行了扩充以及修改, 与 css 相比 , wxss 扩展的特性有

- 尺寸单位
- 样式导入

##### **尺寸单位**

rpx(responsive pixel) 可以根据屏幕宽度进行自适应. 规定屏幕为 750rpx. 如在 iPhone6 上, 屏幕宽度为 375px, 共有 750 个物理像素, 则 750rpx = 375px = 750物理像素,  1rpx= 0.5px = 1 物理像素

建议: 开发微信小程序时, 设计师可以用 IPhone6 作为视觉稿的标准

##### **样式导入**

使用 @import 语句可以导入外联样式表, @import 后跟需要导入的外联样式表的相对路径, 用 ; 表示语句结束

内联样式

框架上支持使用 style, class 属性来控制的样式

- style: 静态的样式统一写到 class 中, style 接收动态的样式, 在运行时会进行解析, 避免将静态样式写进style中, 影响渲染速度
- class: 用于指定样式规则, 其属性值是样式规则中类选择器名的集合

##### **全局样式与局部样式**

定义在 app.wxss 中的样式为全局样式, 作用于每个页面, 在 page 的 wxss 中定义的样式为局部样式, 只作用在对应的页面, 并会覆盖 app.wxss 中相同的选择器

##### **公共属性**

偶有组件都有以下属性

- id 组件唯一标识
- class 组件的样式类
- style 组件的内联样式
- hidden 组件是否显示
- data-* 组件上触发的事件时, 会发送给事件处理函数
- bind*/catch\* 组件的事件

##### **特殊属性**

几乎所有组件都有各自定义的属性, 可以对该组件的功能或样式进行修饰

###  WXS

WXS(WeiXin Script) 是小程序的一套脚本语言, 结合WXML 可以构建出页面结构

注意

1. wxs 不依赖于运行时基础库版本, 可以在所有版本的小程序中运行.
2. wxs 与 javascript 是不同的语言, 有自己的语法, 并不和 javascript 一致.
3. wxs 的运行环境和其他 javascript 代码是隔离的, wxs 中不能调用其他 javascript 中定义的函数, 也不能调用小程序的 API 
4. wxs 函数不能作为组件的事件回调.
5. 由于运行环境的差异, 在 IOS 设备上小程序内的 wxs 会比 javascript 代码快 2~20 倍. 在 android 设备上二者运行效率无差异

**页面渲染**

```html
<wxs module="m1">
    var msg = "hello world"; 
    module.exports.message=msg;
</wxs>
<view>{{m1.message}}</view>	<!--页面输出 hello world-->
```

##### 模块

WXS 代码可以编写在 wxml 文件中的 <wxs> 标签内, 或以 `.wxs` 为后缀名的文件内

每一个 `.wxs` 文件和 <wxs> 标签都是一个单独的模块

每个模块都有自己独立的作用域, 即在一个模块里面定义的变量与函数, 默认为私有的, 对其他模块不可见.

一个模块要想对外暴露其内部私有变量与函数, 只能通过 module.exports 实现.

**.wxs 文件**

在维修开发者工具里面, 右键可以直接创建 .wxs 文件, 在其中直接编写 WXS 脚本

```js
//	comm.wxs
var foo = "hello world"
var bar = function(d){
    return d;
}
module.exports = {
    foo:foo,
    bar:bar
}
```

上述 comm.wxs 的文件里面编写了 WXS 代码, 该 .wxs 文件可以被其他的 .wxs 文件或 WXML 中的 <wxs> 标签引用.

每一个 wxs 模块均有一个内置的 module 对象

属性 exports , 通过该属性, 可以对外共享本模块的私有变量与函数

```jsx
//	tools.wxs
var foo = "hello world"
var bar = function(d){
    return d;
}
module.exports = {
    foo:foo,
    bar:bar
}
module.exports.msg = "some msg"
```

```html
<wxs src = "tools.wxs" module="tools" />
<view>{{tools.msg}}</view>	<!-- some msg -->
<view>{{tools.bar(tools.foo)}}</view> <!-- hello world -->
```

**require 函数**

在 .wxs 模块中引用其它 wxs 文件模块, 可以使用 require 函数.

- 只能引用 .wxs 文件模块, 且必须使用相对路径
- wxs 模块均为单例, wxs 模块在第一次被引用时, 会自动初始化为单例对象. 多个页面, 多个地方, 多个引用, 使用的都是同一个 wxs 模块对象
- 如果一个 wxs 模块在定义之后, 一切没有被引用, 则该模块不会被解析与运行.

**<wxs> 标签**

- module  当前 <wxs> 标签的模块名, 必填字段.
- src 引用 .wxs 文件的相对路径, 仅当本标签为 闭合标签或标签的内容为空时有效.

module 属性

module 属性是当前 <wxs> 标签的模块名, 在单个 wxml 文件内, 建议其值唯一. 有重复模块名则先后顺序覆盖. 不同文件之间 module 属性值得命名必须符合以下规则

- 首字母必须是 ( a-zA-Z ), 下划线 ( _ )
- 剩余字符可以是: 字母( a-zA-Z ), 下划线 ( _ ) , 数字 ( 0-9 )

**src 属性**

src 属性可以用来引用其它的 wxs 文件模块

- 只能引用 .wxs 模块, 且必须使用相对路径
- wxs 模块均为单例, wxs 模块在第一次被引用的时候, 会自动初始化为单例, 多个页面, 多个地方, 多次引用, 使用的都是同一个 wxs 模块对象
- 如果一个 wxs 模块在定义之后, 一直没有被引用, 则该模块不会被解析与运行

注意: 

1. <wxs> 模块只能在被定义模块的 WXML 文件中被访问到. 使用 <include> 或  <import> 时, <wxs>模块不会被引入到对应的 WXML 文件中.
2. <template> 标签中, 只能使用该 <template> 的 WXML 文件中定义的 <wxs> 模块

##### 变量

- wxs 中的变量均为值得引用
- 没有声明的变量直接赋值使用, 会被定位全局变量
- 如果只声明变量而不赋值, 则默认值为 undefined
- var 表现与 javascript 一致, 会有变量提升

##### 注释

- //
- /**/
- /* 

# mpVue
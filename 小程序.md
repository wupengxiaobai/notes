# 微信小程序

### 基本应用

**微信小程序(应用)**

- 结构 wxml

  - 遵循XML语法
  - 常用标签
    - <view> 类似 <div>
    - <text> 类似 <span>
    - <image> 类似 <img>
      - 图片在开发小程序项目的时候
        - 图片需要设置宽高(有默认宽高)
        - 图片需要设置缩放模式 mode='aspectFill'
    - <navigator> 类似 <a>
  - 常用组件 
    - swiper

- 样式 wxss

  - 尺寸单位	rpx (基于750分辨率自动计算)
  - 样式导入 `import "xxx.wxss"`

- 行为 js 

  - ECMAScript

  - wx对象(微信小程序封装的顶级对象)

    注意: 微信小程序里面没有 DOM 和 BOM 的概念

- 配置 json

  - 非常严格的 json 格式

  - **app.json 全局配置**

    - pages 配置路由

    - window 配置头部
    - tabBar 底部选项卡

**组件组成基本**

![1543578741889](.\wx\1543578741889.png)

#### wxml 高级

**数据绑定  `{{}}`**

```html
<!-- wxml -->
<view>{{message}}</view>
```

```js
//	page.js
Page({
    data: {
        message: "Hello wx!"
    }
})
```

**特别注意: **

1. 花括号和引号之间不能有空格
2. 不要直接写 checked="false", 其计算结果是一个字符串, 转成 boolean 类型后代表真值, 需要使用插值表达式来进行判断

```xml
<checkbox checked="{{false}}"></checkbox>
```

**列表渲染 wx:for='{{}}'**

```xml
<!-- wxml --> 
<view wx:for="{{array}}" wx:key="{{item.id}}">{{item}}</view>
```

```js
//	page.js
Page({
    data: {
        array: [1, 2, 3, 4, 520]
    }
})
```

**注意: 如果是多层嵌套情况, 使用  wx:for-item='xxx' 指定被遍历的每个item**

**流程判断 wx:if='{{}}'**

```xml
<!-- wxml --> 
<view wx:if="{{array}}">if</view>
<view wx:else="{{array}}">else</view>
```

**流程判断2 hidden="{{}}"**

**xml 中书写 js 代码**

```xml
<!-- wxml -->
<wxs module='foo'>
    //	这里可导出一个对象, 这个对象可以直接在界面上使用
    module.exports = {
            sum: function(a, b){
            return a + b;
        }
    }
</wxs>
<view>{{foo.sum(1,2)}}</view>
```

#### wxss 常用

```css
/* 箭头 */
.jiantou::after {
  content: '';
  position: absolute;
  top: 50%;
  right: 50rpx;
  width: 14.5rpx;
  height: 14.5rpx;
  transform: rotate(45deg) translateY(-50%);
  border: 1px solid #333;
  border-left-width: 0;
  border-bottom-width: 0;
}

/*单行省略*/
.text-over {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}


/* 透明下边框 */
.no-bt {
  border-color: transparent !important;
}
```



#### 行为 js 文件

```js
/*
	此处可以是用来模块的引入和函数的封装
*/

Page({
    /**
   * 页面的初始数据
   */
    data: {},
    /**
   * 生命周期函数--监听页面加载
   */
    onLoad: function (options) {
        //	options.scene 可以识别用户通过什么方式进入我们的小程序
        //	我们需要请求过的数据, 在该生命周期进行请求相对合适
        //	使用 wx.require() 请求数据
        wx.request({
            url: 'https://locally.uieee.com/slides',
            data: '',
            header: {},
            method: 'GET',
            dataType: 'json',
            success: function(res) {},
            fail: function(res) {},
            complete: function(res) {},
        });
    },
    /**
   * 生命周期函数--监听页面初次渲染完成
   */
    onReady: function () {},
    /**
   * 生命周期函数--监听页面显示
   */
    onShow: function () {},
    /**
   * 生命周期函数--监听页面隐藏
   */
    onHide: function () {},
    /**
   * 生命周期函数--监听页面卸载
   */
    onUnload: function () {},
    /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
    onPullDownRefresh: function () {},
    /**
   * 页面上拉触底事件的处理函数
   */
    onReachBottom: function () {},
    /**
   * 用户点击右上角分享
   */
    onShareAppMessage: function () {}
})
```

##### **事件绑定和冒泡**

1. 冒泡事件 bind 事件类型 如 `bindtap` `bindlongpress`
2. 非冒泡事件 catch 事件类型 如 `catchtap` `catchlongpress`

**常用事件类型**

| 类型      | 触发条件                     |
| --------- | ---------------------------- |
| tap       | 手指触摸后马上离开           |
| longpress | 手指触摸后, 超过 350ms再离开 |



### 常用组件

#### 视图容器

##### View

|                        | 类型    | 默认值 | 说明                                                         |
| ---------------------- | ------- | ------ | ------------------------------------------------------------ |
| hover-class            | String  | none   | 指定按下(view)去的样式类, 当hover-class="none"时,没有点击效果 |
| hover-stop-propagation | Boolean | flase  | 指定是否组织本节点的祖先节点出现点击状态                     |
| hover-start-time       | Number  | 50     | 按住后多久出现点击状态, 单位毫秒                             |
| hover-stay-time        | Number  | 400    | 手指松开后点击状态保留时间, 单位毫秒                         |

##### scroll-view

| 属性              | 类型          | 默认值 | 说明                                                         |
| ----------------- | ------------- | ------ | ------------------------------------------------------------ |
| scroll-x/scroll-y | Boolean       | false  | 允许 横向/纵向 滚动                                          |
| upper-threshold   | Number/String | 50     | 设置距离顶部/左边多远时 触发 scrolltoupper 事件              |
| lower-threshold   | Number/String | 50     | 设置距离底部/右边多远时 触发 scrolltolower 事件              |
| bindscrolltoupper | EventHandle   |        | 滚动到顶部/左边, 会触发 scrolltoupper事件                    |
| bindscrolltolower | EventHandle   |        | 滚动到底部/右边, 会触发 scrolltlower                         |
| bindscroll        | EventHandle   |        | 滚动触发, event.detail={scrollLeft,scrollTop,scrollHeight,scrollWdith,deltaX,deltaY} |

![1544002774295](.\wx\1544002774295.png)

#### 基础内容

##### icon图标

| 属性名 | 类型          | 默认值 | 说明                                                         |
| ------ | ------------- | ------ | ------------------------------------------------------------ |
| type   | String        |        | icon的类型, 有效值: success, success_no_circle, info, warn, waiting, cancel, download, search, clear |
| size   | Number/String | 23px   | icon大小                                                     |
| color  | Color         |        | icon的颜色, 同css的color                                     |

##### text 组件

| 属性名     | 类型    | 默认值 | 说明                                                         |
| ---------- | ------- | ------ | ------------------------------------------------------------ |
| selectable | Boolean | false  | 文本是否可选                                                 |
| space      | String  | false  | 显示连续空格 有效值: ensp(中文字符空格一般大小),nbsp(根据字体设置的空格带小), emsp(中文字符空格大小) |
| decode     | Boolean | false  | 是否解码                                                     |

##### progress 进度条

| 属性            | 类型        | 默认值    | 说明                                                  |
| --------------- | ----------- | --------- | ----------------------------------------------------- |
| percent         | Float       |           | 百分比0~100                                           |
| show-info       | Boolean     | false     | 进度条右侧显示百分比                                  |
| border-radius   | Number      | 0         | 圆角大小                                              |
| font-size       | Number      | 16        | 右侧百分比字体大小                                    |
| stroke-width    | Number      | 6         | 进度条线的宽度                                        |
| color           | Color       | #09bb7    | 进度条颜色(请使用 activeColor)                        |
| activeColor     | Color       |           | 已选择的进度条的颜色                                  |
| backgroundColor | Color       |           | 未选择的进度条颜色                                    |
| active          | Boolean     | false     | 进度条从左往右的动画                                  |
| active-mode     | String      | backwards | backwards:动画从头播; forwards:动画从上次结束点接着播 |
| bindactiveend   | EventHandle |           | 动画完成事件                                          |

**注意: 在 mpVue 中使用进度条外包一个div**, 控制大小

#### 表单组件

```xml
<!--常用表单-->
<input type='text'>常用表单</input>

<!--复选框/组-->
<checkbox>复选框</checkbox>
<checkbox-group bindchange="checkboxHandler" data-参数名='参数值'>
    <!--给checkbox组添加修改事件, 并使用 data-参数名='参数值' 进行参数传递 -->
    <checkbox checked>撸码</checkbox>
    <checkbox>做菜</checkbox>
</checkbox-group>

<!--单选框/组-->
<radio>单选框</radio>
<radio-group>
    <radio checked value='male'>男</radio>
    <radio value='female'>女</radio>
    <radio disabled>保密</radio>
</radio-group>

<switch checked></switch>
```

**input的一些属性**

| 属性                                 | 类型        | 默认值 | 说明                                                         |
| ------------------------------------ | ----------- | ------ | ------------------------------------------------------------ |
| type                                 | String      | text   | 有效值: text/number/idcart/digit                             |
| password                             | Boolean     | false  | 是否为密码类型                                               |
| placeholder/placeholder-style(class) | String      |        | 输入款为空时占位符/占位符样式(样式类)                        |
| focus                                | Boolean     | false  | 自动焦点                                                     |
| auto-focus                           | Boolean     | false  | (讲讲废弃, 直接使用 focus) 自动聚焦, 拉起键盘                |
| bindinput                            | EventHandle |        | 键盘输入时触发 event.detail = {value, cursor, keyCode}，keyCode 为键值 |
| bindFocus                            | EventHandle |        | 输入框聚焦时触发                                             |
| bindblur                             | EventHandle |        | 输入款失去焦点时触发                                         |
| bindconfirm                          | EventHandle |        | 点击完成按钮时触发                                           |

```js
//	事件接收参数
checkboxHandler(e){
	console.log(e.detail);	//	获取表单值
    console.log(e.target.dataset['参数名']);	//	获取传递参数值
}
```

**mpVue中复选等**

![1544110339097](.\wx\1544110339097.png)

##### picker

支持五种选择器，通过mode来区分，分别是普通选择器，多列选择器，时间选择器，日期选择器，省市区选择器，默认是普通选择器。

**普通选择器: mode = selector**

| 属性名     | 类型               | 默认值 | 说明                                                         |
| ---------- | ------------------ | ------ | ------------------------------------------------------------ |
| range      | Array/Object Array | []     | mode 为 selector 或 multiSelector时, range 有效              |
| range-key  | String             |        | 当 range 是一个 Object Array 时, 通过 range-key 来选择器默认显示内容 |
| value      | Number             | 0      | 默认选择 range 中的第几个(下标0开始)                         |
| disabled   | Boolean            | false  | 是否禁用                                                     |
| bindchange | EventHandle        |        | value 改变时触发 change 事件, 通过 event.mp.detail.value/event.target/value 获取选择项对应索引 |
| bindcancel | EventHandle        |        | 取消选择或点遮罩层收齐 picker 时触发                         |

**多列选择器 mode = multiSelector**

| 属性名           | 类型                  | 默认值 | 说明                                                         |
| ---------------- | --------------------- | ------ | ------------------------------------------------------------ |
| range            | 二维数组/二维对象数组 | []     | 数组的每项表示每列的数据如[['a','b'],['c','d']]              |
| range-key        | String                |        | 当 range 是二维 Object Array时, 通过 range-key 来指定 Object 中 key 的值作为选择器显示内容 |
| value            | Array                 | []     | 每一项表示选择了 range 对应项中的第几个                      |
| bindchange       | EventHandle           |        | value 改变触发 cahnge 事件                                   |
| bindcolumnchange | EventHandle           |        | 某一列的值改变时触发 columnchange 事件                       |
| bindcancel       | EventHandle           |        | 取消选择时触发                                               |

**时间选择器: model = time**

**日期选择器: mode = date**

**省市区选择器: model=region**

注意: 在修改显示内容的时候要修改整个数组(使用setData)才能达到界面数据同时更新的效果

##### button

[参考](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)

| 属性      | 类型    | 默认值  | 说明                                                   |
| --------- | ------- | ------- | ------------------------------------------------------ |
| type      | String  | default | default/primary/warn 只有defalut时才可以设置背景的颜色 |
| plain     | Boolean | false   | 按钮是否镂空, 背景色透明                               |
| loading   | Boolean | false   | 文字前是否带 loading 图标                              |
| open-type | String  |         | 微信开放能力(转发)                                     |
| disabled  | Boolean | false   | 是否禁止选中                                           |



#### swiper组件

```html
<swiper indicator-dots="{{indicatorDots}}"
  autoplay="{{autoplay}}" interval="{{interval}}" duration="{{duration}}">
  <block wx:for="{{imgUrls}}">
    <swiper-item>
      <image src="{{item}}" class="slide-image" width="355" height="150"/>
    </swiper-item>
  </block>
</swiper>
<button bindtap="changeIndicatorDots"> indicator-dots </button>
<button bindtap="changeAutoplay"> autoplay </button>
<slider bindchange="intervalChange" show-value min="500" max="2000"/> interval
<slider bindchange="durationChange" show-value min="1000" max="10000"/> duration
```



#### tabBar组件

属性说明: 

| 属性            | 类型     | 是否必填 | 默认值 | 描述                            |
| --------------- | -------- | -------- | ------ | ------------------------------- |
| color           | HexColor | 是       |        | tab 上的文字默认颜色            |
| selectedColor   | HexColor | 是       |        | tab上的文字选中时颜色           |
| backgroundColor | HexColor | 是       |        | tab 的背景色                    |
| borderStyle     | String   | 否       | black  | tabber上边款的颜色(black/white) |
| list            | Array    | 是       |        | tab的列表, 至少2个, 最多5个     |
| position        | String   | 否       | bootom | 可选值 bottom, top(无图标)      |

其中 list 接受一个数组, 数组中的每个项都是一个对象, 属性值如下

| 属性             | 类型   | 是否必填 | 说明                                                         |
| ---------------- | ------ | -------- | ------------------------------------------------------------ |
| pagePath         | String | 是       | 页面路径, 必须在pages中先定义                                |
| text             | String | 是       | tab上按钮文字                                                |
| iconPath         | String | 否       | 图片路径, icon 大小限制为40kb, 建议尺寸81px*81px(position 为 top时,该参数无效) |
| selectedIconPath | String | 否       | 选中时图片路径, 其它说明如上iconPath相同                     |



### 常用 API

#### 本地存储

- **设置本地存储** 

  - 同步设置 **`wx.setStorageSync(string key, Object data)`**

  - 异步设置 **`wx.setStorage(Object object)`**

    ```js
        wx.setStorage({
            key:"key",
            data:"value"
        })
    
        try {
            wx.setStorageSync('key', 'value')
        } catch (e) {}
    ```

- **获取本地存储** 

  - 异步获取 **`wx.getStorage(Object object)`** 

  - 同步获取 **`wx.getStorageSync(String)`**

    ```js
    wx.getStorage({
        key: 'key',
        success (res) {
            console.log(res.data)
        }
    })
    ```

#### 用户授权

**获取用户信息**

- **wx.getUserInfo()** 获取用户信息(调用前需要用户授权)

- 用户授权使用 button 组件 `<button open-type="getUserInfo" bindgetuserinfo="onGotUserInfo">获取用户信息</button>`

  mpVue 中授权演示如下: 

  ```html
  <button open-type="getUserInfo" @getuserinfo="handleGetUserInfo">授权登录</button>
  ```

  ```js
  handleGetUserInfo() {
      let _this = this;
      wx.getUserInfo({
          success(data) {	//	授权成功
              if (data.rawData) {
                  _this.isShow = true;
                  _this.userInfo = data.userInfo;
              }
          },
          fail(data) {	//	授权失败
              wx.showToast(
                  {
                      title: "授权失败",
                      icon: "none"
                  },
                  1500
              );
              _this.isShow = false;
          }
      });
  }
  ```

#### 加载动画

**头部加载动画**

- **wx.showNavigationBarLoading(Object object)** 开始

- **wx.hideNavigationBarLoading(Object object)** 关闭

**提示框加载动画**

- **wx.showLoading(Object object)**	开启
- **wx.hideLoading(Object object)**     关闭

**提示框**

- **wx.showToast(Object object)** 
- **wx.hideToast(Object object)**

#### **下拉事件监听**

- **wx.startPullDownRefresh(Object object)** 开启(或者 window 配置 enablePullDownRefresh 为true即可)
- **wx.stopPullDownRefresh(Object object)** 关闭

#### 媒体相关

#### 背景音乐

- 音乐播放 **`wx.playBackgroundAudio(Object object)`**
- 音乐暂停 **`wx.pauseBackgroundAudio(Object object)`**

**音乐播放/暂停监听**

- 监听音乐播放 **`wx.onBackgroundAudioPlay(function callback)`**
- 监听音乐暂停 **`wx.onBackgroundAudioPause(function callback)`**
- 监听音乐停止 **`wx.onBackgroundAudioStop(function callback)`**

#### 显示操作菜单

- **wx.showActionSheet(Object object)**

| 属性      | 类型     | 默认值 | 描述                            |
| --------- | -------- | ------ | ------------------------------- |
| itemList  | Array    |        | 按钮的文字数组, 数组长度最大为6 |
| success   | function |        | 接口调用成功的回调函数          |
| fail      | function |        | 接口调用失败的回调函数          |
| itemColor | string   |        | 按钮文字颜色                    |

**object.success** 参数

| 属性     | 类型   | 说明                                  |
| -------- | ------ | ------------------------------------- |
| tapIndex | number | 用户点击的按钮序号, 从上到下, 从0开始 |

```js
wx.showActionSheet({
    itemList: ['A', 'B', 'C'],
    success (res) {
        console.log(res.tapIndex)
    },
    fail (res) {
        console.log(res.errMsg)
    }
})
```

#### 上传/下载

**下载** 

`wx.downloadFile(Object object)`

| 属性     | 类型     | 说明                                        |
| -------- | -------- | ------------------------------------------- |
| url      | string   | 下载资源的url(必填)                         |
| header   | Object   | HTTP请求的 Header, Header中不能设置 Referer |
| filePath | string   | 指定文件下载后存储的路径                    |
| success  | function | 成功回调                                    |
| fail     | function | 失败回调                                    |

**object.success 回调函数参数**

| tempFilePath | 临时文件路径, 如果没有传入filePatch 指定临时文件, 则下载后的文件会存储到一个临时文件 |
| ------------ | ------------------------------------------------------------ |
| statusCode   | 开发者服务区返回的 HTTP 状态码                               |

**返回值**

`DownloadTask`	 一个可以监听下载进度变化的事件

**上传相关**

**chooseImage** 接口获取到一个本地资源的临时文件路径后, 可以通过此接口将本地资源上传到指定服务器.

| count      | number   | 9                          | 最多可以选择的图片张数             |
| ---------- | -------- | -------------------------- | ---------------------------------- |
| sizeType   | Array    | ['original', 'compressed'] | 所选图片尺寸(原图/压缩图)          |
| sourceType | Array    | ['album', 'camera']        | 所选图片来源(从相册选图, 使用相机) |
| success    | function |                            | 成功回调                           |

success 回调参数

| tempFilePaths | Array | 图片的本地临时文件路径列表 |
| ------------- | ----- | -------------------------- |
| tempFiles     | Array | 图片的本地临时文件列表     |



**uploadFile(Object)** 文件上传 将本地资源上传到开发者服务器,. 客户端发起一个 HTTPS POST请求, 其中 content-type为 multipart/form-data

| url      | String   | 必须 | 开发者服务器url                                              |
| -------- | -------- | ---- | ------------------------------------------------------------ |
| filePath | String   | 必须 | 要上传你文件资源的路径                                       |
| name     | String   | 必须 | 文件对应的 key, 开发者在服务器端通过key可以获取到文件的二进制内容 |
| header   | Object   |      | HTTP 请求 Header, header 中不能设置 Refere                   |
| success  | Function |      | 接口调用成功的回调函数                                       |

```js
wx.chooseImage({
    count: 9,
    sizeType: ["original", "compressed"], //  尺寸
    sourceType: ["album", "camera"], //  来源
    success: res => {
        let [tempFilePaths, tempFiles] = [res.tempFilePaths, res.tempFiles];
        this.uploadImageArr = this.uploadImageArr.concat(tempFilePaths);	
        //  tempFilePaths 就是本地存储图片的临时路径, 此处做保存, 用于方便遍历显示到界面上

        //  执行上传值服务端
        /* const uploadTask = wx.uploadFile({
            url: "http://example.weixin.qq.com/upload", // 仅为示例，非真实的接口地址
            filePath: tempFilePaths[0],
            name: "file",
            formData: {
              user: "test"
            },
            success(res) {
              const data = res.data;	//	服务器返回的数据
              const statusCode = res.statusCode	//	服务器返回http状态码
              // do something
            }
          });
          uploadTask.onProgressUpdate(res => {
            console.log("上传进度", res.progress);
            console.log("已经上传的数据长度", res.totalBytesSent);
            console.log(
              "预期需要上传的数据总长度",
              res.totalBytesExpectedToSend
            );
          }); */
    },
    fail() {}
});
```

### 常用封装

#### js的封装

**请求的封装**

```js
//  请求封装
module.exports = function(url, method, data) {
  return new Promise((resolve, reject) => {
    wx.request({
      url: url,
      data: data,
      method: method,
      header: {
        "Content-Type": 'json'
      },
      dataType: 'json',
      success: resolve,
      fail: reject
    })
  })
}
```

#### css 封装

```css

```



# 小程序API*

## 基础

### wx.canIUse(string schema)

判断小程序的API, 回调,参数,组件等是否在当前版本可用

- `${API}.${method}.${param}.${options}` 或者 `${component}.${attribute}.${option}` 

  参数说明:  

  - ${API} 代表 API 名字

  - ${method} 代表调用方式, 有效值为 return, success, object, callback

  - $(param) 代表参数或者返回值
  - ${options} 代表参数的可选值

  - ${component} 代表组件名字

  - ${attribute} 代表组件熟悉

  - ${option} 代表组件熟悉的可选值

  示例  `wx.canIUse('showToast.object.image')`

###系统

##### wx.getSystemInfoSync

##### wx.getSystemInfo

获取客户端系统信息, 返回值如下

| brand/model              | string | 手机品牌/型号     |
| ------------------------ | ------ | ----------------- |
| pixelRatio               | number | 设备像素比        |
| screenWidth/screenHeight | number | 屏幕宽度/高度     |
| windowWidth/windowHeight | number | 可使用窗口宽/高度 |
| language                 | string | 微信设置的语言    |
| version                  | string | 微信版本号        |
| system                   | string | 操作系统版本      |
| platform                 | string | 客户端平台        |

### 更新

##### wx.getUpdateManager()

获取**全局唯一**的版本更新管理器，用于管理小程序更新

##### UpdateManager

用来管理更新, 可以通过 wx.getUpdateManager 接口获取实例

方法如下: 

 -	UpdateManager.applyUpdate() 强制小程序重启并使用新版本.  下载完成(onUpdateReady 回调) 调用
	-	UpdateManager.onCheckForUpdate(callback) 监听像微信后台请求检查更新结果事件. 小程序启动时自动检查更新, 无需主动调用
			UpdateManager.onUpdateReady(callback) 小程序下载成功后回调
		UpdateManager.onUpdateFailed(callback) 小程序更新失败回调

```js
//  更新唯一凭证
let updateManager = wx.getUpdateManager()
// 查看是否有新版本
updateManager.onCheckForUpdate((res) => {
    console.log(res.hasUpdate)
})
//  有新版本则自动触发
updateManager.onUpdateReady(() => {
    wx.showModel({
        title: '更新提示',
        content: '新版本已准备哈, 是否重启',
        success(res) {
            if (res.confirm) {
                //  强制小程序重启使用新版
                updateManager.applyUpdate()
            }
        }
    })
})
//  更新失败回调
updateManager.onUpdateFailed(function() {
    console.log('更新失败')
})
```

### 小程序

#### 生命周期 

###### wx.getLaunchOptionsSync

获取小程序启动时的参数, 返回值 Object(启动参数)

| path         | string | 启动小程序的路径                                             |
| ------------ | ------ | ------------------------------------------------------------ |
| scene        | number | 启动小程序的场景值(1020 公众号profile页相关小程序列表, 1035公招自定义菜单, 1036 App分享卡片, 1037小程序打开小程序, 1038 从另一个小程序返回, 1043 公众号模板消息) |
| query        | Object | 启动小程序的 query 参数                                      |
| shareTicket  | string |                                                              |
| referrerInfo | Object | 来源信息. 从另一个小程序, 公众号或 App进入小程序时返回. 否则为 {} (appId 来源的 appId; extraData 来源的小程序传来的数据, scene=1037/1038时支持) |

#### 应用级别事件

###### wx.offPageNotFound(callback)

取消监听小程序要打开的页面不存在事件

callback 打开的页面不存在事件的回调函数

###### wx.onPageNotFound(callback)

监听小程序要打开页面不存在事件

callback 小程序打开的页面不存在事件的回调函数

**注意: 我们可以在回调中使用页面重定向, 但是必须在回调中同步处理**

###### wx.offError(callback)

取消监听小程序错误事件, callback 错误事件的回调

###### wx.onError(callback)

监听小程序错误事件. 如脚本错误或 API 调用报错等. 改时间与 App.onError 的回调时机与参数一致

callback 回调函数, 参数 error 错误信息, 包含堆栈

###### wx.offAppShow(callback)

取消件套小程序切前台事件

###### wx.onAppShow(callback)

监听小程序切前台事件. 改时间与 App.onShow 回调参数一致

参数 res 结构

| path         | string | 小程序切前台的路径                                           |
| ------------ | ------ | ------------------------------------------------------------ |
| scene        | number | 小程序切前台的场景值                                         |
| query        | Object | 小程序切前台的query参数                                      |
| shareTicket  | string | 更多转发信息                                                 |
| referrerInfo | Object | 来源信息(appId 来源 的appId; extraData 来源传递来的数据. scene=1037/1038时支持) |

部分版本在无 referrerInfo 的时候会返回 undefined, 使用 `options.referrerInfo && options.referrerInfo.appId` 进行判断

###### wx.offAppHide(callback)

取消监听小程序切后台事件, 回调

###### wx.onAppHide(callback)

监听小程序切后台事件, 与 App.onHide 回调时机一致.

### 定时器

##### setTimeout(callback, number delay, any rest)

设定一个定时器, 在定时到期以后执行注册的回调函数

参数

​	callback  回调函数

​	number delay 延迟时间, 单位ms

​	any rest 附加参数, 作为参数传递给回调函数

返回值 number 定时器的编号, 该值传递给 clearTimeout 来取消定时器

##### clearTimeout(timeoutID)

取消由 setTimeout 设置的定时器

##### setInterval()

设定一个定时器, 按照指定的周期来执行注册回调

##### clearInterval()

取消由 setInterval 注册的定时器

### 调试

##### wx.setEnableDebug(Object object)

设置是否打开调试开. 

- enableDeBug 是否打开调试
- success 成功回调函数
- ...

##### wx.getLogManager(number level)

获取日志管理器对象.

- number level 取值 0/1, 取值为0表示会把 APP, Page 的生命周期函数和 wx命名空间下的函数调用写入入职, 取1则不会, 默认 0.

###### 返回值

LogManager 日志管理器实例

​	方法

 - LogManager.debug() 写 debug 日志
 - LogManager.info() 写 info 日志
 - LogManager.log() 写 log 日志
 - LogManager.warn() 写 warn 日志

使用说明 最多保存 5M 的日志内容, 超过旧内容会被删除.

用户可以通过使用 \<Button\> 组件的 open-type='feedback' 来上传打印的日志. 开发者可以通过小程序管理后台左侧菜单 "客服反馈" 页面查看

基础库默认把 App, Page 的生命周期函数和 wx 命名空间下的函数调用写入日志

#### 云开发控制台 console

云开发提供了一个控制台用于可视化管理云资源, 控制台包含以下几大模块

- 概览: 查看云资源的总体使用情况
- 用户管理: 查看小程序的用户访问记录
- 数据库: 管理数据库集合, 记录, 权限设置, 索引设置
- 存储管理: 管理云文件, 权限设置
- 云函数: 管理云函数, 查看调用日志. 监控记录
- 统计分析: 查看云资源详情使用统计

在用户管理中会显示使用云能力的小程序的访问用户列表, 默认以访问时间倒序排列, 访问时间的触发点是在小程序端调用 wx.cloud.init 方法, 其中 traceUser 参数值为 true  

```js
wx.cloud.init({
    traceUser: true
})
```



## 路由

#### wx.navigateBack(Object object)

- delta 回退多少步数, 超过步数则回到index
- success 成功回调

#### wx.navigateTo(Object object)

- url 跳转地址
- success 成功回调
- ...

#### wx.reLaunch(Object object)

关闭所有页面并指定跳转某页面

- url 指定跳转页面地址
- success 成功回调

#### wx.redirect(Object object)

关闭当前页面,并指定跳转某一页面

- url 跳转页面地址
- success 成功回调

#### wx.switchToTab(Object object)

指定跳转某一 tabBar 项

- url 指定跳转 tabBar 地址



## 界面

### 交互

##### wx.showLoading(Object object)

- title 加载提示
- mask 是否涵盖隐藏层, 默认false
- success 成功回调

##### wx.hideLoading() 加载

关闭加载loading

##### wx.showToast(Object object) 轻提示

- title 提示内容
- icon 提示体表
- mask 是否涵隐藏层

##### wx.hideToast() 隐藏轻提示

- success 成功回调
- ...

##### wx.showModel(Object object) 模态框

- title 标题
- content 内容
- cancelText 取消文本
- cancelColor 取消文本字体颜色
- confirmText 确认文本
- confirmColor 确认文本字体颜色
- success() 成功回调
  - 参数 res 根据res, 是可以确定点击了取消还是点击了确认

##### wx.showActionSheet(Object object)

显示操作菜单

- itemList 操作列表项
- success 成功回调 参数 res.tapIndex 选择菜单项索引

### 导航栏

##### wx.hideNavigationBarLoading(Object object)

当前页面隐藏导航条加载动画

- success 成功回调
- ...

##### wx.setNavigationBarColor(Object object)

设置页面顶部导航颜色

- fontColor 前景颜色值(按钮, 标题, 状态栏颜色, 支持 #ffffff, #000000)
- backgroundColor 背景颜色值, 有效值为十六进制颜色
- animation 动画效果
  - duration 动画变化时间, 默认0
  - timingFunc 动画变化方式, 默认 linear
    - linear easeIn easeOut easeInOut
- success 成功回调

##### wx.setNavigationBarTitle(Object object)

设置当前页面顶部导航标题

- title 标题文本
- success 成功回调
- ....

##### wx.showNavigationBarLoading()

在当前页面显示导航条加载动画

- success 成功回调

### 背景

##### wx.setBackgroundColor(Object object)

动态设置窗口的背景色

- backgroundColor 窗口的背景色, 必须是十六进制
- success 成功回调

##### wx.setBackgroundTextStyle(Object object)

动态设置下拉背景字体, loading 图的演示

- textStyle 必填 下拉背景字体, loading 样式
  - dark	
  - light

### Tab Bar

##### wx.hideTabBar(Object object)

隐藏 tabBar

- animation 是否需要动画效果, 默认false
- success 成功回调
- ...

##### wx.showTabBar(Object object)

显示 tabBar

- animation 是否需要动画效果, 默认false
- success 成功回调
- ...

##### wx.setTabBarStyle(Object object)

动态设置 tabBar 的整体样式

- color	tab文字默认颜色HexColor
- selectedColor      tab被选中时文字颜色HexColor
- backgroundColor     tab的背景色HexColor
- borderStyle   tabBar上边框的颜色, 支持 black/white
- success  成功回调
- ...

##### wx.setTabBarItem(Object object)

动态设置 tabBar 某一项的内容

- index tabBar 项目索引
- text    tab 上的按钮文字
- iconPtah  图片路径, 大小限制 40kb, 建议尺寸 81px*81px, 不支持网络图片
- selectedIconPath 选中时图片路径
- success  接口调用成功的回调函数
- ..

##### wx.showTabBarRedDot(Object object)

显示 tabBar 某一项的右上角的红点

- index 索引
- success 成功回调
- ....

##### wx.hideTabBarRedDot(Object object)

隐藏 tabBar 某一项右上角红点

- index 索引
- success 成功回调
- ....

##### wx.setTabBarBarBadge(Object object)

给 tabBar 某一项右上角添加文本

- index	索引	
- text        文本内容

##### wx.removeTabBarBadge(Object object)

移除 tabBar 某一项右上角的文本

- index 索引
- success 成功回调
- ...

### 下拉刷新

##### wx.startPullDownRefresh(Object object)

开始下拉刷新. 调用后出发下拉刷新动画, 效果与用户手动刷新一致

- success 成功回调

##### wx.stopPullDownRefresh()

停止当前页面下拉刷新

- success 成功回调

### 滚动

##### wx.pageScrollTo(Object object)

将页面滚动到目标位置

- scrollTop 滚动到页面的目标位置, 单位 px
- duration 滚动动画的时长, 单位 ms
- success 成功回调
- ...

### 动画

##### wx.createAnimation(Object object)

创建一个动画实例 animation. 调用实例的方法来描述动画, 最后通过动画实例的 export 方法导出动画数据传递给组件的 animation 属性

- duration 动画持续时间
- timingFunction 动画的效果, 默认 linear
- delay 延迟时间
- transformOrigin '50% 50% 0' 动画开始基点

###### 返回值  Animation

动画对象

- Animation.export() 导出动画队列

  export 方法每次调用后会清掉之前的动画操作

-  Animation.step() 表示一组动画完成.

  可以在一组动画中调用任意多个动画方法, 一组动画的所有动画会同时开始, 一组动画完成后才会进行下一组动画的开始.

#### 自定义组件

##### wx.nextTick(callback)

延迟一部分操作到下一个时间片再执行

#### 菜单

##### wx.getMenuButtonBoundingClientRect()

获取菜单按钮布置信息

#### 置顶

##### wx.setTopBarText(Object object)

动态设置置顶栏文字内容. 只有当前小程序被置顶时能生效.

- text 文本内容
- success 成功回调

### 窗口

##### wx.offWindowResize(callback)

取消监听窗口尺寸变化事件

- callback 尺寸变化事件回调

##### wx.onWindowResize(callback)

监听窗口尺寸变化

- callback 
  - 参数 res.size 
    -  windowWidth
    -  windowHeight

## 网络

### 发起请求

##### wx.request(Object object)

- url 开发者服务器地址
- data 请求参数
- header 设置请求头 默认 application/json
- method 请求方法 默认 get
  - OPTIONS HTTP 请求 OPTIONS
  - GET  HTTP请求GET
  - HEAD  HTTP请求 HEAD
  - POST HTTP 请求 POST
  - ... 
- dataType 返回数据格式
  - json 返回的数据为 JSON , 返回后会对数据进行一次 JOSN.parse
  - 其它  不对返回的内容进行 JSON.parse
- responseType 响应数据类型
  - text	响应的数据为文本
  - arraybuffer 响应的数据为 ArrayBuffer
- success 成功回调
  - data  开发者服务返回的数据
  - statusCode 开发者服务器返回的 HTTP 状态码
  - header 开发者服务器返回的 HTTP Response Header
- ...

data 参数说明

最终发送给服务器的数据是 String类型, 如果传入的data不是String, 会被转换, 规则如下:

- GET 方法的数据, 转成 query (q=xx&m=xxx&..)
- POST 方法且header['content-type']为 application/json 的数据, 会对数据进行 JSON 序列化
- POST 方法且 header['content-type'] 为 application/x-www-form-urlencoded 的数据, 会将数据转换成 query(encodeURIComponent(k)=encodeURIComponent(v)&encodeURIComponent(k)=encodeURIComponent(v)..)

示例代码

```js
let RequestTask = wx.request({
    url: 'test.php', // 仅为示例，并非真实的接口地址
    data: {
        x: '',
        y: ''
    },
    header: {
        'content-type': 'application/json' // 默认值
    },
    success(res) {
        console.log(res.data)
    }
})
```

返回值 RequestTask

- RequestTask.abort() 

  中断请求任务

- onHeadersReceived(callback)

  监听 HTTP Response Header 事件, 比请求完成事件更早

- offHeadersReceived(callback) 取消监听

### 下载

##### wx.downloadFile(Object object)

下载文件资源到本地. 客户端直接发起一个 HTTPS GET请求, 返回文件的本地临时路径

注意: 请在服务端响应的 header 中指定合理的 Content-Type 字段, 以保证客户端正确处理文件类型

- url 下载资源的URL路径
- header HTTP请求的 Header, Header中不能设置 Referer
- filePath 指定文件下载后存储的路径
- success 成功回调
  - tempFilePath  临时文件路径, 如果没有传入 filePath 指定文件存储路径, 则下载后的文件会存储到一个临时文件
  - statusCode 开发者服务器返回的 HTTP 状态码
- ....

###### 返回值 DownloadTask

一个可以监听下载进度变化事件和取消下载的对象

- DownloadTask.abort() 中断下载任务
- DownloadTask.onProgressUpdate(callback) 监听下载进度变化事件

		callback 返回值 res

		- progress 下载进度百分比
		
		- totalBytesWritten 已经下载的数据长度, 单位 bytes
		
		- totalBytesExpectedToWrite 预期需要下载的数据总长度, 单位 Bytes

```js
let DownloadTask = wx.downloadFile({
    url: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1545303501290&di=fdd08c353d8c0c4c44afca807aa9a1d7&imgtype=0&src=http%3A%2F%2Fpic.58pic.com%2F00%2F95%2F76%2F78bOOOPIC49.jpg',
    success: (res) => {
        if (res.statusCode == 200) {
            console.log(res.tempFilePath)
            this.setData({
                'imgUrl': res.tempFilePath
            })
        }
    }
})
RequestTask.onProgressUpdate(function(res) {
    console.log(res)
})
```

- onHeadersReceived(callback)

监听 HTTP Response Header 事件. 比请求完成事件更早

参数 res.http 属性是开发者服务区返回的 HTTP Response Header

### 上传

##### wx.uploadFile(Object object)

将本地资源上传到服务器. 客户端发起一个 HTTPS POST 请求, 其中 content-type 为 multipart/form-data

- url	开发者服务区地址
- filePath 要上传文件资源路径
- name 文件对应的key, 开发者在的服务端可以通过 key 获取文件的二进制内容
- header HTTP 请求 Header
- formData HTTP 请求中其他额外的 form data
- success 成功回调
  - res.data 开发者服务区返回的数据
  - res.statusCode 开发者服务区返回的 HTTP 状态码
- ...

示例代码

```js
wx.chooseImage({
    success(res) {
        const tempFilePaths = res.tempFilePaths
        wx.uploadFile({
            url: 'https://example.weixin.qq.com/upload', // 仅为示例，非真实的接口地址
            filePath: tempFilePaths[0],
            name: 'file',
            formData: {
                user: 'test'
            },
            success(res) {
                const data = res.data
                // do something
                }
        })
    }
})
```

###### 返回值 UploadTask

UploadTask 一个可以监听上传进度的事件和取消上传的对象

- UploadTask.abort() 中断上传任务

- UploadTask.onProgressUpdate(callback)

  监听上传进度变化事件

- UploadTask.offProgressUpdate(callback)

  取消监听上传进度条变化事件
- UploadTask.onHeadersReceived(callback)

  监听 HTTP Response Header 事件, 比请求完成事件更早

```js
uploadTask.onProgressUpdate((res) => {
    console.log('上传进度', res.progress)
    console.log('已经上传的数据长度', res.totalBytesSent)
    console.log('预期需要上传的数据总长度', res.totalBytesExpectedToSend)
})

uploadTask.abort() // 取消上传任务
```

### WebSocket

##### wx.connectSocket(Object object)

创建一个 WebScoket 连接

- url  开发者服务器 wss 接口地址
- header 请求头设置
- protocols 子协议数组

- success 成功回调
- ...

###### 返回值 SocketTask

WebSocket 任务管理, 可以通过 wx.connectSocket() 接口创建返回

方法

- SocketTask.send(Object object) 通过 WebSocket 连接发送数据
- SocketTask.close(Object object) 关闭 WebSocket 连接
- SocketTask.onOpen(callback) 监听 WebSocket 连接打开事件
- SocketTask.onClose(callback) 监听 WebSocket 连接关闭事件
- SocketTask.onError(callback) 监听 WebSocket 错误事件
- SocketTask.onMessage(callback) 监听 WebSocket 接收到服务器的消息事件

##### wx.onSocketError(callback)

监听 WebSocket 错误事件

- callback WebSocket错误事件的回调

##### wx.onSocketMessage(callback)

监听 WebSocket 接受到服务器的消息事件

回调参数 res.data 服务器返回的消息

##### wx.onSocketClose(callback)

监听 WebSocket 连续关闭事件

- callback WebSocket 连续关闭事件的回调函数

##### wx.onSocketOpen(callback)

监听 WebSocket 连续打开事件

- callback 参数 res.header 连接成功的 HTTP 响应头

##### wx.sendSocketMessage(Object object)

通过 WebSocket 连接发送数据, 需要先 wx.connectSocket, 并在 wx.onSocketOpen 回调之后才能发送

- data   string/ArrayBuffer 需要发送的内容
- success 成功回调
- ...

```js
const socketOpen = false
const socketMsgQueue = []
wx.connectSocket({
    url: 'test.php'
})

wx.onSocketOpen(function (res) {
    socketOpen = true
    for (let i = 0; i < socketMsgQueue.length; i++) {
        sendSocketMessage(socketMsgQueue[i])
    }
    socketMsgQueue = []
})

function sendSocketMessage(msg) {
    if (socketOpen) {
        wx.sendSocketMessage({
            data: msg
        })
    } else {
        socketMsgQueue.push(msg)
    }
}
```

##### wx.closeSocket(Object object)

关闭 WebSocket 连接

- code	默认值1000(正常关闭连接)

- reason   可读字符串, 表示连接被关闭的原因. 字符串必须不长于123字节的 UTF-8文本
- success 成功回调
- ...

### mDns

##### wx.onLocalServiceResolveFail(callback)

监听 mDNS 服务解析失败的事件

- callback 回调

##### wx.onLocalServiceDiscoveryStop(callback)

监听 mDNS 服务停止搜索的事件

##### wx.onLocalServiceLost(callback)

监听 mDNS 服务离开的事件

- callback

  参数 res.serviceType	服务的类型

  参数 res.serviceName  服务的名称

##### wx.onLocalServiceFound(callback)

监听 mDNS 服务发现的事件

- callback

  参数 res.serviceType 服务的类型

  参数 res.serviceName 服务的名称

  参数 res.ip	服务的 ip 地址

  参数 res.port 服务的端口

## 数据缓存

##### wx.getStorageInfo(Object object)

异步获取当前 storage 的相关信息

- success 成功回调
  - keys 当前 storage 中所有的 key
  - currentSize 当前占用的空间大小
  - limitSize 限制的空间大小
- ...

##### wx.getStorageInfoSync()

是wx.getStorageInfo 同步版本

- keys  当前 storage 中所有的 key
- currentSize  当前占用的空间大小 KB
- limitSize  限制空间大小

实例代码

```js
wx.getStorageInfo({
    success(res) {
        console.log(res.keys)
        console.log(res.currentSize)
        console.log(res.limitSize)
    }
})

try {
    const res = wx.getStorageInfoSync()
    console.log(res.keys)
    console.log(res.currentSize)
    console.log(res.limitSize)
} catch (e) {
    // Do something when catch error
}
```

##### wx.clearStorage(Object object)

清理本地数据缓存

- success()
- ...

##### wx.clearStorageSync()

wx.clearStorage() 的同步版本

示例 

```js
wx.clearStorage()

try {
    wx.clearStorageSync()
} catch (e) {
    // Do something when catch error
}
```

##### wx.removeStorage(Object object)

从本地缓存中移除指定 key

- key 本地缓存中指定key
- success 成功回调

##### wx.removeStorageSync()

wx.removeStorage() 的同步版本

示例

```js
wx.removeStorage({
    key: 'key',
    success(res) {
        console.log(res.data)
    }
})

try {
    wx.removeStorageSync('key')
} catch (e) {
    // Do something when catch error
}
```

##### wx.setStorage(Object object)

将数据存储在本地缓存中指定的 key 中. 会覆盖原来 key 对应的内容. 数据存储生命周期跟小程序本身一致, 除非用户主动删除或查过一定时间被自动清理, 否则数据都一直可用. 单个 key 允许存储最大数据长度为 1MB, 所有数据存储上线为 10MB

- key 本地存储中指定的 key
- data 需要存储的内容, 支持原生类型, Date 及能通过 JSON.stringify 序列化的对象
- success 成功回调
- ...

##### wx.setStorageSync(key, data)

wx.setStorage() 的同步版本

```js
wx.setStorage({
    key: 'key',
    data: 'value'
})

try {
    wx.setStorageSync('key', 'value')
} catch (e) { }
```

##### wx.getStorage(Object object)

从本地缓存中异步获取指定 key 的内容

- key  本地缓存中的指定key
- success 读取成功回调
  - 参数 res.data     本地缓存指定 key 对应的内容

```js
wx.getStorage({
    key: 'key',
    success(res) {
        console.log(res.data)
    }
})

try {
    const value = wx.getStorageSync('key')
    if (value) {
        // Do something with return value
    }
} catch (e) {
    // Do something when catch error
}
```

## 媒体

### 地图

##### wx.createMapContext(mapId, this)

- mapId 		<map>组件的 id
- this                  在自定义组件下,当前组件示例的 this, 用来操作组件内 <map> 组件

###### 返回值 MapContext

MapContext 实例, 可以通过 wx.createMapContext 获取

mapContext 通过 id 跟一个 <map> 组件绑定, 操作对应 <map> 组件

方法

- MapContext.getCenterLocation(Object object)

  获取当前地图中心的经纬度, 返回 gcj02 坐标系, 可以用于 wx.opnLoaction()

  - success 成功回调
    - res.longitude 经度
    - res.latitude  纬度
  - ...

- MapContext.moveToLocation()

  将地图中心移动到当前定位点. 需要配合 map 组件的 show-loaction 使用

- MapContext.translateMarker(Object object)

  平移 Marker, 带动画

  - markerId 指定 marker
  - destination 指定移动目标点
    - longitude 经度
    - latitude  纬度
  - autoRotate 移动过程是否旋转
  - rotate 旋转角度
  - duration 动画持续时长
  - animationEnd 动画结束回调
  - success 成功回调

- MapContext.includePoints(Object object) 

  缩放视野展示所有经纬度

  - points 显示在可视区内坐标点列表
    - longitude 经度
    - latitude 纬度
  - success 成功回调
  - ..

- MapContext.getRegion()

  获取当前地图的视野范围

  - success 
    - res.southwest 西南角经纬度
    - res.northeast 东北角经纬度

- MapContext.getScale()

  获取地图的缩放级别

  - success 
    - res.scale 缩放值

### 图片

##### wx.compressImage()

压缩图片接口, 可选压缩质量

- src 图片路径(相对路径, 临时文件路径, 存储文件路径)
- quality 压缩质量 数值越小, 质量越低, 压缩率越高 (仅支持 jpg)
- success 成功回调

```js
wx.compressImage({
  src: '', // 图片路径
  quality: 80 // 压缩质量
})
```

##### wx.saveImageToPhotosAlbum(Object object)

调用钱需要 用户授权 scope.writePhotosAlbum

保存图片到系统相册

- filePath 图片文件路径
- success 成功回调

```js
wx.saceImageToPhotosAlbum({
    success(res){}
})
```

##### wx.getImageInfo(Object object)

获取图片信息, 网络图片需要先配置 download 域名才能生效

- src 图片路径
- success 成功回调
  - res.width 图片原始宽度
  - res.height 图片原始高度
  - res.path 图片的本地路径
  - res.orientation 拍照时设备方向
    - up 默认(手机横持拍照)
  - res.type 图片格式

##### wx.previewImage(Object object)

在新页面中全屏预览图片. 预览过程中用户可以进行保存, 发送给好友等操作

- urls  Array.<string>需要预览的图片链接列表, 必须
- current  urls的第一张 当前显示图片的链接
- success 成功回调

##### wx.chooseImage(Object object)

从本地相册选择图片或使用相机拍照

- count 最多可选择图片张数, 默认9
- sizeType 所选图片尺寸, 默认 ['original', 'compressed']
  - original
  - compressed
- sourceType 选择图片来源 ['album', 'camera']
  - album 从相册选图
  - camera 使用相机照相
- success 成功回调
  - 参数 res.tempFilePaths
  - 参数 res.tempFiles
    - 属性 path 本地临时文件路径
    - 属性 size 本地临时文件大小

示例 

```js
wx.chooseImage({
    count: 1,
    sizeType: ['original', 'compressed'],
    sourceType: ['album', 'camera'],
    success(res) {
        // tempFilePath可以作为img标签的src属性显示图片
        const tempFilePaths = res.tempFilePaths
        }
})
```

### 视频

##### wx.saveVideoToPhotosAlbum(Object object)

调用前需要 用户授权 scope.writePhotosAlbum

保存视频到系统相册

- filePath 视频文件路径
- success 成功回调
- ...

```js
wx.saveVideoToPhotosAlbum({
    filePath: 'wxfile://xxx',
    success(res) {
        console.log(res.errMsg)
    }
})
```

##### wx.chooseVideo(Object object)

拍摄视频或从手机相册选视频

- sourceType 视频选择的来源 默认 ['album', 'camera']
  - album 从相册中选择视频
  - camera 使用相机拍摄视频
- compressed 是否压缩所选择的视频文件
- maxDuration 拍摄视频最长时间. 单位 s
- camera 
  - back 启用后置摄像头
  - front 启用前置摄像头
- success 成功回调
  - tempFilePath 选定视频临时文件路径
  - duration  选定视频时间长度
  - size 选定数据量大小
  - height 选定视频的高度
  - width 选定视频宽度

```js
wx.chooseVideo({
    sourceType: ['album', 'camera'],
    maxDuration: 60,
    camera: 'back',
    success(res) {
        console.log(res.tempFilePath)
    }
})
```

##### wx.createVideoContext(id, this)

创建 video 上下文 VideoContext 对象

- id  <video> 组件的id
- this  当前组件实例的this, 以操作组件内 <video> 组件

###### 返回值

VideoContext

VideoContext 实例, 可以通过 wx.createVideoContext 获取

videoContent 通过 id he一个 <vidoe> 组件绑定, 操作对应的 <video> 组件

- VideoContext.play() 播放视频
- VideoContext.pause() 暂停视频
- VideoContext.stop() 跳转到指定位置
- VideoContext.seek(number position) 跳转指定位置
- VideoContext.sendDanmu(Object data) 发送弹幕
- VideoContext.playbackRate(number rate) 设置播放倍速
- VideoContext.requestFullScreen(Object object) 进入全屏
- VideoContext.exitFullScreen() 退出全屏
- VideoContext.showStatusBar() 显示状态栏(ios全屏下有效)
- VideoContext.hideStatusBar() 隐藏状态栏(ios有效)

### 音频

##### wx.stopVoice(Object object)

结束播放语音

- success 成功回调

##### wx.pauseVoice(Object object)

暂停正在播放的语音, 再次调用 wx.playVoice 播放同一个文件时, 会从暂停处开始播放, 如果想要从头开始播放, 需要先调用 wx.stopVoice

- success 成功回调

##### wx.playVoice(Object object)

开始播放语音. 同时只允许一个语音文件还没播放完

- filePath 需要播放的语音文件的文件路径
- duration 指定录音时长, 到达指定录音时长后自动停止录音
- success 成功回调

```js
wx.startRecord({
    success(res) {	//用户授权成功
        const tempFilePath = res.tempFilePath
        wx.playVoice({
            filePath: tempFilePath,
            complete() { }
        })
    }
})
```

##### wx.setInnerAudioOption(Object object)

设置 InnerAudioContext 的播放选项, 设置之后对当前小程序全局生效

- mixWithOther 是否与其他影片混播, 设置为 true 之后, 不会终止其他应用或微信内的音乐, 默认 true
- obeyMuteSwitch (ios生效) 是否遵循静音开关, 设置为false时, 即使在静音模式下, 也能播放声音. 默认 true
- success 成功回调

##### wx.getAvailableAudioSources(Object object)

获取当前支持的音频输入源

- success

  参数 res.audioSources Array.<string> 支持的音频输入源列表, 可在 [RecorderManager.start()](https://developers.weixin.qq.com/miniprogram/dev/api/RecorderManager.start.html) 接口中使用

  ​	合法值: auto 自动设置, 所有平台适用

##### wx.createInnerAudioContext()

创建内部 audio 上下文 InnerAudioContext 对象

###### 返回值 InnerAudioContext

- InnerAudioContext.onCanplay(callback) 监听音频进入可以播放状态的事件
- InnerAudioContext.offCanplay(callback) 取消监听音频进入可以播放状态的事件
- InnerAudioContext.onPlay(callback) 监听音频播放事件
- InnerAudioContext.offPlay(callback) 取消监听音频播放事件
- InnerAudioContext.onPause(callback) 监听音频暂停事件
- InnerAudioContext.offPause(callback) 取消监听音频播放事件
- InnerAudioContext.onStop(callback) 监听音频停止事件
- InnerAudioContext.offStop(callback) 取消监听音频停止事件
- InnerAudioContext.onEnded(callback) 监听音频自然播放至结束的事件
- InnerAudioContext.offEnded(callback) 取消监听音频自然播放到结束的事件
- InnerAudioContext.onTimeUpdate(callback) 监听音频播放进度更新事件
- InnerAudioContext.offTimeUpdate(callback) 取消监听音频播放进度更新事件
- InnerAudioContext.onError(callback) 监听音频播放错误事件
- InnerAudioContext.offError(callback) 取消监听音频播放错误事件
  - 回调参数 res.errCode
    - 10001 系统错误
    - 10002 网络错误
    - 10003 文件错误
    - 10004 格式错误
    - -1         未知错误
- InnerAudioContext.offError(callback) 取消监听音频播放错误事件
- InnerAudioContext.onWaiting(callback) 监听音频加载中事件, 音频因为数据不足, 需要停下来加载时触发
- InnerAudioContext.onSeeking(callback) 监听音频进行跳转操作事件
- InnerAudioContext.offSeeking(callback) 取消监听音频进行跳转操作的事件
- InnerAudioContext.onSeeked(callback) 监听音频完成跳转操作的事件
- InnerAudioContext.offSeeked(callback) 取消监听音频跳转完成事件
- InnerAudioContext.paly() 播放
- InnerAudioContext.pause() 暂停, 再次播放会从暂停处开始播放
- InnerAudioContext.stop() 停止, 再播放会从头开始
- InnerAudioContext.seek(number postion) 跳转到指定位置
  - 参数 number position 跳转的时间. 单位s, 精确到小数点后3位, 即支持 ms级别精度
- InnerAudioContext.destroy() 销毁当前实例

##### wx.createAudioContext(id, this)

创建 audio 上下文 AudioContext 对象

- id <audio> 组件的 id

###### 返回值 AudioContext

- AudioContext.setSrc(string src) 设置音频地址
- AudioContext.play() 播放音频
- AudioContext.pause() 音频暂停
- AudioContext.seek(number position) 音频跳转到指定位置, 单位s

### 背景音频

##### wx.onBackgroundAudioStop(callback) 

监听音乐停止事件

##### wx.onBackgroundAudioPause(callback)

监听音乐暂停事件

##### wx.onBackgroundAudioPlay(callback)

监听音乐播放事件

##### wx.stopBackgroundAudio(Object object)

停止播放音乐

- access 成功回调
- ...

示例 wx.stopBackgroundAudio()

##### wx.seekBackgroundAudio(Object object)

控制音乐播放进度

- position 音乐位置 单位 s
- success 成功回调
- ...

实例 wx.seekBackgroundAudio({  position: 30})

##### wx.pauseBackgroundAudio(Object object)

暂停播放音乐

- success 成功回调
- ...

##### wx.playBackgroundAudio(Object object)

使用后台播发器播放音乐. 对于微信客户端来说, 只能同时有一个后台音乐在播放. 当用户离开小程序后, 音乐将停止播放; 当用户在其他小程序占用了音乐播放器, 原有的小程序内的音乐将停止播放

- dataUrl 音乐链接(支持m4a, aac, mp3, wav)
- title 音乐标题
- coverImgUrl 封面URL
- success 成功回调
- ...

```js
wx.playBackgroundAudio({
    dataUrl: '',
    title: '',
    coverImgUrl: ''
})
```

##### wx.getBackgroundAudioPlayerState(Object object)

获取后台音乐播放状态

- success 接口调用成功回调
  - res.duration 选定音频长度(s), 只有在音乐播放中时返回
  - res.currentPosition 选定音频的播放位置(s)
  - res.status 播放状态
    - 0 暂停中
    - 1 播放中
    - 2 没有音乐播放
  - res.downloadPercent 音频下载进度百分比
  - res.dataUrl 歌曲数据链接
- ...

##### wx.getBackgroundAudioManager()

获取 全局唯一 的背景眼音频管理器, 小程序切入后台, 如果音频处于播放状态, 可以继续播放, 但是后台状态不能通过调用 api 操作音频的播放状态

微信客户端 6.7.2 开始, 如果需要在小程序后台继续播放音频, 需要在 app.json 中配置 requiredBackgroundModes 属性, 正式版需要通过审核

###### 返回值

BackgroundAudioManager

- BackgroundAudioManager.play() 播放音乐
- BackgroundAudioManager.pause() 暂停播放
- BackgroundAudioManager.seek() 跳转到指定位置
- BackgroundAudioManager.stop() 停止音乐
- BackgroundAudioManager.onCanplay() 监听背景音频进入可播放状态事件, 不保证后面可流畅播放
- BackgroundAudioManager.onWaiting() 监听音频加载中事件, 当音频因为数据不足, 需要停下来加载时会触发
- BackgroundAudioManager.onError() 监听背景音频播放错误事件
- BackgroundAudioManager.onPlay() 监听背景音频播放事件
- BackgroundAudioManager.onPause() 监听背景音频暂停事件
- BackgroundAudioManager.onTimeUpdate() 监听背景音频播放进度更新事件
- BackgroundAudioManager.onStop() 监听背景音频停止事件
- BackgroundAudioManager.onNext() 监听用户在系统音乐面板点击下一曲事件(IOS)
- BackgroundAudioManager.onPrev() 监听用户在系统音乐面板点击上一曲事件(IOS)

### 实时音视频

##### wx.createLivePusherContext()

创建 live-pusher 上下文 LivePusherContext 对象

###### 返回值 LivePusherContext

LivePusherContext实例, 可通过 wx.createLivePusherContext 获取

livePusherContext 与页面内唯一的 <live-pusher> 组件绑定, 操作对应的  <live-pusher> 组件

- LivePusherContext.start() 播放推流
- LivePusherContext.stop() 停止推流
- LivePusherContext.pause() 暂停推流
- LivePusherContext.resume() 回复推流
- LivePusherContext.switchCamera() 切换前后摄像头
- LivePusherContext.snapshot() 快照
- LivePusherContext.toggleTorh() 切换
- LivePusherContext.playBUG(object object) 播放背景音乐
- LivePusherContext.stopBGM() 停止背景音
- LivePusherContext.pauseBUG() 暂停背景音
- LivePusherContext.resumeBUG() 回复背景音
- LivePusherContext.setBUGMVolume(Object object) 设置背景音量

##### wx.createLivePlayerContext(id, this)

创建 live-player 上下文 LivePlayerContext 对象

- id <live-player> 组件 id 
- this 自定义组件下当前组件实例的 this, 以操作<live-player>组件

###### 返回值 LivePlayerContext

- LivePlayerContext.play(Object object) 播放
  - success 成功回调
  - ...
- LivePlayerContext.stop(Object object) 停止
  - success 成功回调
  - ...

- LivePlayerContext.mute(Object object) 静音
  - success 成功回调
  - ...
- LivePlayerContext.pause(Object object) 暂停推流
  - success 成功回调
  - ...
- LivePlayerContext.resume(Object object) 恢复
  - success 成功回调
  - ...
- LivePlayerContext.requestFullScreen(Object object) 进入全屏
  - 参数属性
    - direction 设置全屏时的方向, 默认 0
      - 0 正常横向
      - 90 屏幕逆时针90度
      - -90 屏幕顺时针90度
    - success 成功回调

LivePlayerContext.exitFullScreen(Object object) 退出全屏

- success 成功回调
- ...

### 录音

##### wx.stopRecord()

停止录音

##### wx.startRecord(Object object)

开始录音, 当主动调用 wx.stopRecord, 或者录音超过1分钟时自动结束录音. 当离开小程序时, 此接口无法调用

- success 成功回调

  参数 res.tempFilePath 录音文件的临时路径

- ..

示例

```js
wx.startRecord({
    success(res) {
        const tempFilePath = res.tempFilePath
        }
})
setTimeout(function () {
    wx.stopRecord() // 结束录音
}, 10000)
```

##### wx.getRecorderManager()

获取全局唯一的录音管理器 RecorderManager

###### 返回值 RecorderManager

- RecorderManager.start(Object object) 开始录音
  - duration  默认60000, 录音时长, 单位 ms, 最大值600000ms
  - sampleRate 采样率, 默认 8000
  - numberOfChannels 默认2 录音通道数
  - encodeBitRate 默认48000 编码码率
  - format 默认aac 音频格式
    - mp3
    - aac
  - frameSize 指定帧大小
  - audioSource 指定录音的音频输入源, 可通过 wx.getAvailableAudioSources() 获取当前音频源

- RecorderManager.pause() 暂停录音
- RecorderManager.resume() 继续录音
- RecorderManager.stop() 停止录音
- RecorderManager.onStart(callback) 监听录音开始事件
- RecorderManager.onResume(callback) 监听录音继续事件
- RecorderManager.onPause(callback) 监听录音暂停事件
- RecorderManager.onStop(callback) 监听录音结束事件
  - 回调函数参数属性 res.tempFilePath 录音文件的临时路径
- RecorderManager.onFrameRecorded(callback) 监听已录制完指定帧大小的文件事件. 如果设置了 frameSize, 则会回调此事件
  - 回调函数参数属性
    - frameBuffer  录音分片数据
    - isLastFrame 当前帧是否正常录音前的最后一帧
- RecorderManager.onError(callback) 监听录音错误事
  - 回调参数res.errMsg 错误信息
- RecorderManager.onInterruptionBegin(callback) 监听录音因为受到系统占用而被终端开始事件, 以下场景会触发此事件: 微信语音聊天, 微信视频聊天, 此事件触发后, 录音会被暂停, pause 事件于此事件后触发
- RecorderManager.onInterruptionEnd(callback) 监听录音中断结束事件. 受到 interruptionBegin 事件之后, 小程序内所有录音都会暂停, 收到此事件之后才可再次录音成功.

示例代码

```js
const recorderManager = wx.getRecorderManager()

recorderManager.onStart(() => {
  console.log('recorder start')
})
recorderManager.onPause(() => {
  console.log('recorder pause')
})
recorderManager.onStop((res) => {
  console.log('recorder stop', res)
  const {tempFilePath} = res
})
recorderManager.onFrameRecorded((res) => {
  const {frameBuffer} = res
  console.log('frameBuffer.byteLength', frameBuffer.byteLength)
})

const options = {
  duration: 10000,
  sampleRate: 44100,
  numberOfChannels: 1,
  encodeBitRate: 192000,
  format: 'aac',
  frameSize: 50
}

recorderManager.start(options)
```

### 相机

##### wx.createCameraContext()

创建 camera 上下文 CameraContext 对象

###### 返回值 CameraContext

cameraContext 与页面内唯一的 <camera> 组件绑定, 操作对应的 <camera> 组件.

方法

- CameraContext.takePhoto(Object object) 拍摄照片
  - quality 成像质量 string
    - high 高质量
    - normal 普通质量
    - low 低质量
  - success 成功回调
    - 回调参数 res.tempImagePath 照片文件临时路径
  - ...
- CameraContext.startRecord(Object object) 开始录像
  - timeoutCallback(callback) 超过30s或页面 onHide 时会结束录像
    - 回调参数 res
      - tempThumbPath  封面照片文件的临时路径
      - tempVideoPath 视频的文件的临时路径
  - success 成功回调
  - ...
- CameraContext.stopRecord(Object object) 结束录像
  - success 成功回调
    - 参数 res
      - 属性 tempThumbPath 分秒图片文件的临时路径
      - 属性 tempVideoPath 视频的文件的临时路径

### 字体

##### wx.loadFontFace(Object object)

动态加载网络字体. 文件地址需为下载类型

注意:

1. 引入中文字体，体积过大时会发生错误，建议抽离出部分中文，减少体积，或者用图片替代
2. 字体链接必须是https（ios不支持http)
3. 字体链接必须是同源下的，或开启了cors支持，小程序的域名是`servicewechat.com`
4. canvas等原生组件不支持使用接口添加的字体
5. 工具里提示 Faild to load font可以忽略

- family 定义的字体名称
- source 字体资源的地址, 建议格式为 TTF 和 WOFF
- desc  object可选字体描述符
  - style	字体样式(normal/italic/oblique)
  - weight    字体粗细(normal/bold/100-900)
  - variant  设置小写大写字母的字体显示文本
- success 调用成功回调
- ...

## 位置

##### wx.openLocation(Object object)

使用微信内置地图查看位置

 参数

- latitude 纬度 -90~90, 负表示南纬 使用 gcj02国测坐标系
- longitude 纬度 -180~180 负表示西经
- scale 缩放比例 5~18
- name 位置名
- address 地址的详细说明
- success 成功回调
- ...

##### wx.getLocation(Object object)

调用需要用户授权 scope.userLocation

获取当前的地理位置, 速度. 当用户离开小程序后, 此接口无法调用

参数

- type string 默认wgs84, wgs84返回 gps 坐标, gcj02 返回可用于 wx.openLocation 的坐标
- altitude 传入true会返回高度信息, 由于获取高度需要较高精度, 会减慢接口返回速度
- success 成功回调
  - 回调参数 res
    - latitude 纬度
    - longitude 精度
    - speed 速度 m/s
    - accuracy 位置的精确度
- ...

示例

```js
wx.getLocation({
    type: 'gcj02', // 返回可以用于wx.openLocation的经纬度
    success(res) {
        const latitude = res.latitude
        const longitude = res.longitude
        wx.openLocation({
            latitude,
            longitude,
            scale: 18
        })
    }
})
```

##### wx.chooseLocation(Object object)

打开地图选择位置. 调用前需要用户授权 scope.userLocation

参数

- success 接口调用成功回调
  - 回调参数 res
    - name 位置名称
    - address 详细地址
    - latitude 纬度
    - longitude 经度
- ...

```js
wx.chooseLocation({
    success(res) {
        console.log(res)
    }
})
```

## 转发

##### wx.showShareMenu(Object object)

显示当前页面转发按钮

- withShareTicket 是否使用 shareTicket 的转发详情
- success 成功回调
- ...

##### wx.hideShareMenu(Object object)

隐藏转发按钮

- success 成功回调
- ....

##### wx.getShareInfo(Object object)

获取转发详细信息

- shareTicket  string 必填 shareTicket
- timeout 超时时间
- success 成功回调
  - 参数 res 
    - errMsg 错误信息
    - encryptedData 包括敏感数据在内的完整转发信息的加密数据
    - iv 加密算法初始向量
- ...

##### wx.updateShareMenu(Object object)

更新转发属性

- withShareTicket 是否使用带 shareTicket 的转发详情
- isUpdatableMessage  是否是动态消息
- activityId 动态消息的 activityId, 通过 createActivityId 接口获取
- templateInfo 动态消息的模板信息
  - parameterList 参数列表
    - name 参数名
    - value 参数值
- success 成功回调
- ...

## 文件

##### wx.getFileSystemManager()

获取全局唯一的文件管理器

###### 返回值 FileSystemManger

- FileSystemManager.access(Object object) 判断文件/目录是否存在

  - path 文件路径
  - success 成功回调
    - res.errMsg 错误信息 fail no such file or directory ${path}
  - ...

  FileSystemManager.accessSync(path)  同步版本

- FileSystemManager.appendFile(Object object) 在文件结尾追加内容

  - filePath 追加内容的文件路径

  - data  要追加的文本或二进制数据流(string/ArrayBuffer)

  - encoding 指定写如文件的字符编码, 默认 utf8

    - 合法值: ASCII base64 binary hex  ucs2/ucs-2/utf16le/utf-16le  utf-8/utf8  latin1

  - success 成功回调

  - fail 失败回调

    - res.errMsg 错误信息

    | fail no such file or directory, open ${filePath}          | 指定的 filePath 文件不存在           |
    | --------------------------------------------------------- | ------------------------------------ |
    | fail illegal operation on a directory, open "${filePath}" | 指定的 filePath 是一个已经存在的目录 |
    | fail permission denied, open ${dirPath}                   | 指定的 filePath 路径没有写权限       |
    | fail sdcard not mounted                                   | 指定的 filePath 是一个已经存在的目录 |

    FileSystemManager.appendFileSync(filePath, data, encoding) 同步版本

- FileSystemManager.saveFile(Object object) 保存临时文件到本地. 会移动临时文件, 调用成功后, tempFilePath不可用

  - tempFilePath 临时文件路径

  - filePath 要存储的文件路径

  - success 成功回调

    - res.savedFilePath 存储后的文件路径

  - fail 失败回调

    - res.errMsg 错误信息

    | fail tempFilePath file not exist            | 指定的 tempFilePath 找不到文件 |
    | ------------------------------------------- | ------------------------------ |
    | fail permission denied, open "${filePath}"  | 指定的 filePath 路径没有写权限 |
    | fail no such file or directory "${dirPath}" | 上级目录不存在                 |

  - ...

    FileSystemManager.saveFileSync(tempFilePath, filePath) 同步版本

- FileSystemManager.getSavedFileList(Object object) 获取该小程序已保存的临时文件列表

  - success 成功回调
    - 回调参数 res.fileList 文件数组
  - ...

- FileSystemManager.removeSavedFile(Object object) 删除该小程序下已保存的本地缓存文件

  - filePath 需要删除的文件路径
  - success 成功回调
  - fail 失败回调
    - res.errMsg 合法值: fail file not exist 指定 tempFilePath 找不到文件
  - ...

- FileSystemManager.copyFile(Object object) 复制文件

  - srcPath 源文件路径, 只可以是普通文件

  - destPath 目标文件路径

  - success 成功回调

  - fail 失败回调

    - res.errMsg 错误信息

    | fail permission denied, copyFile {srcPath} -> ${destPath}  | 指定目标文件路径没有写权限                   |
    | ------------------------------------------------------------ | -------------------------------------------- |
    | fail no such file or directory, copyFile {srcPath} -> ${destPath} | 源文件不存在，或目标文件路径的上层目录不存在 |

  - ...

    copyFileSync(srcPath, destPath) 同步版本

- FileSystemManager.getFileInfo(Object object) 获取该小程序下的本地临时文件或本地缓存文件信息

  - filePath 读取的文件路径
  - success 成功回调

- FileSystemManager.mkdir(Object object) 创建目录

  - dirPath 创建的目录路径

  - success 成功回调

    mkdirSync(dirPath) 同步版本

- FileSystemManager.readFile(Object object) 读取本地文件内容

  - filePath 要读取的文件的路径

  - encoding 指定读取文件的字符集编码, 不传以 ArrayBuffer 格式读取文件的二进制内容

  - success 成功回调

    - res.data 文件内容(string/ArrayBuffer)

  - ... 

    readFileSync(filePath, encoding) 同步版本

- FileSystemManager.readdir(Object object) 读取目录内文件列表

  - dirPath 要读取的目录文件

  - success 成功回调

    - 回调参数 res.files 指定目录下的文件名数组

    FileSystemManager.readdirSync(dirPath) 同步版本, 返回值 files 文件名数组

- FileSystemManager.rename(Object object) 重命名文件, 可以把文件从 oldPath 移动到 newPath

  - oldPath 源文件路径, 可以是普通文件或目录

  - newPath 新文件路径

  - success 成功回调

  - ...

    FileSystemManager.renameSync(oldPath, newPath) 同步版本

- FileSystemManager.rmdir() 删除目录

  - dirPath 要删除的目录路径

  - recursive 是否递归删除目录, ture 则删除该目录和该目录下的所有子目录及文件, 默认 false

  - success 成功回调

    FileSystemManager.rmdirSync(disPath, recursive) 同步版本

- FileSystemManager.stat(Object object) 获取 Stats 对象

  - path 文件/目录 路径
  - recursive 是否递归获取目录下的每个文件的 Stats 信息
  - success 成功回调
    - 返回值res.stats 当 recursive 是 false 时, res.stats 是一个 States 对象, 反之为 Object , key 以 Path为根路径的相对路径, value 是 该路径对应的 Stats 对象
  - ...

- FileSystemManager.unlink(Object object) 删除文件

  - filePath 删除的文件路径

  - success 成功回调

  - ...

    FileSystemManager.unlinkSync(fIlePath) 同步版本 

- FileSystemManager.unzip(Object object) 解压文件

  - zipFilePath 源文件路径, 只可以使 zip 压缩文件
  - targetPath 目标目录路径
  - success 成功回调

- FileSystemManager.writeFile(Obejct object) 写文件

  - filePath  要写入的文件路径

  - data 写入的文本或二进制数据

  - encoding 指定写入文件的字符集编码(默认utf8)

  - success 成功回调

  - ...

    FileSystemManager.writeFileSync(filePath, data, encoding) 同步版本

###### Stats 

- Stats.isDirectory() 判断当前文件是否是一个目录
- Stats.isFile() 判断当前文件是否是一个普通文件

##### wx.getFileInfo(Obejct object)

获取文件信息

- filePath 本地文件路径
- digestAlgorithm  默认值 md5 计算文件摘要的算法
  - md5 算法
  - sha1 算法
- success 成功回调
  - size 文件大小, 单位字节
  - sigest 按照传入的 digestAlgorithm 计算得出的文件摘要
- ...

示例

```js
wx.getFileInfo({
    filePath: "/temp/t1.txt",
    digestAlgorithm: "sha1",
    success(res) {
        console.log(res.size)
        console.log(res.digest)
    }
})
```

##### wx.getSavedFileInfo(Object object)

获取本地文件的文件信息. 此接口只能用于获取已保存到本地的文件, 若需要获取临时文件信息, 使用 wx.getFileInfo()

- filePath 文件路径
- success 成功回调
  - 回调参数res
    - size  文件大小
    - createTime 文件保存时的时间戳, 从 1970/01/01 08:00:00 到该时刻的秒数
- ...

##### wx.getSavedFileList(Object object)

获取该小程序已保存的本地缓存文件列表

- success 成功回调
  - 参数 res.fileList 文件数组, 每一项是一个fileItem
    - filePath 文件路径
    - size 文件大小
    - createTime 创建时间戳

##### wx.removeSavedFile(Object object)

删除本地缓存文件

- filePath  需要删除的文件路径
- success 成功回调
- ...

##### wx.openDocument(Obejct object)

新开页面打开文档

- filePath 文件路径, 可通过 downloadFile 获取
- fileType 文件类型, 指定文件类型打开文件
  - 支持 doc docx xls xlsx ppt pptx pdf 等格式
- success 成功回调
- ...

示例

```js
wx.downloadFile({
    // 示例 url，并非真实存在
    url: 'http://example.com/somefile.pdf',
    success(res) {
        const filePath = res.tempFilePath
        wx.openDocument({
            filePath,
            success(res) {
                console.log('打开文档成功')
            }
        })
    }
})
```

##### wx.saveFile(Object object)

保存文件到本地. 注意的是 saveFile 会把临时文件移动. 所以调用成功后传入的临时文件路径将不可用

- tempFilePath  需要保存的文件的临时路径
- success 成功回调
  - 返回值 res.savedFilePath 存储后的文件路径  
- ...

示例

```js
wx.chooseImage({
    success(res) {
        const tempFilePaths = res.tempFilePaths
        wx.saveFile({
            tempFilePath: tempFilePaths[0],
            success(res) {
                const savedFilePath = res.savedFilePath
                }
        })
    }
})
```

## 开放接口

### 登录

##### wx.login(Object object)

调用接口获取登录凭证(code). 通过凭证进而换区用户登录状态信息, 包括用户的唯一标识(openid) 及本次登陆的会话密匙(session_key) 等. 用户数据的加解密通讯需要依赖会话密匙完成

- timeout 超时时间, 单位 ms
- success 调用成功的回调函数
  - 回调参数 res.code 用户登录凭证, 有效期五分钟, 开发者需要在开发者服务器厚爱调用 code2Session, 使用 code 换取 openid 和 session_key 等信息
- fail 调用失败回调
- ...

##### code2Session

登录凭证校验, 通过 wx.login() 接口获得临时登录凭证 code 后传到开发者服务器调用此接口完成登录流程. 本接口应在后台服务器调用

请求地址 `GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code`

- appid 小程序 appid
- secret 小程序 appSecret
- js_code 登录时获取的 code
- grant_type 授权类型, 此处只需要填写 authorization_code

###### 返回值 Object

返回的 JSON 数据包

- oppid 用户唯一标识
- session_key 会话密匙
- unionid 用户在开放平台的唯一标识, 在满足 UnionID 下发条件的情况会返回
- errcode 错误码
  - -1 系统繁忙, 开发者稍后再试
  - 0 请求成功
  - 40029 code 无效
  - 45011 频率限制, 每个用户每分钟100次
- errmsg 错误信息

##### wx.checkSession(Object object) 

##### 检查登录状态是否过期

通过 wx.login 接口获得的用户登录行状态拥有一定的时效性. 用户越久未登录小程序, 用户登录状态越有可能失效. 反之, 如果用户一直在使用小程序, 则用户登录状态一直保持有效. 具体时效逻辑由微信维护. 我们只要调用 wx.checkSession 接口检测当前用户登录状态是否有效.

登录状态过期后开发者可以再调用 wx.login 获取新的用户登录状态. 调用成功说明当前 session_key 未过期, 调用失败说明 session_key 已经过期.

- success 成功回调
- fail 失败的回调

```js
wx.checkSession({
    success() {
        // session_key 未过期，并且在本生命周期一直有效
    },
    fail() {
        // session_key 已经失效，需要重新执行登录流程
        wx.login() // 重新登录
    }
})
```

### 小程序跳转

##### wx.navigateToMiniProgram(Object object) 

打开另外一个小程序

- appId 要打开的小程序 appId
- path  打开的页面路径, 空表示打开首页
- extraData 需要传递个目标小程序的数据, 目标小程序可以再 App.onLaunch, App.onShow 中获取到该数据
- envVersion 默认值 release(正式版) 要打开的小程序版本, 仅在当前小程序为开发版或测试版时该参数有效, 如果当前小程序时是正版, 则打开的小程序必须是正版
- success 成功回调
- ...

使用限制: 需要用户触发跳转, 需要用户确认跳转, 每个小程序可跳转的其他小程序数量限制为不超过10 个

```js
wx.navigateToMiniProgram({
    appId: '',
    path: 'page/index/index?id=123',
    extraData: {
        foo: 'bar'
    },
    envVersion: 'develop',
    success(res) {
        // 打开成功
    }
})
```

##### wx.navigateBackMiniProgram(Object object)

返回到上一个小程序, 只有在当前小程序是被其他小程序打开时可以调用成功

- extraData 需要返回给上一个小程序的数据, 可在 App.onShow 中获取到这份数据
- success 成功回调
- ...

### 账号信息

##### wx.getAccountInfoSync()

获取当前账号信息

返回值 Object

- miniProgress 小程序账号信息
  - appId 小程序 appId
- plugin 插件账号信息

  - appId 插件 id
  - version 插件版本号

### 用户信息

##### wx.getUserInfo(Object object)

调用前需要 用户授权 scope.userInfo

获取用户信息

- withCredentials 是否带上登录信息, 默认 false, 如果为true, 要求此前有吊用过 wx.login 且登录状态未过期, 此时返回的数据会包含 encryptedData, iv等敏感信息; 为 false时, 不要求有登录登录状态

- lang 显示用户信息的语言 默认 en

  - en / zh_CN / zh_TW

- success 成功回调

  - userInfo 用户信息对象, 不包含 openId 等敏感信息
  - rawData 不包含敏感信息的恩怨史数据字符串, 用于计算签名
  - signature 使用 sha1 (rawData+sessionkey) 得到字符串, 用于校验用户信息
  - encryptedData 包括敏感数据在内的完整用户信息的加密数据
  - iv 加密算法的初始向量

  接口调整说明: 在用户未授权的情况下调用此接口, 将不再出现授权弹窗, 会直接进入 fail 回调, 在用户已授权的情况下调用此接口, 可成功获取用户信息.

示例:

```js
//	必须在用户已授权的情况下调用
wx.getUserInfo({
  success(res) {
    const userInfo = res.userInfo
    const nickName = userInfo.nickName
    const avatarUrl = userInfo.avatarUrl
    const gender = userInfo.gender // 性别 0：未知、1：男、2：女
    const province = userInfo.province
    const city = userInfo.city
    const country = userInfo.country
  }
})
```

encryptedData 解密后为以下json结构

```json
{
  "openId": "OPENID",
  "nickName": "NICKNAME",
  "gender": GENDER,
  "city": "CITY",
  "province": "PROVINCE",
  "country": "COUNTRY",
  "avatarUrl": "AVATARURL",
  "unionId": "UNIONID",
  "watermark": {
    "appid": "APPID",
    "timestamp": TIMESTAMP
  }
}
```

示例代码: 如果只是展示用户头像昵称, 可以使用 <open-data /> 组件

```html
<!-- 如果只是展示用户头像和昵称, 可以使用 <open-data /> 组件 -->
<open-data type="userAvatarUrl"></open-data>
<open-data type="userNickName"></open-data>

<!-- 需要使用 button 来授权登录 -->
<button 
        wx:if="{{canIUse}}"
        open-type="getUserInfo"
        bindgetuserinfo="bindGetUserInfo"
        >授权登录</button>
<wiew wx:else>请升级微信版本</wiew>
```

```js
Page({
    data: {
        canIUse: wx.canIUse('button.open-type.getUserInfo')
    },
    onLoad() {
        // 查看是否授权
        wx.getSetting({
            success(res) {
                if (res.authSetting['scope.userInfo']) {
                    // 已经授权，可以直接调用 getUserInfo 获取头像昵称
                    wx.getUserInfo({
                        success(res) {
                            console.log(res.userInfo)
                        }
                    })
                }
            }
        })
    },
    bindGetUserInfo(e) {
        console.log(e.detail.userInfo)
    }
})
```

##### getPaidUnionId 

本接口应在后端服务器调用

用户支付完成后, 获取该用户的 UnionId, 无需用户验证

注意: 调用前需要用户完成支付, 且在支付后的五分钟内有效

请求地址: `GET https://api.weixin.qq.com/wxa/getpaidunionid?access_token=ACCESS_TOKEN&openid=OPENID`

请求参数: 

- access_token 接口调用凭证
- openid 支付用户唯一标识
- transaction_id 微信支付订单号
- mch_id 微信支付分配的珊瑚好, 和商户订单号配合使用
- out_trade_no 微信支付商户订单号, 和商户号配合使用

###### 返回值 Object

返回的 JSON 数据包

unionid 用户唯一标识, 调用成功后返回

errcode 错误码

ermsg 错误信息 

​	-1 系统繁忙 0 请求成功 40003 openid错误 89002 没有绑定开发平台账号 89300 订单无效

使用说明: 

 1. 微信支付订单号 (transaction_id)

    ```
    https://api.weixin.qq.com/wxa/getpaidunionid?access_token=ACCESS_TOKEN&openid=OPENID&transaction_id=TRANSACTION_ID
    ```

	2. 微信支付商户订单号和微信支付商户号(out_trade_no 及 mch_id)

    ```
    https://api.weixin.qq.com/wxa/getpaidunionid?access_token=ACCESS_TOKEN&openid=OPENID&mch_id=MCH_ID&out_trade_no=OUT_TRADE_NO
    ```

##### UserInfo 

用户信息

属性 

​	string nickName 用户昵称

 	string avatarUrl 用户头像图片的 URL, URL 最后一个数值代表正方形头像大小, 用户没有头像时,此项为空, 如果用户更换头像, 原有头像 URL 将失效

​	number gender 用户性别  0未知 1男性 2女性

​	string country 用户所在国家

​	string province 用户所在省份

​	string city 用户所在城市

​	string language 显示国家省份城市所用的语言

### 接口调用凭证

##### getAccessToken

本接口应在后端服务器调用

获取小程序全局唯一后台接口调用凭据 (access_token). 调用各后台接口都需要使用 access_token, 开发者需要进行妥善保存. 请求地址方式如下

```
GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET
```

请求参数说明

​	grant_type 填写 client_credential

​	appid 小程序唯一凭证, 即 AppID 需要已成为开发者, 且账号没有异常状态

​	secret 小程序唯一凭证密匙, 及 AppSecret, 获取方式同 appid

###### 返回值 JSON 数据包

​	access_token 获取到的凭证

​	expire_in 凭证有效期, 单位 s, 目前是 两小时以内

​	errcode 错误码 合法值 

​		-1 系统繁忙  

​		0 请求成功 

​		40001 AppSecret错误或者 AppSecret 不属于该小程序

​		40002 确保 grant_type 字段值为 client_credential

​		40013 不合法的 AppID

​	errmsg 错误信息

返回数据示例

正确 : {"access_token": "ACCESS_TOKEN", "expires_in": 7200}

错误: {"errcode": 40013, "errmsg": "invalid appid"}

###### access_token 的存储和更新

- access_token 的存储至少需要保留 512 个字符空间
- access_token 的有效期目前为 2小时, 需要定时刷新, 重复获取将导致上次获取 access_token 失效
- 建议开发者使用中控服务器统一获取和刷新 access_token, 其它业务逻辑服务器所使用的 access_token 均来自该中控服务器.
- access_token 的有效期通过返回值 expire_in 来传达, 中控服务器需要依据该有效期提前刷新, 建议提前5分钟
- access_token 有效期可能在未来会有调整, 所以中控服务器不仅要内部主动定时刷新, 还需要提供被刷新 access_token 的接口, 这样便于业务服务器在调用 API 调用数值 access_token 已超时情况下, 触发 access_token 的刷新流程.

### 数据上报

##### wx.reportMonitor(string name, number value)

自定义业务数据监控上报接口

- name 监控ID, 在 [小程序管理后台] 新建数据指标后获得
- value 上报数值, 经处理后会在 [小程序管理后台] 上展示每分钟的上报总量

使用说明: 使用前, 需要在 [小程序管理后台-运维中心-性能检测-业务数据监控] 中新建监控事件, 配置监控描述与告警类型, 每一个监控事件对应唯一的监控 ID, 开发者最多可以创建 128 个监控事件

示例: `wx.reportMonitor('1', 1)`

### 数据分析

#### wx.reportAnalyTics(string eventName, Object data)

自定义分析数据上报接口. 使用前, 需要在小程序管理吼他自定义分析中新建事件, 配置好事件名与字段

- eventName 事件名
- data 上报的自定义数据
  - key 配置中的字段名
  - value 上报的数据

示例代码

```js
wx.reportAnalytics('purchase', {
    price: 120,
    color: 'red'
})
```

#### 访问留存

##### getAnalysisDailyRetain

本接口应在后端服务器调用

获取用户访问小程序日留存

请求地址: 

```
POST https://api.weixin.qq.com/datacube/getweanalysisappiddailyretaininfo?access_token=ACCESS_TOKEN
```

请求参数

​	access_token 接口调用凭证

​	begin_date 开始日期. 格式yyyymmdd

​	end_date 结束日期, 限定查询1条数据, 允许设置的最大值为昨天. 格式 yyyymmdd

###### 返回值 Object

​	ref_date 日期

​	visit_uv_new 新增用户留存

​		key 标识 0开始, 表示当天, 1表示1天后, 以此类推

​		value key对应日期的新增用户数/活跃用户数

​	visit_uv 活跃用户留存. 值同上

请求数据示例		

```json
{
    "begin_date": "20170313",
    "end_date": "20170313"
}
```

返回数据示例

```json
{
    "ref_date": "20170313",
    "visit_uv_new": [
        {
            "key": 0,
            "value": 5464
        }
    ],
    "visit_uv": [
        {
            "key": 0,
            "value": 55500
        }
    ]
}
```

##### getAnalysisMonthlyRetain

本接口应在后端服务器调用

获取用户访问小程序月留存

请求地址

```
POST https://api.weixin.qq.com/datacube/getweanalysisappidmonthlyretaininfo?access_token=ACCESS_TOKEN
```

参数及返回值同上一致

##### getAnalysisWeeklyRetain

本接口应在后端服务器调用

获得用户访问小程序周留存

请求地址

```
POST https://api.weixin.qq.com/datacube/getweanalysisappidweeklyretaininfo?access_token=ACCESS_TOKEN
```

参数返回值与上一致

#### getAnalysisDailySummary

本接口应在后端服务器调用

获取用户访问小程序服务器调用

请求地址

```
POST https://api.weixin.qq.com/datacube/getweanalysisappiddailysummarytrend?access_token=ACCESS_TOKEN
```

请求参数与上一致

###### 返回值 Object 

- ref_date 日期格式 yyyymmdd
- list  数据列表
  - index 分布类型
    - access_source_session_cnt 访问来源分布
    - access_staytime_info 访问时长分布
    - access_depth_info  访问深度的分布
  - item_list 分布数据列表
    - key 场景 id
    - value 该场景 id 访问 pv
    - access_source_visit_uv 该场景范围 uv

#### getAnalysisVisitPagefa

本接口应在后端服务器调用

访问页面, 目前只提供按 page_visit_pv 排序的  top200

```
POST https://api.weixin.qq.com/datacube/getweanalysisappidvisitpage?access_token=ACCESS_TOKEN
```

### 支付

##### wx.requestPayment(Object object)

发起微信支付 [微信支付接口文档](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=1_1)

- timeStamp 当前时间戳

- nonceStr 随机字符串, 长度32字符以下

- package 统一下单接口返回的 prepay_id 参数值, 提交格式如: prepay_id = ***
- signType 签名算法, 默认 MD5
  - MD5 / HMAC-SHA256
- paySign 前面, 具体前面方案键 小程序接口文档
- success 成功回调
- ...

示例代码

```js
wx.requestPayment({
    timeStamp: '',
    nonceStr: '',
    package: '',
    signType: 'MD5',
    paySign: '',
    success(res) { },
    fail(res) { }
})
```

### 授权

##### wx.authorize(Object object)

提前当用户发起授权请求. 调用后会立即弹窗询问用户是否同意授权小程序使用某项功能或获取用户某些数据, 但不会实际调用对应接口, 如果用户之前以及同意授权, 则不出现弹窗, 直接返回成功 [用户授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)

- scope  需要获取权限的 scope [scope列表](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)
- success 成功回调
- ...

注意：wx.authorize({scope: "scope.userInfo"})，无法弹出授权窗口，请使用 <button open-type="getUserInfo"/>

示例代码

```js
// 可以通过 wx.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope
wx.getSetting({
    success(res) {
        if (!res.authSetting['scope.record']) {
            wx.authorize({
                scope: 'scope.record',
                success() {
                    // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问
                    wx.startRecord()
                }
            })
        }
    }
})
```

### 设置

##### wx.openSetting(Objedct object)

调起客户端小程序设置界面, 返回用户设置的操作结果. 设置界面只会出现小程序已经向用户请求过的权限

注意: 2.3.0 版本开始, 用户发生点击行为后, 才可以跳转打开设置页, 管理授权信息

- success 成功回调
  - authSetting 用户授权结果
- ...

```js
wx.openSetting({
    success(res) {
        console.log(res.authSetting)
        // res.authSetting = {
        //   "scope.userInfo": true,
        //   "scope.userLocation": true
        // }
    }
})
```

##### wx.getSetting(Object object)

获取用户的当前设置, 返回值中只会出现小程序向用户请求过的权限

- success 成功回调
  - res.authSetting 用户授权结果
- ...

```js
wx.getSetting({
    success(res) {
        console.log(res.authSetting)
        // res.authSetting = {
        //   "scope.userInfo": true,
        //   "scope.userLocation": true
        // }
    }
})
```

##### AuthSetting

用户授权设置信息

- scope.userInfo 是否授权用户信息, 对应接口 wx.getUserInfo
- scope.userLocation 是否授权地理位置, 对应接口 wx.getLocation, wx.chooseLoaction
- scope.address 是否授权通讯地址, 对应接口 wx.chooseAddress
- scope.invoiceTitle 是否授权获取发票, 对应接口 wx.chooseInvoice
- scope.werun 是否授权微信运动步数, 对应接口 wx.getWeRunData
- scope.record 是否授权录音功能, 对应接口 wx.startRecord
- scope.writePhotosAlbum 是否授权保存到相册  wx.saveImageToPhotosAlbum, wx.saveVideoToPhotosAlbum
- scope.camera 是否授权摄像头, 对应 <camera /> 组件

### 客服消息

##### customerTyping 

本接口应在后端服务器调用

下发客服当前输入状态给用户

请求地址及方式

```
POST https://api.weixin.qq.com/cgi-bin/message/custom/typing?access_token=ACCESS_TOKEN
```

参数

- access_token 接口调用凭证
- touser 用户的 OpenID
- command命令
  - Typing 对用户发"正在输入"状态
  - CancelTyping 取消度用户的 "正在输入"状态

返回的 JSON 数据包

- errcode 错误码
  - 45072 command 字段取值不对
  - 45080 下发输入状态, 需要之前30s内核用户有过消息交互
  - 45081 已经在输入状态, 补课重复下发
- errmsg 错误信息

请求数据示例

```
{
	"touser": "OPENID",
	"command": "Typing"
}
```

##### getTempMedia 

获取客服消息内的临时素材, 

```
GET https://api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&media_id=MEDIA_ID
```

##### sendCustomerMessage

发送客服消息给用户

```
POST https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=ACCESS_TOKEN
```

##### uploadTempMedia

把媒体文件上传到微信服务器.目前仅支持图片, 用于发送客服消息或被动回复用户消息

### 模板消息

### 统一服务消息

### 动态消息

### 插件管理

### 收货地址

##### wx.chooseAddress

调用前需要用户授权

获取用户收货地址, 调起用户编辑收货地址原生界面, 并在编辑完成后返回用户选择的地址.

- success 成功回调
  - 回调参数 res 下的属性
    - userName 收货人姓名
    - postalCode 右边
    - provinceName 国标收货地址第一级地址
    - cityName 
    - countyName
    - detailInfo 详细收货地址信息
    - nationalCode 收货地址国家码
    - telNumber 收货人手机号码
    - errMsg 错误信息
- ...

示例

```js
wx.chooseAddress({
    success(res) {
        console.log(res.userName)
        console.log(res.postalCode)
        console.log(res.provinceName)
        console.log(res.cityName)
        console.log(res.countyName)
        console.log(res.detailInfo)
        console.log(res.nationalCode)
        console.log(res.telNumber)
    }
})
```

### 卡卷

### 发票

##### wx.chooseInvoiceTitle(Object object)

调用之前需要 用户授权 scope.invoiceTitle

选择用户的发票抬头

- success 成功回调
  - 返回参数 res
    - type 抬头类型
      - 0 单位
      - 1 个人
    - title 太透名称
    - taxNumber 抬头税号
    - companyAddress 单位地址
    - telephone 手机号码
    - bankName银行名称
    - bankAccount 银行账号
    - errMsg 错误信息
- ...

##### wx.chooseInvoice(Object object)

调用钱需要用户授权 scope.invoice

选择用户已有的发票

- success 成功回调
  - res.invoiceInfo 用户选中的发票列表
    - cardId 所选发票卡卷的 cardId
    - encryptCode 所选发票卡卷的加密 code 
    - publisherAppId 发票方的 appId
- ....

### 附件的小程序

##### addNearbyPoi 

接口后端服务器调用

添加地点

请求地址&方式&参数说明

```
POST https://api.weixin.qq.com/wxa/addnearbypoi?access_token=ACCESS_TOKEN
```

- 请求参数
  - access_token 接口调用凭据
  - related_name 经营资质主体
  - related_credential 经营资质证件号
  - related_address 经营资质地址
  - related_proof_material 相关证明材料

###### 返回值 JSON 数据包

- errmsg 错误信息
- errcode 错误码
- data 返回数据 

### 二维码

### 内容安全

### 生物认证

### 微信运动

## 设备

### iBeacon

##### wx.onBeaconServiceChange(callback)

监听 iBeacon 服务状态变化事件

回调返回值res

- available 服务目前是否可用
- discovering 目前是否处于搜索状态

##### wx.onBeaconUpdate(callback)

监听 iBeacon 设备更新事件

返回值 res.beacons 当前搜索到的所有 iBeacon 设备

##### wx.getBeacons(Object object)

获取所有已搜索到的 iBeacon 设备

- success 成功回调
  - res.beacons 设备列表
- ...

##### wx.stopBeaconDiscovery(Object object)

停止搜索附件的设备

- success 成功回调
- ...

错误信息

| 错误码 | 错误信息                      | 说明             |
| ------ | ----------------------------- | ---------------- |
| 0      | ok                            | 正常             |
| 11000  | unsupport                     | 系统或设备不支持 |
| 11001  | bluetooth service unavailable | 蓝牙服务不可用   |
| 11002  | location service unavailable  | 位置服务不可用   |
| 11003  | already start                 | 已经开始搜索     |

##### wx.startBeaconDiscovery(Object object) 

开始搜索附件的 iBeacon 设备

- uuids 蓝牙设备广播 uuid 列表
- success 成功回调
- ...

##### IBeaconInfo 

属性

-  uuid 设备广播的 uuid
- major 设备的id
- minor 设备的 次id
- proximity 设备距离的枚举值
- accuracy 设备的距离
- rssi 设备的信号强度

### Wi-Fi

##### wx.stopWifi(Object object)

关闭 Wi-Fi 模块

- success 成功回调 
- ...

错误

代码示例

```js
wx.stopWifi({
    success(res) {
        console.log(res.errMsg)
    }
})
```

##### wx.startWifi(Object object) 

初始化 Wi-Fi 模块

- success 成功回调
- ...

##### wx.setWifiList(Object object)

设置 wifiList 中 AP 的相关信息

- success

### 加速计

### 电量

##### wx.getBatteryInfo(Object object)

获取设备电量

- success 成功回调
  - 参数res.level 设备电量, 1-100
  - isCharging 是否正在充电

### 剪贴板

### 罗盘

### 联系人

##### addPhoneContact(Object object)

添加手机联系人

- firstName 联系人名字
- photoFilePath 头像本地路径
- nickname 昵称
- lastname 姓氏
- middleName 中间名
- remark 备注
- mobilePhoneNumber 手机号
- weChatNumber 微信号
- addressCountry 联系地址国家
- success 成功回调
- ...

### 陀螺仪

### 方向

### 网络

##### wx.onNetworkStatusChange(callback)

监听网络状况变化事件

参数 res 属性

- isConnected 当前是否有网络连接
- networkType 网络类型
  - wifi
  - 2g/3g/4g
  - unknown Android 下不常见的网络类型
  - none 无网络

##### wx.getNetworkType(Object object)

获取网络类型

- success 成功回调
  - res.networkType 网络类型
- ...

```js
wx.getNetworkType({
    success(res) {
		const networkType = res.networkType
	}
})
```

### 电话

##### wx.makePhoneCall(Object object)

拨打电话

- phoneNumber 需要拨打的电话号码
- success 成功回调

```js
wx.makePhoneCall({
    phoneNumber: '18958849752xxx'
})
```

### 扫码

##### wx.scanCode(Object object) 

调起客户端扫码界面进行扫码

- onlyFromCamera 是否只能从相机扫码, 不允许从相册选择图片
- scanType ['barCode', 'qrCode'] 扫码类型
- success 成功回调
  - result 所扫码的内容
  - scanType 所扫码的类型
  - charSet 所扫码的字符集
  - path 所扫的吗为当前小程序的合法二维码时, 会返回此字段, 内容是二维码携带的 path
  - rawData 原始数据, base64 编码

示例

```js
// 允许从相机和相册扫码
wx.scanCode({
    success(res) {
        console.log(res)
    }
})

// 只允许从相机扫码
wx.scanCode({
    onlyFromCamera: true,
    success(res) {
        console.log(res)
    }
})
```



### 震动

##### wx.vibrateLong(Object object) 

使手机发生较长事件的震动 400ms

- success 成功回调
- ...

##### wx.vibrateShort(Object object)

使手机发生较短事件震动(15ms) iphone7/7Plus以上及Android机型生效

- success	成功接口

### 性能

##### wx.onMemoryWarning(callback)

监听内存不足警告事件

当 IOS/Android 向小程序进程发出内存警告时, 触发该事件. 触发该事件不以为小程序被杀, 大部分情况下仅仅是警告, 开发者可以在收到通知后回收一些不必要资源避免进一步加剧内存紧张

```js
wx.onMemoryWarning(function () {
    console.log('onMemoryWarningReceive')
})
```

### 低功耗蓝牙

### 蓝牙

### NFC

### 屏幕

##### wx.getScreenBrightness(Object object)

获取屏幕亮度

success 成功回调

参数  res.value 屏幕亮度

##### wx.setScreenBrightness(Object object)

设置屏幕亮度

- value 屏幕亮度值 0~1, 0 最暗, 1最亮
- success 接口调用成功的回调
- ...

##### wx.setKeepScreenOn(Object object)

设置是否保持常亮状态. 仅在小程序生效

- keepScreenOn 是否保持屏幕常亮, 必填


- success 成功回调

##### wx.onUserCaptureScreen(callback)

监听用户主动截图事件. 用户使用系统按键截屏时触发

## Worker

### wx.createWorker(scriptPath)

创建一个 Worker 线程. 目前限制最多只能创建一个 Worker

- string scriptPath worker 入口文件的绝对路径

###### 返回值 Worker

-  Worker.postMessage(Object message) 向主线程/Worker 线程发送的消息
  -  参数 Object message 需要发送的消息, 必须是一个可序列化的 JavaScript key-value形式对象

示例代码

```js
//	worker 线程中
worker.postMessage({
    msg:'hello 线程'
})
//	主线程中
const worker = wx.createWorker('workers/request/index.js')
worker.postMessage({
    msg: 'hello from main'
})
```

##### Worker.onMessage(callback)

监听主线程向当前线程发送的消息的事件

回调函数参数 res.message 主线程向当前线程发送的消息

##### Worker.terminate() 

结束当前 Worker 线程, 仅限在 worker 对象上调用

## 第三方平台

##### wx.getExtConfig(Object object)

获取第三方平台自定义的数据字段

##### wx,getExtConfigSync(Object object)

- success 调用成功回调
  - extConfig 第三方平台自定义的数据
- ...

本接口暂时无法通过 wx.canIUse 判断是否兼容, 开发者需要自行判断 wx.getExtConfig 是否存在来兼容

示例代码

```js
if (wx.getExtConfig) {
    wx.getExtConfig({
        success(res) {
            console.log(res.extConfig)
        }
    })
}
```

## WXML

### wx.createSelectorQuery()

返回一个 SelectorQuery 对象实例

```js
const query = wx.createSelectorQuery()
query.select('#text').boundingClientRect()
query.selectViewport().scrollOffset()
query.exec(function (res) {
    res[0].top // #the-id节点的上边界坐标
    res[1].scrollTop // 显示区域的竖直滚动位置
    console.log(res)
})
```

### wx.createIntersectionObserver(this, options)

创建并返回一个 IntersectionObserver 对象实例. 在自定义组件中, 可以使用 this.createIntersectionObserver([options]) 来代替

- this 自定义组件实例
- options 选项
  - thresholds 一个数值数组, 包含所有阈值
  - initialRatio 初始化相交比例, 如果调用时检测到相交比例与这个值不相等且达到阈值,则会触发一次监听器的回调函数
  - observeAll 是否同时观测多个目标节点

###### 返回值 IntersectionObserver

- IntersectionObserver.relativeTo(selector, margins) 

  - selector 选择器
  - margins 用来扩展/收缩参数节点在布局区域的边界
    - left 节点布局区域的左边界
    - right/top/bottom ...

- IntersectionObserver.relativeToViewport(margins)

  指定页面显示区域作为参照区域之一

  示例代码: 如果目标节点(.target-class)进入显示区域以下 100 px 时, 就会触发回调

  ```javascript
  Page({
      onLoad() {
          wx.createIntersectionObserver().relativeToViewport({bottom: 100}).observe('.target-class', (res) => {
              res.intersectionRatio // 相交区域占目标节点的布局区域的比例
              res.intersectionRect // 相交区域
              res.intersectionRect.left // 相交区域的左边界坐标
              res.intersectionRect.top // 相交区域的上边界坐标
              res.intersectionRect.width // 相交区域的宽度
              res.intersectionRect.height // 相交区域的高度
          })
      }
  })
  ```

- IntersectionObserver.abserve(targetSelector, callback)

   指定目标节点并开始监听相交变化情况

  - targetSelector 选择器

  - callback 监听相交状态变化的回调函数

    - res.intersectionRatio 相交比例
    - res.intersectionRect 相交区域的边界

    - res.boundingClientRect 目标边界
    - relativeRect 参照区域的边界

- IntersectionObserver.disconnect()

  停止监听, 回调函数不再触发

### NodesRef

用于获取 WXML 节点信息的对象

##### NodesRef.fields(fields)

获取节点的相关信息, 需要获取的字段在 fields 中指定. 返回值是 nodesRef 对应的 selectorQuery

- id 是否返回节点 id
- dataset 是否返回节点 dataset
- rect 是否返回节点布局位置
- size 是否返回节点尺寸
- scrollOffset 是否返回节点的 scrollTop/left 节点必须是 scroll-view/viewport
- properties 指定属性名列表, 返回节点对应属性名的当前属性值
- computedStyle 指定样式名列表, 返回节点对应样式名的当前值
- context 是否返回节点对应的 Context 对象

注意: computedStyle 的优先级高于 size, 同时存在 

```js
Page({
    getFields() {
        wx.createSelectorQuery().select('#the-id').fields({
            dataset: true,
            size: true,
            scrollOffset: true,
            properties: ['scrollX', 'scrollY'],
            computedStyle: ['margin', 'backgroundColor'],
            context: true,
        }, function (res) {
            res.dataset // 节点的dataset
            res.width // 节点的宽度
            res.height // 节点的高度
            res.scrollLeft // 节点的水平滚动位置
            res.scrollTop // 节点的竖直滚动位置
            res.scrollX // 节点 scroll-x 属性的当前值
            res.scrollY // 节点 scroll-y 属性的当前值
            // 此处返回指定要返回的样式名
            res.margin
            res.backgroundColor
            res.context // 节点对应的 Context 对象
        }).exec()
    }
})
```

##### SelectorQuery NodesRef.boundingClientRect(NodesRef.boundingClientRectCallback)

添加节点的布局位置的查询请求, 相对于显示位置, 以像素为单位, 功能类似于 DOM 的 getBoundingClientRect. 返回 NodesRef 对应的 SelectorQuery

- 回调函数, 在执行 SelectorQuery.exec 方法后, 节点信息会在 callback 中返回
  - id 节点ID
  - dataset 节点的 dataset
  - l/r/b/t 边界坐标
  - w/h 节点的宽高

###### 返回值 SelectorQuery

```js
Page({
    getRect() {
        wx.createSelectorQuery().select('#the-id').boundingClientRect(function (rect) {
            rect.id // 节点的ID
            rect.dataset // 节点的dataset
            rect.left // 节点的左边界坐标
            rect.right // 节点的右边界坐标
            rect.top // 节点的上边界坐标
            rect.bottom // 节点的下边界坐标
            rect.width // 节点的宽度
            rect.height // 节点的高度
        }).exec()
    },
    getAllRects() {
        wx.createSelectorQuery().selectAll('.a-class').boundingClientRect(function (rects) {
            rects.forEach(function (rect) {
                rect.id // 节点的ID
                rect.dataset // 节点的dataset
                rect.left // 节点的左边界坐标
                rect.right // 节点的右边界坐标
                rect.top // 节点的上边界坐标
                rect.bottom // 节点的下边界坐标
                rect.width // 节点的宽度
                rect.height // 节点的高度
            })
        }).exec()
    }
})
```



##### SelectorQuery NodesRef.scrollOffset(NodesRef.scrollOffsetCallback)

添加节点的滚动位置查询请求, 以像素为单位, 节点必须是 scroll-view 或者 viewport 返回 NodesRef 对应的 SelectorQuery

- 回调函数, 在执行 SelectorQuery.exec 方法后, 节点信息会在 callback 中返回
  - 回调返回值 res
    - id 节点的ID
    - dataset 节点的 dataset
    - scrollLeft/scrollTop 节点水平/竖直 滚动位置

###### 返回值 SelectorQuery

```js
Page({
    getScrollOffset() {
        wx.createSelectorQuery().selectViewport().scrollOffset(function (res) {
            res.id // 节点的ID
            res.dataset // 节点的dataset
            res.scrollLeft // 节点的水平滚动位置
            res.scrollTop // 节点的竖直滚动位置
        }).exec()
    }
})
```

##### SelectorQuery NodesRef.context(NodesRef.contextCallback)

添加节点的 Context 对象查询请求. 支持 VideoContext, CanvasContext, LivePlayerContext 和 MapContext 的获取

- 回调函数在执行 SelectorQuery.exec 方法后, 返回节点信息
  - 回调参数 res
    - context  节点对应的 Context 对象 

###### 返回值 SelectorQuery

```js
Page({
    getContext() {
        wx.createSelectorQuery().select('.the-video-class').context(function (res) {
            console.log(res.context) // 节点对应的 Context 对象。如：选中的节点是 <video> 组件，那么此处即返回 VideoContext 对象
        }).exec()
    }
})
```

### SelectorQuery

查询节点信息的对象

方法

##### SelectorQuery.in(Component component)

将选择器的选取范围修改为自定义组件 component 内. (初始选择器竞选去页面范围节点)

##### SelectorQuery.select(selector)

在当前页面下选择第一个匹配选择器 selector 的节点, 返回 NodesRef 对象实例, 用于获取节点信息

##### SelectorQuery.selectAll(selector) 

在当前页面下选取匹配选择的器 selector 的所有节点

##### SelectorQuery.selectViewport()

选择显示区域, 可以用于获取显示区域的尺寸, 滚动位置等信息

##### SelectorQuery.exec(callback)

执行所有的请求, 请求结果按请求次序构成数组, 在callback 的第一个参数中返回

# 组件*

## 视图容器

### view

视图容器

- hover-class    指定按下的样式类, 当hover-class="none" 时, 没有点击效果
- hover-stop-propagation 指定是否阻止本节点的祖先节点出现点击状态(冒泡)
- hover-start-time  按住多久后出现点击态, ms
- hover-stay-time 松开后点击态保留时长

### scroll-view 

可滚动视图区域

- scroll-x  允许横向滚动
- scroll-y  允许纵向滚动
- upper-threshold  距离顶部/左边多少距离触发 scrolltoupper 事件
- lower-threshold 距离底部/右边多少距离触发 scrolltolower 事件
- scroll-top 设置竖向滚动条位置
- scroll-left 设置横向滚动条位置
- scroll-into-view 值为某一子元素的 id(不能以数字开头), 设置哪个方向滚动. 则在哪个方向滚动到该元素
- scroll-with-animation  设置滚动条位置时使用动画过渡
- enable-back-to-top IOS点击顶部状态栏, 安卓双击标题栏时, 滚动条返回顶部, 只支持竖向
- bindscrollupper 滚动到顶部/左边, 会触发 scrolltoupper 事件
- bindscrolltolower 滚动到底部/右边, 会触发 scrolltolower 事件
- bindscroll 滚动时触发

### swiper 

滑块视图容器

- indicator-dots  是否显示面板指示点
- indicator-color  指示点颜色
- indicator-active-color 指示点选中颜色
- autoplay 是否自动切换
- current 当前所在滑块 index
- current-item-id 当前所在滑块的 item-id, 不能与 current 同时指定
- interval 自动切换时间间隔
- duration 滑动动画时长
- circular 是否采用衔接滑动(循环)
- vertical 滑动方向是否为纵向
- previous-margin 前边距. 可用于露出前一项的一小部分, 接收 px 和 rpx
- next-margin 后边距, 可用于露出后一项的一小部分
- display-multiple-items 同时显示的滑块数量
- skip-hidden-item-layout 是否跳过未显示的滑块布局, true 则可优化复杂情况下的滑动性能
- bindchange current 改变时触发函数
- bindtransition    swiper-item 位置发生变化时会触发 transition 事件
- bindanimationfinish    动画结束时, 触发animationfinish 事件

### movable-view

可移动的视图容器, 在页面中可以拖拽滑动

- direction  移动方向, all/vertical/horizontal/none
- inertia 是否带有惯性
- out-of-bounds 超出可视区后是否还可以移动
- x 定义x轴方向的偏移量, 如果x轴不在可移动范围内, 会自动移动到可移动方
- y 定义 y 轴方向的偏移量, 同上
- damping 阻尼系数, 用于控制 x/y 改变时的动画和过界动画回弹的动画, 值越大移动地越快
- friction 摩擦系数, 用于控制惯性滑动的动画, 值越大摩擦力越大, 滑块越快停止, >0
- disabled 是否禁用
- scale 是否支持双指缩放, 默认缩放瘦小生效区域是在移动视图容器内
- scale-min 定义缩放倍数最小值
- scale-max 定义缩放倍数最大值
- scale-value 定义缩放倍数 0.5-10
- animation 是否使用动画
- bindchange 拖动过程中触发的事件
- bindscale 缩放过程中触发的事件

两个特殊事件

- htouchmove 初次手指触摸后移动为横向的移动, 如果 catach 此事件, 以为这 touchmove 也被 catch
- vtouchmove 初次手指触摸后移动为纵向的移动

**注意** movable-view 必须在 <movable-area /> 组件中, 且必须是直接子节点

#### movable-area

movable-view 的可移动区域

- scale-area 当里面的 movable-view 设置为支持双指缩放时, 设置此值可将缩放手势生效区域修改为整个 movable-area

movable-area 必须设置 width 和 height属性

当movable-view 小于 movable-area 时, movable-view 的移动范围是在 movable-area 内

当movable-view 大于 movable-area时, movable-view 的移动范围必须包含 movable-area (x, y 方向分开考虑)

### cover-view

覆盖在原生组件上的文本视图

覆盖在原生组件之上的文本视图, 可覆盖的原生组件包括 map/ video/ canvas/ camera/ live-player /live-pusher 只支持嵌套 cover-view 和 cover-image, 可以在 cover-view 上使用 button

- scroll-top 设置顶部滚动偏移量, 在设置了 scroll-y: scroll成为滚动元素之后生效

### cover-image

覆盖在原生组件之上的图片视图, 可覆盖的原生组件同 cover-view, 支持嵌套在 cover-view 中

- src 图片路径, 暂不支持 base64
- bindload 图片加载成功时触发
- binderror 图片加载失败时触发

## 基础内容

### icon

图标

- type  icon的类型, 有效值: success/ success_no_circle/ info/ warn/ waiting / cancel /download/ search / clear
- size  icon的大小, 单位px
- color icon颜色, 同 css 的color

```html
<icon type="success" size="56rpx" color="#368" />
```

### text

文本

- selectable  文本是否可选, 默认 false
- space 显示连续空格, 默认 false
  - ensp 中文字符空格一半大小
  - emsp 中文字符空格大小 
  - nbsp 根据字体设置空格大小
- decode 是否解码, 默认 false

decode 可以解析的有 `&nbsp;` `&lt;` `&gt;` `&amp;` `&apos;`  `&emsp;` `&ensp;`

<text> 组件内只支持 \<text> 嵌套

除了文本能借你到哪以外的其他节点都无法长按选中

### rich-text

富文本

### progress

进度条

- percent 百分比 0 ~ 100
- show-info 进度条右侧显示百分比
- border-radius 进度条圆角大小
- font-size  文字大小
- stroke-width 进度条宽度
- color 已选择进度条颜色(推荐使用 activeColor)
- activeColor 已选择进度条颜色
- backgroundColor 未选择进度条颜色
- active 动画从左万往右的动画
- active-mode backwards 动画从头开始  forwards 动画从上次结束点继续
- bindactiveend 动画完毕事件

## 表单组件

### button

按钮

- size	按钮大小, 默认default
  - defalut 默认大小
  - mini 小尺寸
- type 按钮样式类型
  - default 白色
  - primary 绿色
  - warn 红色
- plain 按钮是否镂空, 背景色透明
- disabled 是否禁用
- loading 名称齐纳是否带 loading 图标
- form-type 用于 <form>组件, 点击分别触发 <form> 组件的 submit/reset 事件
  - submit 提交表单
  - reset 重置表单
- open-type 微信开放能力
  - contact 打开客服会话, 如果用户在会话中点击消息卡片返回小程序, 可以从 bindcontact 回调中获得具体信息
  - share 触发用户转发
  - getUserInfo 获取用户信息, 可以从bindgetuserinfo 回调中获得用户信息
  - getPhoneNumber 获取用户手机号, 可以从bindgetphonenumber回调中获得用户信息
  - launchApp 打开 APP, 可以通过 app-parameter 属性设定向 APP 传的参数
  - openSetting 发开授权设置页
  - feedback 打开 "意见反馈" 页面, 用户可以提交反馈内容并伤处你日志, 开发者可以登录小程序管理后台进入左侧菜单客服反馈页面获取到反馈内容 
- hover-class 指定按钮按下去的样式类, 当为none时没有点击态效果
- hover-stop-propagation 指定是否阻止本节点的祖先节点出现点击态
- hover-start-time 按住后多久出现点击态
- hover-stay-time 手指松开后点击态保留时间
- lang 指定返回用户信息的语言, zh_CN 简体中文 (open-type="getUserInfo")

- bindgetuserinfo 用户点击该按钮时, 会返回获取到的用户信息, 回调的 detail 数据与 wx.getUserInfo 返回的一致 (open-type="getUserInfo")
- session-form 会话来源 (open-type="contact")
- send-message-title 会话内消息卡片标题  (open-type="contact")
- send-message-path 会话内消息卡片点击跳转小程序路径 (open-type="contact")
- send-message-img 截图, 会话内消息卡片的图片 (open-type="contact")
- send-message-card 会话内消息卡片 (open-type="contact")
- bindcontact 客服消息回调  (open-type="contact")
- bindgetphonenumber 获取用户手机号回调 (open-type="getPhoneNumber")
- app-parameter 打开APP时, 向 APP 传递的参数 (open-type="launchApp")

- binderror 使用开放能力时, 发生错误的回调 (open-type="launchApp")
- bindopensetting 再打开授权设置页后回调 (open-type="openSetting")

##### 注意: 

1. button-hover 默认值为`{background-color: rgba(0,0,0,/1); opacity: 0.7;}`
2. bindgetphonenumber 自 1.2.0 开始支持, 低版本无法使用 canIUse 进行检测, 建议使用基础库版本进行判断
3. 在 bindgetphonenumber 等返回加密信息的回调中调用 wx.login 登录, 可能会刷新登录态, 此时服务器使用 code 换区的 sessionKey 不是加密时使用的 sessionKey, 导致解密失败. 建议开发者提前进行 login, 或者在回调中先使用 checkSession 进行登录态检查, 避免 login 刷新登录态
4. button 可作为原生组件的子节点嵌入, 以便在原生组件上使用 open-type 的能力

### checkbox-group

多项选择器, 有多个 checkbox 组成

- bindchange <checkbox-group> 中选项发生改变是触发 change 事件, detail = { value: [选项中checkbox 的value 值]}

##### checkbox 多选项目

- value <checkbox> 标识, 选中时触发 <checkbox-group> 的change事件, 并携带本身value
- disabled 是否禁用
- checked 当前是否选中, 可用来设置默认选中
- color checkbox 的颜色, 同 css 的 color

### form

表单, 将组件中用书输入的 <switch> <input> <checkbox> <radio> <picker> 提交

当点击 <form> 表单中 form-type 为 submit 的 <button> 组件时, 会将表单的 value 值进行提交, 需要给表单指定 name 值作为提交标识(key)

- report-submit 是否返回 formId 用于发送模板消息
- bindsubmit 携带 form 中的数据触发 submit 事件, `event.detail = {value: {'name':'value'}, formId: ''}`
- bindreset 表单重置时触发 reset 事件

### input

输入框. 该组件是原生组件

- value 输入框初始内容
- type   input 的类型
  - text 文本输入键盘
  - number 数字输入键盘
  - idcard 身份证输入键盘
  - digit 带小数点的数字键盘
- password 是否密码类型
- placeholder 输入框为空时占位符
- placeholder-style 指定 placeholder 样式
- placeholder-class 指定 placeholder 的样式类
- disabled 是否禁用
- maxlength 最大输出长度, -1表示不限制
- cursor-spacing 指定光标与键盘的距离, 单位 px. 取input 距离底部的距离和cursor-spacing 指定距离的最小值作为贯标与键盘的距离
- focus 自动聚焦, 拉起键盘
- confirm-type 设置键盘右下角的文字, 仅在 type = 'text' 时生效
  - send 右下角按钮为 "发送"
  - search 右下角按钮为 "搜索"
  - next 右下角按钮为 "下一个"
  - go 右下角按钮为 "前往"
  - done 右下角按钮为 "完成"
- confirm-hold 点击键盘有效较按钮时是否保持键盘不收起
- cursor 指定 focus 时光标位置
- selection-start 光标起始位置, 自动聚焦时有效, 需要与 selection-end 配合使用
- selection-end 光标结束位置
- adjust-position 键盘弹起时, 是否自动上推页面, 默认 true
- bindinput 键盘输入时触发, `event.detail` keyCode为键值, 处理函数可以直接 return 一个字符串, 将替换成输入框的内容
- bindfocus 输入框聚焦时触发  event.detail
- bindblur 输入框失去焦点时触发  event.detail
- bindconfirm 点击完成按钮时触发  event.detail

### label 

用来改进表单组件可用性, 使用 for 找到 对应id, 或将控件放到该标签下, 点击时就触发对应控件.

for 优先级高于内部控件, 内部若多个控件则触发第一个

目前可以绑定的控件有 <button> <checkbox> <radio> <switch>

- for 绑定控件的id

### picker

从底部弹起的滚动选择器, 支持5种选择器, 使用 mode 控制, 默认是普通选择器

##### 普通选择器 mode = selector

- range 默认[], mode 为 selector/multiSelector时, range有效
- range-key 当 range是一个 Object Array时, 可以通过 range-key 来指定 Object 中 key 的值作为选择器显示内容
- value 默认0, value的值表示选择了 range 中的第几个(下标0开始)
- bindchange value改变时触发 change 事件 detail.value
- disabled 是否禁用
- bindcancel 取消选择或点遮罩层收起 picker 时触发

##### 多列选择器: model = multiSelector

- range  二维 Array/二维 Object Array. mode 为 select/multiSelector 时有效, 二维数组, 长度表示多少列, 数组每项表示每列数据, 如 [['a','b'], ['c','d']] / [[{id:1, name:'美丽'},{id:2,name:'善良'},{id:3,name:'么么哒'}],[{id:1, gender:'女'}, {id:0,gender:'男'},{id:2,name:'保密'}] **这里的对象数组我有点懵!!**
- bindchange value 改变时触发change事件
- bindcolumnchange 某一列的值改变时触发 columnchange函数 detail.column 表示第几列 detail.value 表示变更值的下标
- bindcancel 取消选择时触发

##### 时间选择器 mode = time

- value 表示选中事件 hh:mm
- start 表示有效时间范围开始, 字符串格式为 "hh:mm"
- end 表示有效时间范围的结束
- bindchange value改变时触发 change 事件 detail.value
- bindcancel 取消选择时触发
- disabled 是否禁用

##### 日期选择器 mode = date

- value 表示选中的日期 格式 "YYYY-MM-DD"
- start 有效日期范围的开始
- end 有效日期范围的结束
- fields 有效值 year,montgh,day 表示选择器的粒度, 默认 day
- bindchange value 改变时触发change 事件 
- bindcancel 取消选择时触发
- disabled 是否禁用

##### 省市选择器 mode = region

- value 表示选中的省市区, 默认选中每一列第一个值
- custom-item 可为每一列的顶部添加一个自定义项
- bindchange value 改变时触发 change 事件, detail.code 表示区划分代码, postcode 是邮政
- disabled 是否禁用

### picker-view

嵌入页面的滚动选择器

- value NumberArray 数组中的数字依次表示 picker-view 内的 picker-view-column 选择的第几项(0开始), 数字大于可选长度时, 选择最后一项
- indicator-style 设置选择器中间选中框的样式
- indicator-class 设置选择器黄总监选中框的样式类
- mask-style 设置蒙层样式
- mask-class 设置蒙层样式类
- bindchange 滚动选择时, value 改变时触发change事件 event.detail
- bindpickstart 滚动选择开始时候触发事件
- bindpickend 滚动选择结束时触发事件

其中仅能放置 <picker-view-column /> 组件

### radio-group

单项选择器, 内部由多个 <radio> 组成

- bindchange  组件内部发生改变触发 change 函数

##### radio

单选项目

- value <radio> 标识. 当 <radio> 选中时, <radio-group> 的 change 事件会携带 <radio> 的 value
- checked 当前是否选中
- disabled 是否禁用
- color <radio>颜色, 同 css 的 color

### slider

滑动选择器

- min 最小值
- max 最大值
- step 步长
- disabled 是否禁用
- value 当前值
- color 背景条颜色(使用backgroundColor)
- selected-color 已选择的颜色(activeColor)
- activeColor 已选择的颜色
- backgroundColor 背景条颜色
- block-size 滑块大小, 取值范围 12-28
- block-color 滑块颜色
- show-value 是否显示当前 value
- bindchange 完成一次拖动后触发的事件, event.detail
- bindchanging 拖动过程中触发的事件 event.detail

### switch 

开关选择器

- checked	是否选中
- disabled 是否禁用
- type 样式
  - switch
  - checkbox
- bindchange checked 改变时触发函数
- color switch 颜色

### textarea

多行输入框, 该组件是原生组件

- value 输入框的内容
- placeholder 输入框空时占位符
- placeholeder-style 指定占位符样式
- placeholder-class 指定占位符样式类
- disabled 是否禁用
- maxlength 最大长度
- focus textarea聚焦, 键盘拉起
- auto-height 是否自动增高
- fixed 如果textarea 是一个  position:fixed 的区域, 需要显示指定属性 fixed 为 true
- cursor-spacing 指定光标与键盘的距离 取光标底部距离与cursor-spacing 指定的距离最小值作为光标与键盘的距离
- cursor 指定 focus 时光标的位置
- show-confirm-bar 是否显示键盘上方带有 "完成" 按钮一栏
- selection-start 光标起始位置, 自动聚焦时有效, 需要 selection-end配合
- selection-end 光标结束为止
- adjust-position 键盘弹起时, 是否自动上推页面
- bindfocus 输入框聚焦时触发 event.detail.height 表示键盘高度
- bindblur 输入框失去焦点时触发
- bindlinechange 输入框行数变化时调用
- bindinput 键盘输入时, 触发 input 事件
- bindconfirm 点击完成时 触发 confirm 事件

## 导航

### navigator

页面链接

- target 在哪个目标上发生跳转, 默认当前小程序, 可选值 self/miniProgram
- url 当前小程序内跳转链接
- open-type 跳转方式
  - navigate 对应 wx.navigateTo /wx.navigateToMiniProgram
  - redirect 对应 wx.redirectTo 关闭某个页面, 跳转到 非 tab 页面
  - switchTab 对应 wx.switchTab 打开 tab 页面, 关闭非 tab 页面
  - reLaunch 对应 wx.reLaunch 关闭所有页面, 打开某
  - navigateBack 对应 wx.navigateBack
  - exit 推出小程序  target 为 'miniProgram' 时有效
- delta 当open-type为 'navigateBack' 有效, 表示回退层数
- app-id 当target 为 'miniProgram' 时有效, 表示要打开的小程序 appId
- path 当target 为 'miniProgram' 时有效, 表示打开页面路径, 空则打开首页
- extra-data 当target 为 'miniProgram' 时有效, 表传递给小程序的数据, 在 App.onLaunch() App.onShow() 获取
- version 当 target="minProgram" 时有效, 要打开的小程序版本
  - develop 开发版
  - trial 体验版
  - release 正式版
- hover-class 指定点击时的样式类, none表示没有点击效果
- hover-stop-propagation 指定是否阻止本节点的祖先节点出现点击态
- hover-start-time 按住多久出现点击态
- hover-stay-time 手指松开后点击态保留时间
- bindsuccess 当 target = 'miniProgram' 时有效, 跳转小程序成功
- bindfail 同上, 跳转失败
- bindcomplete 同上, 跳转完成

使用限制

1. 需要用户确认跳转 

   在跳转至其他小程序前, 将统一增加弹窗, 询问是否跳转, 用户确认后才可以跳转至其他小程序, 如果 用户点击取消, 则回调 fail cancel

2. 每个小程序可以跳转的其他小程序数量限制为不超过10 个

   开发者提交新版小程序代码时, 如果使用了跳转/其他小程序功能, 则需要在代码配置中声明将要跳转的小程序名单, 限制不超过10个, 否则无法通过审核.名单在发布新版本时更新, 不支持动态修改. 

### functional-page-navigator

仅在插件中有效, 用于跳转到插件功能页

- version 跳转到小程序版本, 有效值 develop(开发版), trial(体验版), release(正式版) **线上版本必须设置为 release** 
- name 跳转到功能页
  - loginAndGetUserInfo 用户信息功能页
  - requestPayment 支付功能页
- args 功能页参数, 参数格式与具体功能页相关
- bindsuccess 功能页返回, 且操作成功时触发, detail 格式与具备功能页相关
- bindfail 功能页返回, 且操作失败时触发

## 媒体组件

### audio

音频, 建议使用更强的 wx.createInnerAudioContext 接口

- id audio 组件唯一标识符
- src 播放音频资源地址
- loop 是否循环播放
- controls 是否显示默认控件
- poster 默认控件上音频封面图片资源地址
- name 默认控件上音频名字 
- author 默认控件上音频作者
- binderror 当发生错误时触发 error 事件 detail.errMsg
  - 1 获取资源被用户禁止
  - 2 网络错误
  - 3 解码错误
  - 4 不合适资源
- bindplay 当开始/继续播放时触发 play 事件
- bindpause 当暂停播放时触发 pause 事件
- bindtimeupdate 当播放进度改变时触发的 timeupdate 事件
- bindended 播放到末尾时触发 ended 事件

### image

图片 

- src 图片资源地址
- mode 图片缩放, 裁剪模式
  - scaleToFill 不包吃纵横比缩放, 完全拉伸直至填满 image 元素
  - aspectFit 保持纵横比缩放图片. 图片长边能完全显示出来
  - aspectFill 保持纵横比缩放图片. 只保证图片的短边能够完全显示出来. 截取
  - top 不缩放图片, 只显示图片的顶部区域
  - ...
- lazy-load 图片懒加载, 只针对 page 与 scroll-view 下的 image 有效
- binderror 当发生错误时, 发布到 AppService 的事件名
- bindload 当图片加载完毕时, 发布到 AppService 的事件名 event.detail.heigh/width

注意: image组件默认宽度 300px, 高255px; image组件中二维码/小程序码不支持长按识别. 仅在 wx.previewImage 中支持长按识别

### video

视频. 该是原生组件

- src  要播放视频的资源地址
- initial-time 指定视频初始播放位置
- duration 指定视频时长
- controls 是否显示默认播放控件
- danmu-list 弹幕列表
- danmu-btn 是否显示弹幕按钮
- enable-danmu 是否显示弹幕列表
- autoplay 自动播放
- loop 循环播放
- muted 静音播放
- page-gesture 非全屏模式下, 是否开启亮度与音量调节手势
- direction 设置全屏是视频的方向, 不指定则根据宽高比自动判断  0正常竖向 90频密逆时针90度 -90品目顺时针90度
- show-progress 是否显示进度条, 如果不设置, 宽度大于240时显示
- show-fullscreen-btn 是否显示全屏按钮
- show-play-btn 是否显示视频底部控制栏播放按钮
- show-center-play-btn 是否显示视频中间的播放按钮
- enable-progress-gesture 是否开启控制进度手势
- objectFit 当视频大小与 video 容器大小不一致时, 视频的表现是形式. contain:包含 full填充 cover 覆盖
- poster 视图封面的图片网络资源地址
- bindplay 开始/继续播放时触发 play 事件
- bindpause 暂停播放触发 pause 事件
- bindended 播放到末尾时触发 ended 事件
- bindtimeupdate 播放进度条发生变化时触发 
- bindfullscreenchange 视频进入和退出全屏时触发
- bindwaiting 时出现缓冲时触发
- binderror 视频播放出错时触发
- bindprogress 加载进度变化时触发, 只支持一段加载

<video> 默认宽度300px 高度225

### camera

系统相机 , 该组件是原生组件

需要用户授权 scope.camera

- mode 有效值nomal/scanCode
- device-position 前置/后置 front, back
- flash 闪光灯
- bindstop 摄像头在非正常终止时触发(退出后台)
- binderror 用户不允许使用摄像头时触发
- bindscancode 扫码识别成功时触发, mode = scanCode 时有效

相关api: wx.createCameraContext

同一个页面只能插入一个camera 组件

### live-player

实时视频播放. 该组件是原生组件

暂只针对国内主体如下类目的小程序开放. 需要先通过类目审核, 再在小程序管理后台, "设置" - "接口设置" 中自助开通该组件权限

- 社交 
  - 直播
- 教育
  - 在线机构
- 医疗
  - 互联网医院, 公立医院
- 政务民生
  - 所有二级类目
- 金融
  - ....
  - ​

属性信息

-  src 音频地址. 目前只支持 flev rtmp 格式
- mode live(直播), RTC (实时通话, 该模式时延迟更低)
- autoplay 自动播放
- muted 是否静音
- orientation 画面方向
- object-fit 填充模式: contain, fillCrop
- min-cache 最小缓冲区, 单位s
- max-cache 最大缓冲区
- bindstatechange 播放状态变化事件
- bindfullscreenchange 全屏变化事件
- binnetstatus 网络状态通知

相关api: wx.createLivePlayerContext

### live-pusher

实时视频录制, 该组件时原生组件

需要用户授权 scope.camera / scope.record

## 地图

### map 

地图, 该组件是原生组件, 个性化地图能力可在小程序后台 "设置-开发者工具-腾讯位置服务" 申请开通. 设置 subkey后, 小程序内的地图组件均会使用该底图效果

个性化底图暂不支持工具中测试

- longitude 中心经度
- latitude 中心纬度
- scale 缩放级别 5-18
- markers 标记点
  - 标记点用于在地图上显示标记的位置
    - id 标记id marker点击事件回调会返回此 id, 建议每个 marker 设置上 Number 类型的 id 保证更新marker时有更好的性能
    - latitude 纬度
    - longitude 经度
    - title 标记点名
    - zIndex 显示层级
    - iconPath 显示的图标
    - rotate 旋转的角度
    - alpha 标注的透明度
    - width 标注图标宽度
    - height 标注图标高度
    - callout 自定义标注点上方的气泡窗口
      - content 文本
      - color 文本颜色
      - fontSize 文字大小
      - borderRadius 边框圆角
      - borderWdith 边框宽度
      - borderColor 边框颜色
      - bgColor 背景色
      - padding 文本边缘留白
      - display  BYCLICK 点击显示/ALWAYS 常显
      - textAlign 文本对齐方式. 有效值 left/right/center
    - label 为标注点旁边增加标签
    - anchor 经纬度在标注图标的锚点
    - ...
- polyline 路线
- polygons 多边形
- circles 圆
- controls 控件(即废弃, 建议使用 cover-view)
- include-points 缩放视野以包含所有给定的坐标点
- show-location 显示带有方向的当前定位点
- subkey 个性化底图使用key 
- enable-3D 显示 3d 楼快
- show-compass 限制指南针
- enable-overlooking 开启俯视
- enable-zoom 是否支持缩放
- enable-scroll 是否支持拖动
- enable-rotate 是否支持旋转
- bindmarkertap 点击标记点时触发, 返回 marker 的 id
- bindcallouttap 点击标记点对于的气泡时触发, 返回同上
- bindcontroltap 点击控件时触发, 返回 control 的id
- bindregionchange 视野发送变化时触发
- bindtap 点击地图触发
- bindupdated 地图渲染完成触发
- bindpoitap 点击地图 poi 点时触发

## 画布

### canvas

画布, 该组件是原生组件

- canvas-id canvas 组件的唯一标识符
- disable-scroll  默认false, 在canvas 中移动时且有绑定手势事件, 禁止屏幕滚动以及下拉刷新
- bindtouchstart  手势触摸事件开始
- bindtouchmove 手势触摸后移动
- bindtouchend 手势触摸动作结束
- bindtouchcancel 收拾出没动作被打断, 如来电等
- bindlongtap 手指长按 500ms触发 触发长按事件后进行移动不会触发屏幕的滚动
- binderror 错误事件

canvas 默认宽度 300 225 

同一页面中的 canvas-id 不可重复, 如果使用一个已经出现过的 canvas-id, 该 canvaas 标签对应的画布将被隐藏并不再正常工作

相关 api : wx.createCanvasContext

## 开放能力

### open-data

用于展示微信开放的数据

- type 开放数据类型
  - groupName 拉取群名称
  - userNickName y用户昵称
  - userAvatarUrl 用户头像地址
  - userGender 用户性别
  - userCity  用户所在城市
  - userProvince 用户所在省份
  - userCountry  用户所在国家
  - userLanguage 用户的语言
- open-gid 当type 为 groupName 时生效, 群 id
- lang type='user*' 时生效, 以何种语言展示 userInfog

关于open-gid的获取, 使用 wx.getShareInfo

### web-view

web-view 组件时一个可以用来承载网页的容器, 会自动铺满整个小程序页面. 个人和海外类型小程序暂不支持

- src web-view 指向网页链接. 可打开关联公众号的文章, 其他网页需要登录小程序管理后台配置业务域名
- bindmessage 网页向小程序 postMessage 时, 会在特定时机(小程序后退, 组件销毁, 分享) 触发并收到消息
- bindload 网页加载成功时触发此事件
- binderror 网页加载失败时触发此事件

示例

```html
<!-- 指向公众平台首页的 web-view -->
<web-view src="https://mp.weixin.qq.com"></web-view>
```

相关接口: 

<web-view> 网页中可以使用 JSSDK 提供的捷库返回小程序页面, 支持的接口有

| 接口名                      | 说明                 | 最低版本                                                     |
| --------------------------- | -------------------- | ------------------------------------------------------------ |
| wx.miniProgram.navigateTo   | 参数与小程序接口一致 | [1.6.4](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.navigateBack | 参数与小程序接口一致 | [1.6.4](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.switchTab    | 参数与小程序接口一致 | [1.6.5](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.reLaunch     | 参数与小程序接口一致 | [1.6.5](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.redirectTo   | 参数与小程序接口一致 | [1.6.5](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.postMessage  | 向小程序发送消息     | [1.7.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| wx.miniProgram.getEnv       | 获取当前环境         | [1.7.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

相关接口2

<web-view> 网页中经支持以下 JSSDK 接口

- 判断客户段是否支持js  checkJSApi

- 图像接口
  - 拍照或上传 chooseImage
  - 预览图片 previewImage
  - 上传图片 uploadImage
  - 下载图片 downloadImage
  - 获取本地图片 getLocallmgData
- 音频接口
  - 开始录音 startRecord
  - 停止录音 stopRecord
  - 监听录音自动停止 onVoiceRecordEnd
  - 播放语音 playVoice
  - 暂停播放 pauseVoice
  - 停止播放 stopVoice
  - 监听语音播放完毕 onVoicePlayEnd
  - 上传接口 uploadVoice
  - 下载接口 downloadVoice

- 智能接口
  - 识别音频 translateVoice
- 设备信息
  - 获取网络状态 getNetworkType
- 地理位置
  - 使用内置地图打开地点 openLocation
  - 获取地理位置 getLocation
- 摇一摇周边 
  - 打开ibeacon startSearchBeacons
  - 关闭ibeacon stopSearchBeacons
  - 监听ibeacon onSearchBeacons
- 微信扫一扫
  - 调起微信扫一扫 scanQRCode
- 微信卡卷 
  - 拉取使用微信卡劵列表 chooseCard
  - 批量增加卡劵接口 addCard
  - 查看微信卡包的卡卷 openCard
- 长按识别 
  - 小程序圆形码

相关接口3

用户分享时可获取当前 <web-view> 的URL, 即在 onShareAppMessage 回调中返回 webViewUrl 参数.

相关接口4

在网页内可通过 window.__wxjs_environment 变量判断是否在小程序环境, 建议在 WeixinJSBridgeReady 回调中使用, 也可以使用 JSSDK 提供的 getEnv 接口

相关接口5

从卫星7.0.0开始, 可以通过判断 userAgent 中包含 miniProgram 来判断小程序 web-view 环境

### ad

广告, 目前暂时以邀请制开放申请

- unit-id  广告单元id, 可以在小程序管理后台的流量主模块新建
- bindload  广告加载成功的回调
- binderror 广告发生错误触发事件

监听到 error 回调后, 开发者可以正对性的处理, 比如隐藏广告组件的父容器, 以保证用户体验, 但是不要移除广告组件, 否则无法收到 bindload 的回调

### official-account

用户扫码打开小程序时, 开发者可以在小程序内配置公众号关注组件, 方便用户快捷关注公众号,可嵌套在原生组件中	

1. 使用组件前, 需要前往小程序管理后台, 在 "设置" -> "接口设置" -> "公众号关注组件" 中设置要展示的公众号

设置的公众号主体要和小程序主体一致

2. 在一个小程序的生命周期内, 只有从以下场景进入小程序, 才具有展示引导关注公众号组件的能力
   - 当小程序从扫我二维码场景(1011)打开时
   - 当小程序从扫小程序码场景 (1047) 打开
   - 当小程序从聊天顶部场景(1089) 中[最近使用]内打开时, 若小程序之前未被销毁, 则该组件保持上一次打开小程序时的状态
   - 当从其他小程序返回小程序(1038)时, 若之前未被销毁, 则该组件保持上一次打开状态
3. 组件限定最小宽度为 300px 高度为定值 84ox
4. 每个页面只能配置一个该组件

- bindload 组件加载成功时触发

- binderror 组件加载失败时触发

  detail 对象

  - status 状态码
    - -2 网络错误
    - -1 数据解析从未
    - 0 加载错误
    - 1 小程序关注公众号功能被封禁
    - 2...
  - errMsg 错误信息

示例代码

```html
<official-account></official-account>
```

## 原生组件说明

小程序中的部分组件是由客户端创建的原生组件, 这些组件有

- camera
- canvas
- input
- live-player
- live-pusher
- map
- textarea
- video

### 原生组件的使用限制

因为原生组件脱离在 webView 渲染流程外, 所以

- 原生组件的层级是最高的, 所以页面中的其他组件无论 z-index 多少, 都无法改在原生组件上
  - 后插入的原生组件可以覆盖之前的原生组件
- 元素组件还无法在 scroll-view swiper picker-view movable-view 中使用
- 部分css样式无法应用于原生组件
  - 无法对原生组件使用 CSS动画
  - 无法定义原生组件位诶 position: fixed
  - 不能在父节点使用 overflow:hidden 来裁剪原生组件的显示区域
- 元素组件的事件监听不能使用 bind:eventname 的写法, 只支持 bindeventname . 原生组件也不支持 catch 和 capture 的事件绑定方式
- IOS 下原生组件不支持触摸相关事件
- 原生组件会遮挡 vConsole 弹窗弹出的调试面板

在工具上, 原生组件是用 web 组件模拟的, 因为很多情况不能很多地还原真机表现, 建议开发者使用原生组件时近来在真机上进行调试

### cover-view 和 cover-image

为了解决原生组件层级最高的限制, 小程序专门提供了 cover-view 和 cover-image 组件, 可以覆盖在部分原生组件上面. 这两个组件也是原生组件, 但是使用限制与其它原生组件有所不同

# 架构*

## 目录结构

程序包含一个描述整体的程序的 app 和 多个描述各自页面的 page

一个小程序的主体部分由三个文件组成, 必须放在小程序根目录下	

| 文件                                                         | 必需 | 作用             |
| ------------------------------------------------------------ | ---- | ---------------- |
| [app.js](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html) | 是   | 小程序逻辑       |
| [app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html) | 是   | 小程序公共配置   |
| [app.wxss](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html) | 否   | 小程序公共样式表 |

一个小程序页面由四个文件组成, 分别是

js(必须) / wxml(必须) / json / wxss

注意: 为了方便开发者减少配置项, 描述页面的四个文件必须具有相同的路径与文件名

**允许上传的文件**

在项目目录中, 以下文件会经过编译, 因此上传之后无法直接访问: .js/ app.json/ .wxml/ *.wxss(其中 wxml 和 wxss 文件仅针对 app.json 中配置了的页面) 除此之外, 只有后缀名在白名单中的文件可以被上传, 白名单如下

1. wxs
2. png/jpg/jpeg/gif/svg
3. json
4. cer
5. mp3
6. aac
7. m4a
8. wav/mp4
9. ogg
10. silk

## 配置

### 全局配置

小程序根目录下的 app.json 文件用来对微信小程序进行全局配置, 决定页面文件的路径, 窗口表现, 设置网络超时时间, 设置多 tab 等

##### app.json 配置项列表

- pages* StringArray页面路径列表

  用于指定小程序由哪些页面组成, 每一项都对应一个页面, 路径+文件名 信息, 文件名不需要写文件后缀, 框架会自动去寻找对于位置的 .json .js .wxml .wxss 四个文件进行处理

  数组的第一项代表小程序的初始页面(首页), 小程序中新增/减少页面, 都需要对 pages 数组进行修改

- window 全局的默认窗口表现

  用于设置小程序状态栏, 导航条, 标题, 窗口背景色

  - navigationBarBackgroundColor 导航栏背景颜色
  - navigationBarTextStyle 导航栏标题颜色, 仅支持black/white
  - navigationBarTitleText 导航栏标题文字内容
  - navigationStyle 导航栏样式, 仅支持 defalut(默认样式) / custom(自定义导航栏, 保留右上角胶囊按钮)
  - backgroundColor 窗口的背景颜色
  - backgroundTextStyle 下拉loading 的样式, dark/light
  - backgroundColorTop 顶部窗口的背景色 IOS 支持
  - backgroundColorBottom 底部窗口的背景色 IOS 支持
  - enablePullDownRefresh 是否开启当前页面的下拉刷新
  - onReachBottomDistance 页面上拉触底事件触发时距页面底部距离, 单位px
  - pageOrientation 屏幕旋转设置 auto/portrait

- tabBar 底部 tab 栏的表现

  如果小程序是一个多 tab 应用, 可以通过 tabBar 配置项指定 tab 栏的表现, 以及 tab 切换时显示的对应页面

  - color tab上的文字默认颜色
  - selectedColor tab上文字选中时颜色
  - backgroundColor tab 的背景色
  - borderStyle tabbar上边框颜色 black/ white
  - list tab 的列表, 至少2个, 最多5个
    - pagePath 页面路径, 必须在 pages 中先定义
    - text tab 上按钮文字
    - iconPath 图片路径, icon 大小限制为 40kb, 建议尺寸 81px*81px, 不支持网络图片
    - selectedIconPath 选中时的图片路径, icon 大小限制为 40kb, 建议使用 81px*2
  - position tabbar位置 bottom/top

- networkTimeout 网络超时时间

  各类网络请求超时时间,单位毫秒

  - request wx.request 的超时时间
  - connectSocket wx.connectSocket 的超时时间
  - uploadFile wx.uploadFile 的超时时间
  - downloadFile wx.downLoadFile 的超时时间

- debug 是否开启 debug模式, 默认关闭

  可以在开发工具中开启 debug 模式, 在开发和工具的控制台面板, 调试信息以 info 的形式给出, 其信息有Page的注册, 页面路由, 数据更新, 事件触发等, 可以帮助开发者快速定位一些常见的问题

- functionalPages 是否启用插件功能, 默认关闭

  启用插件功能页时, 插件所有者小程序必须设置为 functionalPages 为 true

- subpackages 分包结构配置

  启用分包加载时,声明项目分包结构

- workers  Worker 代码放置的目录

  使用 Worker 处理多线程任务时, worker 代码放置的目录

- requiredBackgroundModes 需要在后台使用的能力, 如 音乐播放

  声明需要后台运行的能力, 类型为数组,

  - audio 后台音乐播放

  ```js
  {
      "pages":["pages/index/index"],
      "requireBackgroundModes":["audio"]
  }
  ```

  此处申明了后台运行的借口, 开发版和体验版可以直接生效, 正式版还需要通过审核

- plugins 使用到的插件

  声明小程序需要使用的插件

- preloadRule 分包预下载规则

  声明分包预下载的规则

- resizable iPad小程序是否支持屏幕旋转, 默认关闭

- navigateToMiniProgramAppIdList 需要跳转的小程序列表, 详情 wx.navigateToMiniProgram

  当小程序需要使用 wx.navigateToMiniProgram 接口跳转到其它小程序时, 需要先在配置文件中声明需要跳转的小程序 appId 列表, 最多允许10 个

- usingComponents 全局自定义组件配置

  此处声明的自定义组件视为全局自定义组件, 在小程序内的页面或自定义组件中可以直接使用而无需再声明

- permission 小程序接口权限相关配置

  小程序接口权限相关配置, 字段类型是对象

  - scope.userLocation 位置相关权限声明
    - desc 小程序获取权限时展示的接口用途说明, 最长30字符

  ```js
  "permission": {
      "scope.userLocation": {
          "desc": "你的位置信息将用于小程序位置接口的效果展示"
      }
  }
  ```

### 页面配置

每个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置	

页面的配置只能设置 app.json 中 window配置项内容, 页面中的配置会覆盖全局 app.json 中 window 相同的配置项

##### 页面配置项列表

| 属性                         | 类型     | 默认值  | 描述                                                         | 最低版本         |
| ---------------------------- | -------- | ------- | ------------------------------------------------------------ | ---------------- |
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如 `#000000`                                 |                  |
| navigationBarTextStyle       | String   | white   | 导航栏标题颜色，仅支持 `black` / `white`                     |                  |
| navigationBarTitleText       | String   |         | 导航栏标题文字内容                                           |                  |
| navigationStyle              | String   | default | 导航栏样式，仅支持以下值： `default` 默认样式 `custom` 自定义导航栏，只保留右上角胶囊按钮 | 微信客户端 7.0.0 |
| backgroundColor              | HexColor | #ffffff | 窗口的背景色                                                 |                  |
| backgroundTextStyle          | String   | dark    | 下拉 loading 的样式，仅支持 `dark` / `light`                 |                  |
| enablePullDownRefresh        | Boolean  | false   | 是否全局开启下拉刷新。 详见 [Page.onPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#onpulldownrefresh) |                  |
| onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 [Page.onReachBottom](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#onreachbottom) |                  |
| disableScroll                | Boolean  | false   | 设置为 `true` 则页面整体不能上下滚动。 只在页面配置中有效，无法在 `app.json`中设置 |                  |
| disableSwipeBack             | Boolean  | false   | 禁止页面右滑手势返回                                         |                  |

注意: 页面的 .json 职能配置 window 相关的配置项, 已决定本页面的窗口表现, 所以无需写 window 属性

示例: 

```json
{
  "navigationBarBackgroundColor": "#ffffff",
  "navigationBarTextStyle": "black",
  "navigationBarTitleText": "微信接口功能演示",
  "backgroundColor": "#eeeeee",
  "backgroundTextStyle": "light"
}
```

## 逻辑层

小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能. 

逻辑层将数据进行处理后发送给视图层, 同时接受视图层的事件反馈

开发者缩写的所有代码最终将被打包成一份 JavaScript 文件, 并在小程序启动的时候运行, 直到小程序销毁, 这一行为类似 ServiceWorker, 所以逻辑层也被称之为 App Service

在 JavaScript 的基础上, 我们增加了一些功能, 以方便小程序的开发

- 增加 App 和 Page 方法, 进行小程序的页面的注册
- 增加 getApp 和 getCurrentPages 方法, 分别用来获取 App 实例和当前的页面栈
- 提供丰富 API , 如微信用户数据, 扫一扫, 支付等微信特有能力
- 每个页面有独立的作用域, 并提供模块化能力

**小程序框架的逻辑层并非运行在浏览器中, 因此 JavaScript 在 web 中一些能力都无法使用, 如window. document 等**

### 注册小程序

##### 小程序 App(Object)

App() 函数用来注册一个小程序

必须在 app.js 中调用, 并且只能调一次

- onLaunch 生命周期回调  ---  监听小程序初始化

  - onLaunch(Object) 小程序初始化完成触发, 全局只触发一次, 参数也可以使用 wx.getLaunchOptionsSync 获取, 参数与 wx.getLaunchOptionsSync 一致

- onShow 生命周期回调 ---- 监听小程序显示

  - onShow(Object) 小程序启动, 或从后台进入前台显示时触发, 也可以使用 onAppShow 绑定监听

- onHide 生命周期回调 ----- 监听小程序隐藏

  - onHide() 小程序从前台进入后台时触发, 也可以使用 wx.onAppHide 绑定监听

- onError 错误监听函数

  - 小程序发生脚本错误或 API 调用错误时触发, 也可以使用 wx.onError 绑定监听, 参数一致

- onPageNotFound  页面不存在监听函数

  - onPageNotFound(Object) 小程序要打开开的页面不存在时触发. 可以使用 wx.onPageNotFound 绑定监听. 参数一致

  ```js
  App({
      onPageNotFound(res) {
          wx.redirectTo({
              url: 'pages/...'
          }) // 如果是 tabbar 页面，请使用 wx.switchTab
      }
  })
  ```

- 其他 开发者可以添加任意的函数或数据到 Object 参数中, 使用 this 访问 

前台/后台 定义: 用户点击左上角关闭, 或者按了设备 Home 键离开微信, 小程序并没有直接销毁, 而是进入后台, 当再次进入小程序或再次打开小程序, 又会从后台进入前台, 需要注意: 只有当小程序进入后台一定时间, 或者系统资源占用过高, 才会被真正的销毁

##### getApp(Object)

全局的 getApp() 函数可以用来获取到小程序 App 实例.

- allowDefault 在 App 未定义时返回默认实现, 当 App 被调用时, 默认实现中定义的属性会被覆盖合并到 App中, 一般用于独立分包

```js
// other.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data
```

注意: 通过getApp() 获取实例之后, 我们不要私自调用生命周期函数

### 场景值

当前支持的场景值有

- 1001 发现栏小程序入口, [最近使用] 列表, 包含[我的小程序]列表
- 1005 顶部搜索框搜索结果页
- 1006 发现栏小程序主入口搜索框的搜索结果页
- 1007 单人聊天会话中内的小程序消息卡片
- 1008 群聊会话中的小程序消息卡片
- 1011 扫描二维码
- 1012 长按图片识别二维码
- 1013 手机相册选取二维码
- 1014 小程序模板消息
- 1017 前往体验版的入口
- 1019 微信钱包
- 1020 公众号 profile 页相关小程序列表
- 1022 聊天顶部置顶小程序入口
- 1023 安卓系统桌面图标
- 1024 小程序 profile 页
- 1025 扫描一维码
- 1026 附件小程序列表
- 1027 顶部搜索栏搜索结果页 [使用过的小程序]列表
- 1028 我的卡包
- 1029 卡劵详情页
- 1030 自动化测试下打开小程序
- 1031 长按识别一维码
- 1032 手机相册选取一维码
- 1034 维修支付完成页
- 1035 公众号自定义菜单
- 1036 App分享消息卡片
- 1037 小程序打开小程序
- 1038 从另一个小程序返回
- 1039 摇电视
- 1042 添加好友搜索框的搜索结果页
- 1043 公众号模板消息
- 1044 待 shareTicket 的小程序消息卡片
- 1045 朋友圈广告
- 1047 扫描小程序码
- 1048 长按图片识别小程序码
- 1049 手机相册选取小程序码
- 1052 卡劵的适用门店列表
- 1053 搜一搜的结果页
- 1054 顶部搜索框小程序快捷入口
- 1056 音乐播放器菜单
- 1057 钱包中的银行卡详情页
- 1058 公众号文章
- 1059 体验版小程序绑定邀请页
- 1064 微信连 Wi-Fi 状态栏
- 1067 公众号文章广告
- 1068 附近小程序列表广告
- 1069 移动应用
- 1071 钱包中银行卡列表页
- 1072 二维码收款页面
- 1073 客服消息列表下发的小程序消息卡片
- 1074 公众号会话下发的小程序消息卡片
- 1077 摇周边
- 1078 连 WiFi 成功页
- 1081 客服消息下发的文字链
- 1082 公众号会话下发的文字链
- 1084 朋友圈广告原生页
- 1089 微信聊天主界面下拉 [最近使用] 栏
- 1090 长按小程序右上角菜单唤出最近使用历史
- 1091 公众号文章商品卡片
- 1092 城市服务入口
- 1095 小程序广告组件
- 1096 聊天记录
- 1997 维修支付签约页
- 1099 页面内嵌插件
- 1102 公众号 profile 页服务预览
- 1103 发现栏小程序入口
- 1104 维修聊天主界面下拉

对于小程序, 可以在 App 的 onLaunch 和 onShow 或 wx.getLaunchOptionsSync 中获取上述场景值

### 注册页面

页面Page

**Page(Object) 构造器**

该函数用来注册一个页面, 授予 Object 类型参数, 其指定页面的初始化数据, 生命周期, 事件处理

- data 页面初始化数据对象

  data 时页面第一次渲染使用初始数据

  页面加载时, data 将会以 JSON 字符串形式由逻辑层传至渲染层, 因此, data 中的数据必须可以转成 JSON 类型: 字符串, 数字, 布尔值, 对象, 数组.

  渲染层可以通过  WXML 对数据进行绑定 {{}}

- onLoad 监听页面加载函数

  页面加载时触发, 一个页面只会调用一次, 可以在 onLoad 的参数中获取打开当前页面路径中的参数 query

- onShow 监听页面显示函数

  页面显示/切入前台时触发

- onReady 监听页面初次渲染完成函数

  页面初次渲染完成时触发, 一个页面只会调用一次, 代表页面已经准备妥当, 可以喝视图层进行交互

  注意: 对界面内容宁晋县设置的API 如 wx.setNavigationBarTitle, 请在  onReady 之后进行

- onHide 监听页面隐藏函数

  页面隐藏/切入后台时触发, 如 navigate 或 底部 tab 切换到其他页面, 小程序切入后台等

- onUnload 监听页面卸载函数

  页面卸载时触发. 如 redirectTo 或 navigateBack 到其他页面时

- onPullDownRefresh 监听用户下拉动作函数

  监听用户下拉刷新事件

  - 需要在 app.json 的 window 选项中或页面配置中开启 enablePullDownRefresh
  - 可以通过 wx.startPullDownRefresh 触发下拉刷新, 调用后触发下拉刷新动画, 效果与用户手动下拉刷新一致
  - 当处理完数据刷新后, wx.stopPullDownRefresh 可以停止当前页面的下拉刷新.

- onReachBottom 页面上拉触底事件的处理函数

  监听用户上拉触底事件

  - 可以在 app.json 的window 选项中或页面配置中设置触发距离 onReachBottomDistance.
  - 再触发距离内滑动周期, 本事件只会被触发一次

- onPageScroll(Object) 监听用户滑动页面事件

  - scrollTop 页面在垂直方向已滚动的距离

  注意: 在需要的时候才在 page 中定义此方法, 不要定义空方法. 以减少不必要的事件派发对渲染层-逻辑层通信的影响,  避免在 onPageScroll 中过于频繁执行 setData 等引起逻辑层-渲染层通信的操作. 尤其是每次传输大量数据, 会影响通信耗时.

- onShareAppMessage(Object) 用户点击右上角转发函数

  监听用户点击页面内转发按钮 (button 组件 open-type='share') 或右上角菜单 "转发" 按钮的行为, 并自定义转发内容

  注意: 只有定义了此事件处理函数, 右上角菜单才会显示 "转发" 按钮

  - form 转发事件来源 (button 页面内转发按钮; menu 右上角转发菜单)

  - target 如果 form 值是 button , 则target 是触发这次转发事件的 button, 否则为 undefined

  - webViewUrl 页面中包含 <web-view> 组件时, 返回当前 <web-view> 的 url

    该事件需要 return 一个 对象, 用于自定义转发内容, 返回内容如下

    - title 转发标题, 默认当前小程序名称
    - path 转发路径 当前页面的path, 必须是 /开头的而完整路径
    - imageUrl 自定义图片路径, 可以是本地文件路径, 代码包文件路径或者网络图片路径, 支持 PNG 及 JPG . 显示图片长度比是 5:4

    ```js
    Page({
        onShareAppMessage(res) {
            if (res.from === 'button') {
                // 来自页面内转发按钮
                console.log(res.target)
            }
            return {
                title: '自定义转发标题',
                path: '/page/user?id=123'
            }
        }
    })
    ```

- onResize 页面尺寸改变时触发函数

  小程序屏幕旋转时触发

- onTabItemTap(Object) 当前是tab页时, 点击 tab 时触发函数

  点击 tab 时触发

  - index 被点击 tabItem 的序号, 0起始
  - pagePath 被点击 tabItem 的页面路径
  - text 被点击 tablItem 的按钮文字

  ```js
  Page({
      onTabItemTap(item) {
          console.log(item.index)
          console.log(item.pagePath)
          console.log(item.text)
      }
  })
  ```

- 其他 任意函数或数据. 当前页面使用 this 访问

  组件处理函数, Page中可以定义组件事件处理函数, 在渲染层的组件中加入事件绑定, 当事件被触发时, 就会执行 Page 中定义的事件处理函数

除了 Page 作为高级用法, 页面可以像自定义组件一样使用 Component 来创建, 这样就可以使用自定义组件的特性, 比如 behaviors 等

##### route

Page.route 获取当前页面的路径 string

```js
onShow(){
    console.log(this.route)
}
```

##### setData

###### Page.prototype.setData(data, callback)

setData 函数用于将数据从逻辑层发送到视图层(异步) 同时改变对应的this.data 的值(同步)

- data 必须, 此次要改变的数据

  - 以 key:vlaue 的形式表示, 将 this.data 中的key 对应的值改成 value

  其中 key 可以以数据路径的形式给出, 支持改变数组中的某一项或对象的某一个属性, 如 array[2].message, a.b.c.d, 并且不需要再this.data中预先定义

- callback setData 引起的界面更新渲染完毕后的回调函数

注意: 

1. 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态(页面数据非实时数据)
2. 仅支持设置 JSON 化的数据
3. 单次设置的数据不能超过  1024kb, 经理避免一次设置过多的数据
4. 不要把data中的任何一项value 设为 undefined, 否则这一项将不被设置并且可能遗留潜在问题

##### 页面生命周期

![54596426047](.\wx\1545964260472.png)

### 路由

小程序中所有页面的路由全部由框架进行管理

**页面栈**

框架以栈的形式维护了当前的所有页面, 当发生路由切换时候, 页面栈表现如下

| 路由方式   | 页面栈表现                        |
| ---------- | --------------------------------- |
| 初始化     | 新页面入栈                        |
| 打开新页面 | 新页面入栈                        |
| 页面重定向 | 当前页面出栈，新页面入栈          |
| 页面返回   | 页面不断出栈，直到目标返回页      |
| Tab 切换   | 页面全部出栈，只留下新的 Tab 页面 |
| 重加载     | 页面全部出栈，只留下新的页面      |

##### getCurrentPages()

用于获取当前页面栈的实例, 以数组形式按栈的顺序给出, 第一个元素为首页, 最后一个元素为当前页

注意: 

1. 不要尝试修改页面栈, 会导致路由以及页面状态错误
2. 不要在 App.onLaunch 的时候调用 getCurrentpages, 此时 page 还没有生产

##### 路由方式

对于路由的触发方式以及页面生命周期函数如下

| 路由方式   | 触发时机                                                     | 路由前页面 | 路由后页面         |
| ---------- | ------------------------------------------------------------ | ---------- | ------------------ |
| 初始化     | 小程序打开的第一个页面                                       |            | onLoad, onShow     |
| 打开新页面 | 调用 API [`wx.navigateTo`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.navigateTo.html) 或使用组件 [``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) | onHide     | onLoad, onShow     |
| 页面重定向 | 调用 API [`wx.redirectTo`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.redirectTo.html) 或使用组件 [``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) | onUnload   | onLoad, onShow     |
| 页面返回   | 调用 API [`wx.navigateBack`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.navigateBack.html) 或使用组件[``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html)或用户按左上角返回按钮 | onUnload   | onShow             |
| Tab 切换   | 调用 API [`wx.switchTab`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.switchTab.html) 或使用组件 [``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html)或用户切换 Tab |            | 各种情况请参考下表 |
| 重启动     | 调用 API [`wx.reLaunch`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.reLaunch.html) 或使用组件 [``](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) | onUnload   | onLoad, onShow     |

注意:

1. navigateTo, redirectTo 只能打开非 tabBar 页面
2. switchTab 只能打开 tabBar 页面
3. reLaunch 可以打开任意页面
4. 页面底部的 tabBar 由页面决定, 即只要是定义为 tabBar 的页面, 底部都有 tabBar
5. 调用页面路由带的参数可以在目标页面的 onLoad 中获取

###  模块化

##### 文件作用域

在 JavaScript 文件中声明的变量和函数只能在该文件中有效. 不同的文件中可以声明相同的变量和函数, 不相互影响, 通过全局函数 getApp() 可以获取全局的应用实例, 如果需要全局的数据可以在 App() 中设置

```js
// app.js
App({
    globalData:'无可睥睨'
})

// other.js
// console.log(getApp().globalData)
```

##### 模块化

可以将一些公共的代码抽离成一个单独的 js 文件, 作为一个模块, 模块通过 module.exports/exports对外暴露接口	

需要注意:

1. exports 是 module.exports 的一个引用, 因此在模块里随便更改 exports 的指向会造成引用链断开, 推荐开发者采用 module.exports 来暴露模块接口
2. 小程序目前不支持映入 node_modules ,开发者需要使用 node_modules 时候建议拷贝出相关的代码到下程序的目录中或使用小程序支持的 npm 功能

```js
//	tool.js
function sayHi(name){
    console.log('hi, '+ name + '先森')
}
function sayBey(name){
    console.log('bey, '+ name + '先森')
}
module.exports = {
    sayHi,
    sayBey
}
```

在需要使用模块的文件中, 使用 require(path) 将代码引入, 暂不支持绝对路径

```js
const tool = require('tool.js')
Page({
    helloMINA(){
        tool.sayHi('MINA')
    }
})
```

也可以使用 import 方式引入

```js
import { sayHi } from 'tool.js';
Page({
    helloMINA(){
        sayHI('MINA')
    }
})
```

### API

小程序开发框架提供丰富的微信原生 API, 可以方便地调起微信提供的能力, 如获取用户信息, 本地存储, 支付功能等

通常, 在小程序 API 有以下几种类型

##### 事件监听 API

我们约定, 以 on 开头的 API 用来监听某个事件是否触发, 如 wx.onSocketOpen, wx.onCompassChange 等

这类 API 接受一个回调函数作为参数, 当时间触发时会调用这个回调函数, 并将相关数据以参数形式传入

示例:

```js
wx.onCompassChange((res) => {
    console.log(res.direction)
})
```

##### 同步 API

我们约定, 以 Sync 结尾的API 都是同步 API, 如 wx.setStorageSync 等, 此外也有一些其他的同步 API, 如 wx.createWorker, wx.getBackgroundAudioManager 等

同步 API 的执行结果可以通过函数返回值直接获取, 执行出错会抛出异常

```js
try {
    wx.setStorageSync('key', 'value')
} catach (e) {
	console.log(e)
}
```

##### 异步 API


- success 接口成功回调
- fail 接口调用失败回调
- complete 接口调用结束回调
- 其他 接口定义的其他参数

###### 回调参数

- errMsg 错误信息, 如果调用成功返回 ${apiName}:ok
- errCode 错误码, 部分API支持, 成功返回0
- 其他 接口返回的其它数据

异步 API 的执行结果需要通过 Object 类型的参数中传入的对应的回调函数获取. 部分异步 API 也有返回值, 可以用来实现更丰富的功能, 如 wx.request wx.connectSockets 等

## 视图层

视图层 View 

框架的视图层有 WXML 与 WXSS 编写, 由组件来进行展示

将逻辑层的数据反应成视图层, 同时将视图层的事件给逻辑层

WXML 用于及描述页面结构

WXS 小程序的一套脚本语言, 结合 WXML 构建页面结构

WXSS 用于描述页面样式

组件(Components) 视图基本组成单元

### WXML

WXML(WeiXin Markup Language) 是框架设计的一套标签语言, 结合 基础组件, 事件系统, 可以构建出页面的结构

以下例子展示 WXML 具备的能力

##### 数据绑定

WXML 中的动态数据均来自对应 Page 中的 data

**简单的绑定**

数据绑定使用 Mustache 语法 `{{}}` 将变量包起来

```html
//	wxml
<view>{{message}}</view>

//page.js
data:{message: 'hello wxml'}
```

组件属性, 控制属性, 关键字 都需要在双引号之内

###### 运算

可以在 `{{}}` 内进行简单的运算, 支持的有如下几种方式

```html
<!--三元表达式 -->
<view hidden="{{flag? true : false}}">hidden</view>

<!--算数运算 -->
<view>{{a + b}} + {{c}} + d </view>

<!--逻辑判断 -->
<view wx:if="{{length>5}}"></view>

<!--字符串运算 -->
<view>{{"hello" + "MINA"}}</view>

<!--数据路径运算 -->
<view>{{obj.key}} {{arr[0]}}</view>

<!--组合 -->
<view wx:for="{{[zero, 1, 2, 3, 4, 520]}}">{{item}}</view>    [1,2,3,4,520]
<view wx:for="{{...arg1, arg2}}">{{item}}</view>  {a:1,b:2,c:3}
```



##### 列表渲染

在组件上使用 wx:for 控制属性绑定一个数组, 就可以使用数组各项数据重复渲染该组件

默认数组的当前的下标变量名 index, 数组当前项变量名为 item

```html
//	wxml
<view wx:for="{{message}}">{{item}}</view>

//	page.js
data:{message: [1,2,3,4,5,20]}
```

使用 wx:for-item 可以指定数组当前元素变量名

使用 wx:for-index 可以指定数组当前下标变量名

```html
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
    {{idx}}: {{itemName.message}}
</view>
```

###### block wx:for

类似 block wx:if , 可以将 wx:for 用在 <block/> 标签上, 一渲染一个包含多节点的结构块

```html
<block wx:for="{{[1,2,3]}}">
    <view>{{index}}</view> -- <view>{{item}}</view>
</block>
```

###### wx:key

如果列表中项目的位置会动态改变或者有新的项目添加到列表中, 并且希望列表中的项目保持自己的特征和状态(如 <input> 中的输入内容, <switch> 中的选中状态, 需要指定列表中的唯一标识符

wx:key 的值以两种形式提供

1. 字符串, 代表在 for 循环的 array 中 item 的某个 property, 该 property 的值需要是列表中唯一的字符串和数字, 且不能动态改变.
2. 保留关键字 *this 代表在 for 循环中的 item 本身, 这种表示需要 item 本身是一个唯一的字符串或者数字

当数据改变触发渲染层重新渲染的时候, 会校正带有 key 的组件, 框架会确保他们被重新排序, 而不是重新创建, 以确保使组件保持自身状态, 并且提高列表渲染时的效率

##### 条件渲染

`wx:if`

在框架中, 使用  `wx:if="{{condition}}"` 来判断是否渲染代码块

`wx:elif` 和 `wx:else` 来添加一个  else 块

```html
//	wxml
<view wx:if="{{view == 'WEBVIEW'}}">WEBVIEW</view>
<view wx:elif="{{view == 'APP'}}">APP</view>
<view wx:else>MINA</view>

// page.js
data: {view: 'MINA'}
```

###### block wx:if

因为 `wx:if` 是一个控制属性, 需要将它添加到一个标签上. 如果哟啊一次性地判断多个组件标签, 可以使用一个 <block /> 标签将多个组件包装起来, 并在上边使用 `wx:if` 控制属性

```html
<block wx:if="{{flag}}">
    <view>view1</view>
    <view>view2</view>
</block>
```

注意: <block/> 并不是一个组件, 它仅仅是一个包装元素, 不会在页面中做任何渲染, 只接受控制属性.

###### wx:if VS hidden

1. 因为 wx:if 之中的模板也可能包含数据绑定, 所以当 wx:if 的条件值切换时, 框架有一个局部渲染的过程, 因为他会确保条件块在切换时销毁或者重新渲染
2. 同时 wx:if 有惰性的, 如果在初始渲染条件为false, 框架什么也不做, 在条件第一次变成真的时候才开始局部渲染
3. 相比之下, hidden 就简单多了, 组件始终会被渲染, 只是简单的控制显示与隐藏
4. 一般来说, wx:if 有更高的切换消耗而 hidden 有更高的渲染消耗, 因此如果需要频繁切换情景下, 用hidden更好, 如果在运行时条件不大, 可能改变则 wx:if 较好

##### 模板

WXML 提供模板 (template), 可以在模板中定义代码片段, 然后在不同的地方调用.

**定义模板**

使用 name 属性, 作为模板的名字. 然后在 <template/> 内定义代码片段, 如下

```html
<template name="msgItem">
	<text>{{index}} : {{msg}}</text>
    <text>{{time}}</text>
</template>
```

**使用模板**

使用 is 属性, 声明需要的使用的模板, 然后将模板所需要的 data 传入, 如

```html
<template is="mgsItem" data="{{...iten}}" />
<!--
data : {
	iten:{
		index: 0,
		msg: '数据',
		time: '2016-09-15'
	}
}
-->
```

is 属性可以使用插值表达式, 来动态决定渲染哪个模板

```html
<template name="odd">
    <view>odd</view>
</template>
<template name="even">
    <view>even</view>
</template>

<block wx:for="{{[1, 2, 3, 4, 5]}}">
    <template is="{{item % 2 == 0 ? 'even' : 'odd'}}" />
</block>
```

**模板作用域**

模板拥有自己的作用域, 只能使用 data传入数据以及模板定义文件中的 <wxs /> 模块

```html
<!--wxml-->
<template name="staffName">
  <view>FirstName: {{firstName}}, LastName: {{lastName}}</view>
</template>

<template is="staffName" data="{{...staffA}}"></template>
<template is="staffName" data="{{...staffB}}"></template>
<template is="staffName" data="{{...staffC}}"></template>

// page.js
Page({
    data: {
        staffA: {firstName: 'Hulk', lastName: 'Hu'},
        staffB: {firstName: 'Shang', lastName: 'You'},
        staffC: {firstName: 'Gideon', lastName: 'Lin'}
    }
})
```

##### 事件

- 事件是视图层到逻辑层的通讯方式
- 事件可以将用户的行为反馈到逻辑层进行处理
- 事件可以绑定到在组件上, 当达到触发事件, 就会执行逻辑层中对应的处理函数
- 事件对象可以携带额外信息

**事件的使用方式**

- 组件中绑定一个事件处理函数
- 如 bandtap, 当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数.
- 在相应的 Page 定义中写上相应的事件处理函数, 参数 event

```html
<view bindtap="add">{{count}}</view>
<!-- page.js
    data: {
        count: 1
    },
    add(e) {
		console.log(e)
         this.setData({
            count: this.data.count + 1
         })
    }
-->
```

###### 事件详情

事件分为冒泡事件和非冒泡事件

**WXML 的冒泡事件列表**

- touchstart  手指触摸动作开始
- touchmove 手指触摸后移动
- touchcancel 手指触摸动作被打断, 如来电
- touchend 手指触摸动作结束
- tap 手指触摸后马上离开
- longpress 手触摸后, 超过 350 ms 再离开, 如果指定了事件回调函数并触发了这个事件, tap 事件将不被触发
- transitionend 在 WXSS transition 或  wx.createAnimation 动画结束后触发
- animationstart 在 一个 WXSS animation 动画开始时触发
- animationiteration 在一个 WXSS animation 一次迭代结束时触发
- animationend 在 WXSS animation 动画完成时触发

除上述之外其他组件自定义事件, 如无特殊情况都是非冒泡事件.

- <form /> 的 submit 事件
- <input /> 的 input 事件
- <scroll-view /> 的 scroll 事件

**事件绑定和冒泡**

事件绑定写法同组件的属性, 以 key, value 的形式

- key 以 bind 或 catch 开头, 然后跟上事件类型, 如 bindtap, catchtouchstart. 非原生组件中, bind 和 catch 后可以紧跟一个冒号, 其含义不变, 如 bind:tap, catch:touchstart
- value 是一个字符串, 需要对应 Page 中定义的同名函数

bind 事件绑定不会阻止事件向上冒泡, catch 事件绑定可以阻止冒泡事件向上冒泡

**事件捕获阶段**

触摸类事件支持捕获阶段, 捕获阶段位于冒泡阶段之前, 在捕获阶段中, 事件达到节点的顺序与冒泡阶段恰好相反, 需要在捕获阶段监听事件时. 可以采用 capture-bind  capture-catch 关键字, 后者将中断捕获阶段和取消冒泡阶段

##### 引用

WXML 提供两种文件引用方式 import 和 include

###### import

import 可以在该文件中使用目标文件定义的 template

在 item.wxml 中定义一个叫 item 的 template

```html
<!-- item.wxml -->
<template name="item">
    <text>{{text}}</text>
</template>
```

在 index.wxml  中引用 item.wxml, 就可以使用 item 模板

```html
<import src="item.wxml" />
<template is="item" data="{{text:'foorbar'}}" />
```

**import 的作用域**

import 有作用域的概念, 即只会 import 目标文件中定义的 template, 而不会 import 目标文件中 import 的template

###### include

include 可以将目标文件除了 <template /> <wxs /> 外整个代码引入. 相当于拷贝到 include 位置

### WXSS

wxss 时一套样式语言, 用于描述 wxml 的组件样式.

wxss 用来决定 wxml 的组件如何显示

为了适应广大前端开发者, wxss 具有css大部分的特性, 同时为了更适合开发微信小程序, wxss 对 css 进行了扩充以及修改, 与 css 相比 , wxss 扩展的特性有

- 尺寸单位
- 样式导入

##### **尺寸单位**

rpx(responsive pixel) 可以根据屏幕宽度进行自适应. 规定屏幕为 750rpx. 如在 iPhone6 上, 屏幕宽度为 375px, 共有 750 个物理像素, 则 750rpx = 375px = 750物理像素,  1rpx= 0.5px = 1 物理像素

建议: 开发微信小程序时, 设计师可以用 IPhone6 作为视觉稿的标准

##### **样式导入**

使用 @import 语句可以导入外联样式表, @import 后跟需要导入的外联样式表的相对路径, 用 ; 表示语句结束

内联样式

框架上支持使用 style, class 属性来控制的样式

- style: 静态的样式统一写到 class 中, style 接收动态的样式, 在运行时会进行解析, 避免将静态样式写进style中, 影响渲染速度
- class: 用于指定样式规则, 其属性值是样式规则中类选择器名的集合

##### **全局样式与局部样式**

定义在 app.wxss 中的样式为全局样式, 作用于每个页面, 在 page 的 wxss 中定义的样式为局部样式, 只作用在对应的页面, 并会覆盖 app.wxss 中相同的选择器

##### **公共属性**

偶有组件都有以下属性

- id 组件唯一标识
- class 组件的样式类
- style 组件的内联样式
- hidden 组件是否显示
- data-* 组件上触发的事件时, 会发送给事件处理函数
- bind*/catch\* 组件的事件

##### **特殊属性**

几乎所有组件都有各自定义的属性, 可以对该组件的功能或样式进行修饰

###  WXS

WXS(WeiXin Script) 是小程序的一套脚本语言, 结合WXML 可以构建出页面结构

注意

1. wxs 不依赖于运行时基础库版本, 可以在所有版本的小程序中运行.
2. wxs 与 javascript 是不同的语言, 有自己的语法, 并不和 javascript 一致.
3. wxs 的运行环境和其他 javascript 代码是隔离的, wxs 中不能调用其他 javascript 中定义的函数, 也不能调用小程序的 API 
4. wxs 函数不能作为组件的事件回调.
5. 由于运行环境的差异, 在 IOS 设备上小程序内的 wxs 会比 javascript 代码快 2~20 倍. 在 android 设备上二者运行效率无差异

**页面渲染**

```html
<wxs module="m1">
    var msg = "hello world"; 
    module.exports.message=msg;
</wxs>
<view>{{m1.message}}</view>	<!--页面输出 hello world-->
```

##### 模块

WXS 代码可以编写在 wxml 文件中的 <wxs> 标签内, 或以 `.wxs` 为后缀名的文件内

每一个 `.wxs` 文件和 <wxs> 标签都是一个单独的模块

每个模块都有自己独立的作用域, 即在一个模块里面定义的变量与函数, 默认为私有的, 对其他模块不可见.

一个模块要想对外暴露其内部私有变量与函数, 只能通过 module.exports 实现.

**.wxs 文件**

在维修开发者工具里面, 右键可以直接创建 .wxs 文件, 在其中直接编写 WXS 脚本

```js
//	comm.wxs
var foo = "hello world"
var bar = function(d){
    return d;
}
module.exports = {
    foo:foo,
    bar:bar
}
```

上述 comm.wxs 的文件里面编写了 WXS 代码, 该 .wxs 文件可以被其他的 .wxs 文件或 WXML 中的 <wxs> 标签引用.

每一个 wxs 模块均有一个内置的 module 对象

属性 exports , 通过该属性, 可以对外共享本模块的私有变量与函数

```jsx
//	tools.wxs
var foo = "hello world"
var bar = function(d){
    return d;
}
module.exports = {
    foo:foo,
    bar:bar
}
module.exports.msg = "some msg"
```

```html
<wxs src = "tools.wxs" module="tools" />
<view>{{tools.msg}}</view>	<!-- some msg -->
<view>{{tools.bar(tools.foo)}}</view> <!-- hello world -->
```

**require 函数**

在 .wxs 模块中引用其它 wxs 文件模块, 可以使用 require 函数.

- 只能引用 .wxs 文件模块, 且必须使用相对路径
- wxs 模块均为单例, wxs 模块在第一次被引用时, 会自动初始化为单例对象. 多个页面, 多个地方, 多个引用, 使用的都是同一个 wxs 模块对象
- 如果一个 wxs 模块在定义之后, 一切没有被引用, 则该模块不会被解析与运行.

**<wxs> 标签**

- module  当前 <wxs> 标签的模块名, 必填字段.
- src 引用 .wxs 文件的相对路径, 仅当本标签为 闭合标签或标签的内容为空时有效.

module 属性

module 属性是当前 <wxs> 标签的模块名, 在单个 wxml 文件内, 建议其值唯一. 有重复模块名则先后顺序覆盖. 不同文件之间 module 属性值得命名必须符合以下规则

- 首字母必须是 ( a-zA-Z ), 下划线 ( _ )
- 剩余字符可以是: 字母( a-zA-Z ), 下划线 ( _ ) , 数字 ( 0-9 )

**src 属性**

src 属性可以用来引用其它的 wxs 文件模块

- 只能引用 .wxs 模块, 且必须使用相对路径
- wxs 模块均为单例, wxs 模块在第一次被引用的时候, 会自动初始化为单例, 多个页面, 多个地方, 多次引用, 使用的都是同一个 wxs 模块对象
- 如果一个 wxs 模块在定义之后, 一直没有被引用, 则该模块不会被解析与运行

注意: 

1. <wxs> 模块只能在被定义模块的 WXML 文件中被访问到. 使用 <include> 或  <import> 时, <wxs>模块不会被引入到对应的 WXML 文件中.
2. <template> 标签中, 只能使用该 <template> 的 WXML 文件中定义的 <wxs> 模块

##### 变量

- wxs 中的变量均为值得引用
- 没有声明的变量直接赋值使用, 会被定位全局变量
- 如果只声明变量而不赋值, 则默认值为 undefined
- var 表现与 javascript 一致, 会有变量提升

##### 注释

- //
- /**/
- /* 

##### 获取界面节点信息

**WXML节点信息**

节点查询 API 可以用于获取节点属性, 样式, 在界面上的位置的等信息

最常见的方法就是使用这个接口来查询某个节点的当前位置, 以及界面的滚动位置

```js
const query = wx.createSelectorQuery()
query.select('#the-id').boundingClientRect((res) => {
    res.top	//	#tghe-id节点的上边界坐标(相对显示区域)
})
query.selectViewport().scrollOffset((res) => {
    res.scrollTop // 显示区域的竖直滚动位置
})
query.exec()
```

上述示例中, #the-id 是一个节点选择器, 与 css 的选择器相近但略有区别

在自定义组件或包含自定义组件的页面中, 推荐使用 this.createSelectorQuery 来代替 wx.createSelectorQuery 这样可以确保在正确的范围内选择节点

**WXML 节点布局相交状态**

节点布局相交状态API可以用于监听两个或多个组件节点在布局位置上的相交状态. 这一组 API 常常可以用于推断某些节点是否可以被用户看见, 有多大比例可以被用户看见.

这组 API 设计的主要概念如下

- 参照节点: 监听参照节点, 取它的布局区域作为参照区域. 如果有两个参照节点, 则会取他们布局的交集 作为参照区域. 页面显示区域也可作为参照区域之一
- 目标节点: 监听的目标, 默认只能是一个节点 (使用 selectAll 选项可以同时监听多个节点)
- 相交区域: 目标节点的布局区域参照区域的相交区域.
- 相交比例: 相交区域占参照区域的比例.
- 阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个

以下示例代码可以在目标节点每次进入或离开页面显示区域时, 触发回调函数.

```js
onLoad(){
    wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
        console.log(res);
        res.dataset	//	目标节点 dataset
        res.intersectionRatio 相交区域占目标节点多少比例
        res.intersectionRect.left 相交区域的左边界坐标
    })
}
```

以下示例代码可以在目标节点与参照节点在页面显示区域相交/相离. 且程度达到目标节点布局区域的 20%和50%时触发回调

```js
onLoad(){
    wx.createIntersectionObserver(this, {
        thresholds: [0.2, 0.5]
    }).relativeTo('relative-class').relativeToViewport().observe('.target-class', (res) => {
        res.intersectionRatio //	相交区域占目标节点布局区域比例
    })
}
```

注意: 与页面显示区域的相交区域并不准确代表用户可见区域, 因为参与计算的区域是 布局区域, 布局区域可能会在绘制时被其他节点裁剪隐藏(祖先 overflow:hidden/fixed 定位节点)

在自定义组件或包含自定义组件的页面中, 推荐使用 `this.createIntersectionObserver` 来代替 [`wx.createIntersectionObserver`](https://developers.weixin.qq.com/miniprogram/dev/api/wx.createIntersectionObserver.html) ，这样可以确保在正确的范围内选择节点。

##### 响应显示区域变化

显示区域指小程序界面中可以自由布局展示的区域. 在默认情况下, 小程序的显示区域尺寸自页面初始化起就不会发生变化. 两种方式可以改变这默认行为

- 在手机上启用屏幕旋转支持

  小程序在手机上支持屏幕旋转, 使小程序中的页面支持屏幕旋转的方法是: 在 app.json 中的 window 端中配置 `"pageOrientation": "auto"` 或在 json 文件中配置 `"pageOrientation": "auto"` 

  单个页面json文件中启动屏幕旋转示例

  ```json
  {
      "pageOrientation": "auto"
  }
  ```

  如果页面添加上述声明, 在屏幕旋转时, 这个页面将随之旋转, 显示区域尺寸也随着屏幕旋转而变化

- 在 iPad 上启用屏幕旋转支持

  在 iPad 上运行小程序可以支持屏幕旋转, 使小程序支持 iPad 屏幕旋转的方法是: 在 app.json 中添加 `"resizable" : true`

  iPad 上不能单独配置某个页面是否支持屏幕旋转

**Media Query**

对应不同尺寸的显示区域, 页面的布局会有所差异, 此时可以使用 media query 来解决大多数问题

```css
@media (min-width: 480px) {
  /* 仅在 480px 或更宽的屏幕上生效的样式规则 */
  .my-class {
    width: 200px;
  }
}
```

**屏幕旋转事件**

仅仅使用 media query 无法控制一些精细的布局变化. 此时可以使用 js 作为辅助.

在 js 中读取页面显示区域尺寸, selectorQuery.selectViewport

页面尺寸发生改变的事件, 可以使用`wx.onWindowResize` 页面的 `onResize` 来监听. 对于自定义组件, 可以使用 resize 生命周期来监听. 回调函数中将返回显示区域尺寸信息

代码示例:

```js
wx.onWindowResize( res => {
   
    res.size.windowWidth // 新的显示区域宽度
    res.size.windowHeight	//	新的显示区域高度
})

onResize(res){
    res.size.windowWidth
    res.size.windowHeight
}

Component({
    pageLiftime: {
        resize(res){
            res.size.windowWidth
            res.size.windowHeight
        }
    }
})
```

## 自定义组件

开发者可以将页面内的功能模块抽象成自定义组件, 以便在不同的页面中重复使用; 也可以将复杂的页面拆分成多个低耦合的模块, 有助于代码维护. 自定义组件在使用时与基础组件非常相似

**创建自定义组件**

类似于页面, 一个自定义组件由 `json` `wxml` `wxss` `js` 4个文件组成. 要编写一个自定义组件, 首先要在 `json` 文件中进行自定义组件的声明(将 component字段 设为 true 这一组件文件设为自定义组件) 

```json
{
    "component" : true
}
```

同时, 还要在 wxml 文件中编写组件模板, 在 wxss 文件中加入组件样式, 他们的写法和页面写法类似. 

代码示例

```html
<view class="inner">{{innerText}}</view>
<slot></slot>
```

```css
/*这里的样式只应用于这个自定义组件*/
.inner{
    color: red
}
```

注意, 在自定义组件的wxss中不应该使用 ID选择器, 属性选择器,和标签选择器

在自定义组件的 js 文件中, 需要使用 Component() 来注册组件, 并提供组件的属性定义, 内部数据和自定义方法.

组件的属性值和内部数据将被应用于组件 wxml 的渲染, 其中属性值是可以由外部传入的

```js
Component({
    properties: {
        //	这里定义了 innerText属性, 属性值可以在组件使用时指定
        innerText: {
            type: String,
            value: 'defaultValue'
        }
    },
    data: {
        //	这里是一些组件内部数据
        someData: {}
    },
    methods: {
        //	这里是一个自定义方法
        customMethod() {}
    }
})
```

**使用自定义组件**

使用已注册的自定义组件前, 首先要在页面的 json 文件中进行引用声明. 此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径

```json
{
    "usingComponents":{
        "component-tag-name": "path/to/the/custom/component"
    }
}
```

如此, 在页面的 wxml 中就可以像使用基础组件一样使用自定义组件. 节点名即自定义组件的标签名, 节点属性即传递给组件的属性值.

> 支持在 app.json 中声明 usingComponents 字段, 在此处声明的自定义组件视为全局自定义组件, 在小程序内的页面或自定义组件中可以直接使用, 无需再声明

代码示例

```html
<view>
    <component-tag-name inner-text="Some Text"></component-tag-name>
</view>
```

自定义组件的 wxml 节点结构在与数据结合之后, 将被插入到引用位置内

**细节注意**

1. 因为 WXML 节点标签只能小写字母, 中划线 和下划线的组合, 所以自定义组件的标签名也只能包含这些字符
2. 自定义组件也可以引用自定义组件, 引用方法类似于页面引用自定义组件的方式(使用 usingComponents 字段)
3. 自定义组件和页码所在项目根目录名不能以 "wx-" 为前缀, 否则会报错

注意, 是否在页面中使用 usingComponents 会使得页面的 this 对象的原型稍有差异, 包括

- 使用 usingComponents 页面的原型与不使用时不一致, 即 Object.getPrototypeOf(this) 结果不同
- 使用 usingComponents 时会多一些方法, 如 selectComponent
- 处于性能考虑, 使用 usingComponent 时, setData 内容不会被直接深复制, 即 this.setData({ field: obj }) 后 this.data.field === obj (深复制会在这个值被组件间传递时发生)

如果页面比较复杂, 新增或删除 usingComponents 定义段时建议重新测试一下

### 组件模板和样式

类似于页面, 自定义组件拥有自己的 wxml 模板 和 wxss 样式

**组件模板**

组件模板的写法与页面模板相同. 组件模板与组件数据结合生成的节点树, 将被插入到组件的引用位置上

在组件模板中可以提供一个 <slot> 节点, 用于承载组件引用时提供的子节点.

代码示例

```html
<!-- 组件模板 -->
<view class="wrapper">
    <view>这里是组件的内部节点</view>
    <slot></slot>
</view>
```

```html
<!-- 引用组件的页面模板 -->
<view>
	<component-tag-name>
        <!-- 这部分内容将被插入到组件的 <slot> 位置上 -->
        <view>这里是插入到组件slot中的内容</view>
    </component-tag-name>
</view>
```

注意, 在模板中引用到的自定义组件及其对应的节点名需要在 json 文件中显式定义, 否则会被当做一个无意义的节点, 除此之外, 节点名也必须可以被声明为抽象节点.

**模板数据绑定**

与普通的 WXML模板类似, 可以使用数据班的, 这样就就可以向子组件的属性传递动态数据.

代码示例

```html
<view>
	<component-tag-name paro-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
        <!--这部分内容将被放置在组件 <slot> 位置上 -->
        <view>这里的内容会插入到组件slot中的内容</view>
    </component-tag-name>
</view>
```

在上述例子中, 组件的属性 propA 和 propB 将接收页面传递的数据, 页面可以通过 setData 来改变绑定的数据字段

注意: 这样的数据绑定只能传递 JSON 兼容数据.还能在数据中包含函数.(这些函数不能在 WXML 中直接调用, 只能传递给子组件)

**组件 wxml 的 slot**

在组件的 wxml 中可以包含 slot 节点, 用于承载组件使用者提供的wxml 结构

默认情况下, 一个组件的 wxml 中只能有一个 slot, 需要多个 slot 时, 可以在组件 js 中声明启动.

```js
Component({
    options: {
        multipleSlots: true //	在组件定义时选项中启用多 slot 支持
    },
    properties: {},
    methods: {}
}) 
```

此时, 我们就可以在这个组件的 wxml 中使用多个 slot, 以不同的name来区分.

```html
<!--组件模板-->
<view class="wrapper">
	<slot name="before"></slot>
    <view>这里是组件内部内容</view>
    <slot name="after"></slot>
</view>

<!--使用时, 我们用 slot 属性指定节点插入到不同 slot位置
	引用组件模板 page
-->
<view>
	<component-tag-name>
        <!--这部分会被插入到 <slot name="before"> 的位置上-->
        <view slot="before">before</view>
        <!--这部分会被插入到 <slot name="after"> 的位置上 -->
        <view slot="after">after</view>
    </component-tag-name>
</view>
```

**组件样式**

组件对应的 wxss 文件样式, 只对组件 wxml 内的节点生效. 编写组件时. 需要注意以下几点

- 组件和引用组件的页面不能使用 id 选择器 (#a), 属性选择器 ([a]) 和标签名选择器, 请改用 class选择器
- 组件的引用组件的页面中使用后代选择器 (.a .b) 在一些极端情况下会有非预期的表现, 尽量避免
- 子元素选择器 (.a > .b) 只能用于 view 组件与子节点之间, 用于其他组件可能会导致非预期的情况
- 继承样式, 如 font, color 会从组件外继承到组件内
- 出继承样式外, app.wxss 中的样式, 组件所在的页面的样式对自定义组件无效

```css
#a {} /*组件中不能使用*/
[a] {}  /*组件中不能使用*/
button {} /*组件中不能使用*/
.a > .b {} /*除非 .a 是 view 组件节点, 否则不一定会生效*/
```

除此之外, 组件可以指定它所在节点默认样式, 使用 :host 选择器指定默认样式

```html
<!--组件 custom-component 的 .wxss-->
:host{
	color:yellow
}
<!--页面 wxml-->
<custom-component>这段文字颜色默认黄色</custom-component>
```

**外部样式类**

这个特性可以用于实现类似于 view 组件的 hover-class 属性: 页面可以提供一个样式类, 赋予 view 的 hover-class, 这个样式类本身写在页面中而而非 view 组件的实现中.

在同一个节点上使用普通样式类和外部样式类时, 两个类的优先级是未定义, 最好避免这种情况.

```scss
/*组件 custom-component.js*/
Component({
    externalClasses: ['my-class']
})
```

```html
<!--组件 custom-component.wxml-->
<custom-component class="my-class">
    这段文字的颜色由组件外部的class决定
</custom-component>
```

这样, 组件的使用者就可以指定这个样式类对应的class, 就像我们使用普通属性一样

```css
<!--页面的wxss-->
.my-class{
    color: red;
}
```

**使组件接受全局样式**

默认情况下, 自定义组件的样式只能接受自定义组件的 wxss 的影响, 除非以下两种情况

- app.wxss 或页面的 wxss 中使用了标签名选择器(或一些其他特殊选择器) 来直接指定样式,  这些选择器会影响到页面和全部组件. 通常情况下这是不推荐的做法.
- 在特定的自定义组件激活了 addGlobalClass 选项, 使得这个自定义组件能被 app.wxss 或页面的 wxss 中所有样式影响

要激活 addGlobalClass 选项, 只需要在  Component 构造器中将 options.addGlobalClass 字段置为 true

激活了 addGlobalClass 选项后, 存在外部样式污染组件样式的风险, 谨慎选择

```js
/* 组件 custom-component.js */
Component({
    options: {
        addGlobalClass: true,
    }
})
```

### Component 构造器

**定义段与实例方法**

component 构造器可以用于定义组件, 调用 Component 构造器可以指定组件的二属性, 数据, 方法等

- properties 组件的外部属性, 是属性名到属性设置的映射表, 属性中可以包含三个字段, `type` 表示数学类型, `value` 表示属性初始值, `observer` 表示数学值被更改时的响应函数
- data 组件的内部数据, 和 `properties` 一同用于组件的模板渲染
- methods 组件的方法, 包含事件响应函数和任意的自定义方法
- behaviors 类似于mixins 和 traits 的组件间代码复用机制
- created 组件的而生命周期, 在组件实例刚刚被创建时执行, 此时不能调用 setData
- attached 组件的生命函数, 在组件实例进入页面节点树时执行
- ready 组件的生命周期函数, 在组件布局完成后执行
- moved 组件的生命周期函数, 在组件实例被移动到节点树另一个位置时执行
- detached 组件生命周期函数, 在组件实例被从页面节点树移除时执行
- relations 组件间关系定义
- externalClasses 组件接受外部样式类
- options 一些选项
- lifetimes 组件生命周期声明对象
- pageLifetimes 组件所在页面的生命周期声明对象, 支持页面的 show, hide
- definitionFilter 定义段过滤器, 用于自定义组件扩展

生成的组件实例可以在组件的方法, 生命周期和属性 observer 中通过this访问, 组件包含一些**通用属性**和**方法**

**属性**

- is 组件的文件路径
- id 节点id
- dataset 节点dataset
- data 组件数据, 包括内部数据和属性值
- properties 组件数据, 与data一致

**方法**

- setData 设置data并执行图层渲染
- hasBehavior 检查组件是否具有 behavior(检查时会递归检查被直接/简介引入的所有吧behavior)
- triggerEvent 触发事件
- createSelectorQuery 创建一个 SelectorQuery 对象
- createIntersectionObserver 创建一个 intersectionObserver 对象
- selectComponent 使用选择器选择组件实例节点, 返回匹配到的第一个组件实例对象
- selectAllComponents 选择选择器组件实例节点, 返回匹配到的全部组件实例对象组成的数组
- getRelationNodes 获取整个关系对应的所有关联节点
- groupSetData 立刻执行callback, 其中多个 setData 之间不会触发见面绘制

代码示例

```js
Component({
    behaviors: [],
    properties: {
        myProperty: {	//	属性名
            type: String,	//	类型(必填) null表示任意类型
            value: '', //	属性初始值(可选)
            observer(newVal, oldVal, changedPath) {
                //	属性被改变时触发的函数(可选), 也可以写成methods段中定义的方法名字字符串, 如 '_propertyChange'
                //	newVla 是新设置的数据, oldVal 就是旧数据
            }
        },
        myProperty2: String // 简化定义方式
    },
    data: {},	//	私有数据, 用于模板渲染
    lifetimes: {
        //	生命周期函数, 可以作为函数, 或一个在 methods 段中定义的方法名
        attached() {},
        moved() {},
        detached() {}
    },
    //	生命周期函数, 可以为一个函数, 或在 methods 端重定义的方法名
    attached() {}, //	此处 attached 的声明会被 lifetimes 字段中的声明覆盖
    ready() {},
    pageLifetimes: {
        //	组件所在一峨眉的生命周期函数
        show() {},
        hide() {},
        resize() {},
    },
    methods: {
        onMyButtonTap() {
            this.setData({
                //	更新属性和数据的方法与更新页面数据方法类似
            })
        },
        //	内部方法建议以下划线开头
        _myPrivateMethod() {
            //	这里将 data.A[0].B 设为 'myPrivatedata'
            this.setData({
                'A[0].B': 'myPrivatedata'
            })
        },
        _propertyChange(newVla, oldVal) {

        }
    }
})
```

注意: 在 properties 定义的字段中, 属性名采用驼峰写法(propertyName), 在 wxml 中, 指定属性时则对应使用连字符写法 (property-name), 应用于数据绑定时采用头发写法法 attr="{{propertyName}}"

**使用 Component 构造器构造页面**

事实上, 小程序的页面也可以视为自定义组件, 因为也可以使用 Component 构造器构造, 拥有与普通组件一样的定义段与实例方法.此时要求对应 json 文件汇总包含 usingComponents 定义段.

此时,  组件的属性可以用于接收页面的参数, 如访问 `/pages/index/index?paramA=123&paramB=xyz`, 如果声明有属性 `paramA` 或 `paramB`, 则他们会被赋值为 123 或 xyz

页面的生命周期方法 `on` 开头的方法, 都应该写在 `methods`定义段中

```json
{
    "usingComponent": {}
}
```

```js
Component({
    properties: {
        paramA: Number,
        paramB: String,
    },
    methods: {
        onLoad() {
            this.data.paramA
            this.data.paramB
        }
    }
})
```

BUG & TIPS

- 使用 this.data 可以获取内部值和属性值. 但是不要直接修改他们, 应该使用 `setData` 修改

- 生命周期函数无法在组件方法中通过 `this` 访问到.
- 属性名应避免以 data 开头, 在WXML 中, `data-xyz=""` 会被作为节点dataset 来处理, 而不是组件属性
- 在一个组件的定义和使用时, 组件的属性名和 data 字段相互间都不能冲突

- 对象类型的属性和data字段中可以包含属性类型的子字段, 可以通过对象类型的属性字段来传递函数
- `bug` 对于type 为 object 或 array 的属性, 如果通过该组件自身的 this.setData 来改变属性值的一个子字段, 则依旧会触发属性 observer, 且 observer 接受到的 newVal 是变化的那个字段的值, oldVal 为空, changedPath 包含字段的字段名相关信息

### 组件事件

**组件间通信**

组件间的通信方式有以下几种

- WXML 数据绑定: 用于父组件向子组件的指定属性设置数据, 仅能设 JSON 兼容数据, 可以在数据中包含函数
- 事件: 用于子组件向父组件传递数据, 可以传递任意数据
- 如果以上两种方式不足以满足需求, 父组件可以通过 `this.selectComponent` 方法获取子组件实例对象, 这样就可以直接访问组件的任意数据和方法

**监听事件**

事件系统是组件间通讯的主要方式之一. 自定义组件可以触发任意的事件, 引用组件的页面可以监听这些事件.

监听自定义组件事件的方法和监听基础事件的方法一致

代码示例

```html
<!--当自定义组件触发 myevent 时间时, 调用 onMyEvent方法-->
<component-tag-name bindmyevent="onMyEvent" />
<!--或可以写成-->
<component-tag-name bind:myevent="onMyEvent" />
```

```js
Page({
    onMyEvent(e){
        e.detail	//	自定义组件触发事件时提供的detail对象
    }
})
```

**触发事件**

自定义组件触发事件时, 需要使用 `triggerEvent` 方法, 指定事件名, detail 对象和事件选项

代码示例

```html
<!-- 自定义组件中 -->
<button bindtap="onTap">点击按钮触发 myEvent 事件</button>
```

```js
Component({
    properties: {},
    methods: {
        onTap() {
            const myEventDetail = {} //	detail 对象, 提供给事件监听函数
            const myEventOption = {} //	触发事件的选项
            this.triggerEvent('myevent', myEventDetail, myEventOption)
        }
    }
})
```

触发事件的选项包括

- bubbles 事件是否冒泡
- composed 事件是否可以穿越组件边界, 为false时, 事件只能在引用组件的节点树上触发, 不进入其它任何组件内部, 默认false
- capturePhase 事件是否拥有捕获阶段

代码示例: 

```html
<!--页面 page.html-->
<another-component bindcustomevent="pageEventListener1">
    <my-component bindcustomevent="pageEventListener2"></my-component>
</another-component>
```

```html
<!--组件 another-component.wxml -->
<view bindcustomevent="anotherEventListener"><slot /></view>

<!--组件 my-component.wxml -->
<view bindcustomevent="myEventListener"><slot /></view>
```

```js
//	组件 my-component.js
Component({
    methods: {
        onTap() {
            this.triggerEvent('customevent', {})	//	只触发 pageEventListener2
            this.triggerEvent('customevent', {bubbles: true}) //	依次触发 pageEventListener1 pageEventListener2
            this.triggerEvent('customevent', {bubbles: true, composed: true}) //	依次触发 pageEventListener1 pageEventListener2
        }
    }
})
```

### 组件生命周期

组件的生命周期, 值的是组件自身的一些函数, 这些函数叜特殊的时间点或遇到一些特殊的框架事件会被自动触发

其中, 最重要的生命周期就是 `created` `attached` `detached` 包含一个组件实例生命流程的最主要时间点. 

- 组件实例刚好被创建时, `created`生命周期被触发, 此时, 组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` . 此时还不能调用 `setData`. 通常情况下, 这个生命周期只应该用于给组件 `this` 添加一些自定义属性字段
- 在组件完全初始化完成, 进入页面节点数后, `attached` 生命周期被触发, 此时, `this.data` 已被初始化当前值. 这个生命周期很有用, 绝大多数初始化工作在这个时机进行.
- 在组件离开页面节点数后, `detached` 生命周期被触发. 退出一个页面时, 如果页面还在页面节点树中, 则`detached` 会被触发

**定义生命周期方法**

生命周期方法可以直接定义在 `Component` 构造器的第一级参数中.

组件的生命周期也可以在 `lifetimes` 字段内进行声明(推荐方式, 优先级最高)

代码示例

```js
Component({
    lifetimes: {
        attached() {
            //	组件实例进入页面节点树时执行
        },
        detached() {
            //	组件实例被从页面节点移除时执行
        }
    }
})
```

在 behaviours 中也可以编写 生命周期方法, 同时不会与其它 behaviours 中的同名生命周期相互覆盖, 要注意的是, 如果一个组件多次直接或间接引用同一个 behavior, 这个behavior 中的生命周期函数在一个执行时机内只会执行一次.

可用的全部声明走去函数如下

- created	组件实例刚刚被创建时执行
- attached 组件实例进入页面节点树时执行
- ready  组件在视图层布局完成后执行
- moved  组件实例被移动到节点树另外一个位置时执行
- detached  组件实例被页面节点数移除时执行
- error 当组件方法抛出错误时执行

**组件所在页面的生命周期**

还有一些特殊的生命周期, 他们并非与组件有很强的的关联, 但是组件需要获知, 以便组件内部处理, 这样的生命周期称为 "组件所在页面的生命周期", 在 `pageLifetimes` 定义段中定义. 其中可用的生命周期有

- show 组件所在页面被展示时执行
- hide 组件所在页面被隐藏时执行
- resize 组件所在页面尺寸发生变化时执行

```js
Component({
    pageLifetimes: {
        show() {
            //	页面被展示触发
        },
        hide() {
            //	页面被隐藏触发
        },
        resize(size) {
            //	页面尺寸变化触发
        }
    }
})
```

**定义和使用 behaviors**

`behaviors` 是用于组件间代码共享的特性, 类似于一些编程语言中的 "mixins" 或 "traits".

每个`behaviors` 可以包含一组属性, 数据, 生命周期和方法, 组件引用它时, 他的属性, 数据和方法被合并到组件中, 生命周期函数也会在每个队员的时机被调用, 每个组件可引用多个 `behaviors` .`behaviors` 也可以引用其他 `behaviors`

`behaviors` 需要使用 `Behavior()` 构造器定义

代码示例

```js
//	my-behavior.js
module.exports = Behavior({
    behaviors: [],
    properties: {
        myBehaviorProperty: {
            type: String
        }
    },
    data: {
        myBeHaviorData: {}
    },
    attached() {},
    methods: {
        myBehaviorMethod() {}
    }
})
```

组件引用时, 在 `behaviors` 定义段中将它们逐个列出即可

```js
// my-component.js
const myBehavior = require('my-behavior')
Component({
    behaviors: [myBehavior],
    properties: {
        myProperty: {
            type: String
        }
    },
    data:{
    	myData: {}
    },
    attached() {},
    methods:() {
        myMethod() {}
    }
})
```

在上述例子中, `my-component` 组件定义中加入了 `my-behavior`, 而 `my-behavior` 中包含有 `myBehaviorProperty` 属性,`myBehaviorData` 数据字段, `myBehaviorMethod` 方法和一个 `attached` 生命周期函数, 这将使得 `my-component` 中最终包含这些属性, 数据和方法, 当组件触发 attached 生命周期函数时, 会依次触发 attached 生命周期和 my-component 中的 attached 生命周期函数

**字段覆盖和组合规则**

组件和它引用的 `behavior` 中可以包含同名的字段, 这些字段的处理方法如下: 

- 如果有同名的属性或方法, 组件本身的属性或方法会覆盖 `behavior` 中的属性和方法, 如果引用了多个 `behavior` , 在定义段中靠后的会覆盖靠前的
- 如果有同名的数据, 如果数据是对象leix,会进行对象合并, 如果非对象类型则进行互相覆盖
- 生命周期函数不会相互覆盖, 而是在对应触发时机被逐个调用, 如果同一个 behavior 被一个组件多次引用. 它定义的生命周期函数只会被执行一次

**内置 behaviors**

自定义组件可以通过引用内置的 `behavior` 来获得内置组件的一些行为.

```JS
Component({
    behavior: ['wx://form-field']
})
```

上述例子 `wx://form-field` 代表一个内置的 `behavior`, 它使得这个自定义组件有类似于表单控件的行为.

内置 `behavior` 往往会为组件添加一些属性, 没有特殊说明下, 组件可以覆盖这些属性以改变它的 type 或添加 `observer`.

**wx://form-field**

是自定义组件有类似于表单控件的行为, from 组件可以识别这些自定义组件, 并在 submit 事件中返回组件字段名以及其对应的字段值, 这将为它添加以下两个属性

- name 表单中字段名
-  value 表单中字段值

**wx://component-export**

使自定义组件支持 `export` 定义段, 这个定义段可以用于指定组件被 `selectComponent` 调用时的返回值

未使用这个定义段时, `selectComponent` 将返回自定义组件的`this` 使用这个定义段时, 将以这个定义段的函数返回值代替

代码示例

```js
//	自定义组件 my-component
Component({
    behaviors: ['wx://component-export'],
    export() {
        return {myField: 'myValue'}
    }
})
```

```html
<!--使用自定义组件时-->
<my-component id="the-id">
```

```js
this.selectComponent('#the-id') //	等于 {myField: 'myValue'}
```

### 组件间关系

**定义和使用组件间关系**

```html
<custom-ul>
    <custom-li> item 1 </custom-li>
    <custon-li> item 2 </custom-li>
</custom-ul>
```

上述例子, `custom-ul` 和 `custom-li` 都是自定义组件, 他们又相互间的关系, 相互的通行往往比较复杂, 此时在组件定义时加入 `relations` 定义段, 可以解决这样的问题

```js
//	path/to/custom-ul.js
Component({
    relations: {
        './custom-li': {
            type: 'child', //	关联的节点为子节点
            linked(target) {
                //	每次 custom-li被插入时执行, target是该节点的实例对象, 触发在该节点 attached 生命周期之后
            },
            linkChange(target) {
                //	每次 custom-li 被移动后执行, target 是该节点的实例对象, 触发在该节点 moved 生命周期之后
            },
            unlinked(target) {
                //	每次 custom-li被移除时执行, target 是该节点的实例对象, 触发在该节点 detached 生命周期之后
            }
        }
    },
    methods: {
        _getAllLi() {
            //	使用 getRelationsNodes 可以获得 nodes 数组, 包含所有已关联的 custom-li, 并且有序
            const nodes = this.getRelationsNodes('path/to/custom-li')
        }
    },
    ready() {
        this._getAllLi()
    }
})
```

```js
//	path/to/custom-li.js
Component({
    relations: {
        './custom-ul': {
            type:'parent', //	关联的目标节点应为父节点
            linked(target) {},
            linkChange(target) {},
            unlinked(target) {}
        }
    }
})
```

注意: 必须在两个组件定义汇总都加入 relations定义组件关系, 否则不会生效

**关联一类组件**	

```html
<custom-form>
	<view>
    	input
        <custom-input></custom-input>
    </view>
    <custom-input>suybmit</custom-input>
</custom-form>
```

custom-form 组件想要关联 custom-input 和 custon-buttom 两个组件, 此时, 如果两个组件都有同一个 behavior

```js
//	path/to/custom-form-controls.js
module.exports =  Behavior({
	//	...
})
```

```js
//	path/to/custom-input.js
const customFormControls = require('./custom-form-controls')
Component({
    behaviors: [customFormControls],
    relations: {
        './custom-form': {
            type: 'ancestor',	//	关联的目标节点为祖先节点
        }
    }
})


// path/to/custom-submit.js
const customFormControls = require('./custom-form-controls')
Component({
    behaviors: [customFormControls],
    relations: {
        './custom-form': {
            type: 'ancestor', // 关联的目标节点应为祖先节点
        }
    }
})
```

则在 relations 关联定义中, 可以使用这个 behavior 来代替组件路径作为关联的目标节点

```js
// path/to/custom-form.js
const customFormControls = require('./custom-form-controls')
Component({
    relations: {
        customFormControls: {
            type: 'descendant', // 关联的目标节点应为子孙节点
            target: customFormControls
        }
    }
})
```

**relations 定义段**

- type 必填, 目标组件的相对关系, parent/child/ancestor/descendant
- linked 关系生命周期函数
- linkChanged 关系生命周期函数
- unlinked 噶UN西生命周期函数
- target 如果该项被设置, 表示关联的目标节点所具有的behavior

### 抽象节点

有时, 自定义组件模板中的一些节点, 其对于的自定义组件不是由自定义组件本身确定的, 而是自定义组件的调用者确定的. 这时候就可以把这个节点声明为抽象节点

比如, 我们事先一个 "选框组" 组件, 他其中可以防止单选框/复选框, 这个组件的 wxml 可以这么写

```html
<!--selectable-group.wxml-->
<view wx:for="{{labels}}">
	<label>
    	<selectable disabled="{{false}}">
        	{{item}}
        </selectable>
    </label>
</view>
```

其中, "selectable" 不是任何在 json 文件的 `usingComponents` 字段中声明的组件, 而是一个抽象节点, 它需要在 componentGenerics 字段中声明

```json
{
    "componentGenerics": {
        "selectable": true
    }
}
```

**使用包含抽象节点的组件**

在使用 selectable-group 组件时, 我们必须指定 "selectable" 具体是哪个组件

```html
<selectable-group generic:selectable="custom-radio" />
```

这样, 在生成这个 selectable-group 组件的实例时, "selectable" 节点就会生成 "custom-radio" 组件实例

```html
<selectable-group generic:selectable="custom-checkbox"/>
```

如此, "selectable" 节点责护生成 "custom-checkbox" 组件实例

注意: 上述的 `custom-radio` 和 `custom-checkbox` 需要包含这个 wxml 对应的 json 文件的 `usingComponents` 定义段中

```js
{
    "usingComponents": {
        "custom-radio": "path/to/custom/radio",
        "custom-checkbox":"path/to/custom/checkbox"
    }
}
```

**抽象节点的默认组件**

抽象节点可以指定一个默认组件, 当具体组件未被指定, 将创建默认组件的实例, 默认组件可以在 `componentGenerics` 字段中指定

```js
{
    "componentGenerics": {
        "selectable": {
            "default": "path/to/default/component"
        }
    }
}
```

注意: 节点的 generic 引用的 `generic:xxx="yyy"` 中, 值 yyy 只能是静态值, 不能包含数据绑定, 所以抽象节点特性不适用于动态决定节点名的场景.

### 单元测试

在编写高质量的自定义组件过程时, 完善的测试用例是 提高自定义组件可用性的保证, 同时测试代码覆盖率也是必不可少的一个环节. 小程序支持使用 npm 安装自定义组件, 针对自定义组件的单元测试也是必须支持的

##  插件

插件的开发和使用

插件是一组 js 接口, 自定义组件或页面的封装, 用于嵌入到小程序中使用, 插件不能独立运行, 必须嵌入在其他小程序中才能被用户使用, 而第三方小程序在使用插件时, 也无法看到插件代码, 因此, 插件适合用来封装自己的功能或服务, 提供给第三方小程序进行展示和使用.

插件开发者可以像开发小程序一样编写一个插件并上传代码, 在插件发布之后, 其他小程序方可调用. 小程序平台会托管插件代码, 其他小程序调用时, 上传的插件代码会跟随小程序一起下载运行

相比普通的 js 文件或自定义组件, 插件拥有更大的独立性, 拥有独立的 API 接口, 域名列表等, 但同时会受到一些限制, 如一些API 无法调用或功能受限, 还有个别特殊的接口, 虽然插件不能直接调用, 但可以使用插件功能页来间接实现

同时, 框架会对小程序和小程序使用的每个 插件进行数据安全保护, 保证它们之间不能切取其它任何一方的数据(除非数据被主动传递给另一方)

### 使用插件

**添加插件**

在使用插件前, 首先要在小程序管理后台的 "设置-第三方服务-插件管理" 中添加插件, 开发者可登录小程序管理后台, 通过 appId 查找插件并添加, 如果插件无需申请, 添加后可直接到使用, 否则需要申请并等待插件开发者通过后, 方可在小程序中使用相应的插件.

**引入插件代码包**

使用插件前, 使用者要在 `app.json` 声明需要使用的插件, 如

```json
//	app.json
{
    "plugins": {
        'myplugin': {
            "version": "1.0.0",
            "provider": "wxidxxxxxxxxxxxxx"
        }
    }
}
```

如上例所示, `plugins` 定义段中可以包含多个插件声明, 每个插件声明以一个使用者自定义插件引用名作为标识, 并指明插件的 appid 和 需要使用的版本号, 其中, 引用名由使用者自定义, 无需和插件开发者保持一致或与开发者协调, 在后续的插件使用中, 该引用名将被用于表示该插件

**使用插件**

使用插件时, 插件的代码对于使用者来说是不可见的. 为了正确使用插件, 使用者查看详情页面中的"开发文档"一节, 阅读由插件开发者提供的插件开发文档, 通过文档来明确插件提供的自定义组件, 页面名称及提供的js接口规范等

### 功能页

某些接口不能在插件中直接调用, 如 wx.login, 插件开发者额可以使用插件功能页的方式来实现. 目前, 插件功能页包括

- 获取用户信息, 包括 openid 和 昵称等(相当于 wx.login 和 wx.getUserInfo 的功能)
- 支持 (相当于 wx.requestPayment)
- 获取收货地址 (相当于 wx.chooseAddress)

要使用插件功能页, 需要县级或功能页特性, 配置对应的功能页函数, 再使用 <functional-page-navigator> 组件跳转到插件功能页, 从而实现相对应的功能

开始之前, 我们需要知道, 插件功能页是指 **插件所有者小程序** 中的一个特殊页面

插件所有者小程序, 指的是与插件 AppID 相同的小程序, 例如, '小程序实例' 小程序开发了一个 "小程序示例插件", 那么无论这个插件被哪个小程序使用, 这个插件的 插件所欧哲小程序 都是 '小程序示例'

**激活功能页特性**

要在插件中调用插件功能页, 需要先激活插件所有者小程序的功能页特性. 具体来说, 在插件所有者小程序的 app.json 中添加 `functionalPages` 定义段, 为 `true`

**跳转功能页**

功能页不能使用 `wx.navigateTo` 来进行跳转, 而是需要 <functional-page-navigator> 组件, 以获取用户信息为例, 

## 基础能力

### **网络**

在小程序中使用网络相关 API 时, 需要注意下列问题

1. 服务器域名配置

   每个微信小程序需要事先设置一个通讯域名, 小程序只可以跟指定的域名进行网络通信, 包括普通的 HTTPS 请求(wx.request), 上传文件(wx.uploadFile), 下载文件(wx.downloadFile) 和 WebSocket 通信(wx.connectSocket)

   **配置流程**

   服务器域名在 [小程序后台- 开发- 开发设置- 服务器域名] 中进行配置, 配置时需要注意

   - 域名只支持 `https` (wx.request, wx.uploadFile, wx.downloadFile) 和 `wss` (wx.connectSocket) 协议
   - 域名不能使用 IP 地址或 localhost;
   - 域名必须经过 ICP 备案
   - 出于安全考虑, api.weixin.qq.com 不能被配置为服务器域名, 相关 API 也不能在小程序内调用, 开发者应该将 appsecret 保存到后台服务器中, 通过服务器使用 appsecret 获取 accesstoken, 并调用相关 api
   - 对于每个接口, 分别可以配置最多 20 个域名

2. 网络请求

   超时时间 默认60s, 超时时间可以在 app.json 中设置

   使用限制

   - 网络请求的 `referer` header 不可设置. 其格式固定为 `https://servicewechat.com/{appid}/{version}/page-frame.html`, 其中 `{appid}` 为小程序的 `appid`, {version} 为小程序的版本号, 0 表示开发版, 体验版以及审核版本, 版本号为 `devtools` 表示为开发者工具, 其余为正式版
   - `wx.request` `wx.uploadFile` `wx.downloadFile` 的最大并发限制是 10 个
   - 小程序进入后台后, 非指定聊天, 如果 5s 内网络请求没有结束, 会回调错误信息 `fail interrupted` 在回到前台之前, 网络请求接口都无法调用

   返回值编码

   - 只要成功接收到服务器返回, 无论 `statusCode` 是多少, 都会进入 `success` 回调. 开发者根据业务逻辑对返回值进行判断

3. 常见问题

   HTTPS 证书

   小程序必须使用 HTTPS/WSS 发起网络请求, 请求时系统会对服务器域名使用的 HTTPS 证书进行校验, 如果校验失败, 则请求不能发送成功, 由于系统限制, 不同平台对于证书的要求的严格程度不同, 为了保证小程序的兼容性, 建议开发者按照最高标注进行证书配置, 并使用相关工具检查现有证书是否符合要求

   对证书要求如下

   - HTTPS 证书必须有效:
     - 证书必须被系统信任, 即根证书被系统内中
     - 部署的 SSL 证书的网站域名必须与证书颁发域名一致
     - 证书必须在有效期内
     - 证书的信任链必须完整(需要服务器配置)
   - ISO 不支持自签名证书
   - ISO 下证书必须满足苹果 App Transport Security 的要求

   跳过域名检验

   在微信开发者工具中, 可以临时开启 开发环境不校验请求域名, TLS 版本及 HTTPS 证书 选项, 跳过服务器域名的校验, 此时, 在微信开发者工具中及手机开启调试时, 不会进行服务器域名的检验

   在服务器域名配置成功后, 建议开发者关闭跳过该检验

##### 局域网通信

基础库 2.4.0 提供了 `wx.startLocalServiceDiscovery` 等系系列 mDNS API , 可以哟来获取局域网内提供的 mDNS 服务的设备 的 IP. 

`wx.request` 等的 url 参数允许为 `${IP}:${POST}/${PATH}` 的格式, 当且仅当 IP 与手机 IP处于同一网段, 且不与本机 IP 相同时, 请求/连接才会成功. 这种情况下, 不会进行安全域的额检验, 不要求必须使用 http/wss 也可以使用 http/ws

```js
wx.request({
    url: 'http://10.9.176.40:828'
    // 省略其他参数
})
```

### 存储

每个微信小程序都有可以有自己的本地存储, 可以通过 `wx.setStorage` `wx.getStorage` `wx.clearStorage` `wx.removeStorage`  对本地缓存进行读写操作

同一个微信用户, 同一个小程序 storage 上限为 10 MB, storage 以用户未读隔离, 同一台设备上, A用户无法读取 B用户的数据

注意: 如果用户存储空间不足, 我们会清空最近最久未使用的小程序本地缓存, 我们不建议将关键信息全部存在 storage, 以防止存储空不足或用户换设备的情况.

### 文件系统

文件系统是小程序提供的一套以我笑傲程序和用户维度隔离的存储以及一套相应的管理接口, 通过 `wx.getFileSystemManager()` 可以获取到去拿局唯一的文件系统管理器, 所有文件系统的管理操作通过 `fileSystemManager` 来调用

```js
const fs = wx.getFileSystemManager()
```

文件主要分为两大类

- **代码包文件**: 在目录项目目录中添加的文件
- **本地文件**: 通过调用接口本地产生, 或通过网络下载来, 存储到本地的文件.

本地文件分为三种:

1. 本地临时文件: 临时产生, 随时会被回收的文件, 不限制存储大小
2. 本地缓存文件: 小程序通过接口把本地临时文件缓存后产生的文件, 不能自定义目录和文件名, 除非用户主动删除小程序, 否则不会被删除, 跟本地哟惊呼文件共计, 普通小程序最多可存储 10 MB
3. 本地用户文件: 小程序通过接口把本地临时文件缓存后产生的文件, 允许自定义目录和文件名, 除非用户主动删除小程序, 否则不会被删除. 跟本地用户文件共计, 普通小程序最多存储 10MB

##### **代码包文件**

由于代码包文件大小限制, 代码包文适用于放置首次加载时需要的文件, 对于内容较大或需要动态替换的文件, 不推荐用添加到代码包中.

**访问代码包文件**

代码包文件的访问方式是从项目根目录开始写文件路径, 不支持相对路径的写法

**修改代码包文件**

代码包内的我呢间无法在运行后动态修改或删除, 修改代码包文件需要重新发布版本

##### **本地文件**

本地文件指的是小程序被用户添加到手机后, 会有一块独立的文件存储㻃, 以用户维度隔离, 即同一台手机, 每一个微笑用户不能访问到其他登录用户的文件, 同一个用户不同 appid 之间文件也是不能相互访问

本地文件的文件均为以下格式

{{协议名}}://文件路径

**本地临时文件**

本地临时文件只能通过调用特定接口产生, 不能直接写入内容. 本地临时文件产生后, 仅在当前生命周期内有效, 重启逆之后即不可用. 因此, **不可以把本地临时文件路径存储起来下次使用**. 如如果需要下次使用, 通过 FileSystemManger.saveFile() 或 FileSystemManager.copyFile() 接口把本地临时文件转换成本地缓存文件或本地用户文件.

```js
wx.chooseImage({
    success(res){
        const tempFilePaths = res.tempFilePaths	//	tempFilePaths 的每一项是一个本地临时文件路径
    }
})
```

**本地缓存文件**

本地缓存文件只能通过接口调用特定的接口产生, 不能直接写入内容. 本地缓存文件产生后, 重启之后仍可用. 本地缓存文件只能通过 FileSystemManager.saveFile() 接口将本地临时文件保存获得.

示例:

```js
fs.saveFile({
    tempFilePath: '',	//	传入一个本地临时文件
    success(res) {
        console.log(res.savedFilePath)	//	res.savedFilePath 作为一个本地缓存文件路径
    }
})
```

注意: 本地缓存文件是最初的设计 提供了功能更完整的本地文件, 可以完全覆盖本地缓存文件的功能

**本地用户文件**

本地用户是从`1.7.9` 版本开始新增的概念, 我们提供了一个用户文件目录给开发者, 开发者对这个目录有完全自由的读写权利. 通过 `wx.env.USER_DATA_PATH` 可以虎丘到这个目录的路径

```js
const fs = wx.getFileSystemManager()
fs.writeFileSync(`${wx.env.USER_DATA_PATH}/hello.txt`, 'heelo, world', 'utf8')
```

**读写权限**

| 接口、组件   | 读   | 写   |
| ------------ | ---- | ---- |
| 代码包文件   | 有   | 无   |
| 本地临时文件 | 有   | 无   |
| 本地缓存文件 | 有   | 无   |
| 本地用户文件 | 有   | 有   |

### 画布

**Canvas** 画布

所有在 `canvas` 中的图画必须使用 JavaScript 完成

WXML 

```js
//	wxml
<canvas canvas-id="myCanvas" style="border: 1px solid;" />

//	js
const ctx = wx.createCanvasContext('myCanvas')
ctx.setFillStyle('red')
ctx.fillRect(10,10,150,75)
ctx.draw()
```

第一步: 创建一个 Canvas 绘图上下文

首先, 我们需要创建一个 Canvas 绘图上下文 CanvasContext

CanvasContext 是小程序内建的一个对象, 有一些绘图的方法

```js
const ctx=wx.createCanvasContext('myCanvas')
```

第二步: 使用Canvas 绘图上下文进行绘图描述

接着, 我们来描述在Canvas 中绘制什么内容

设置绘图上下文填充色为红色

```js
ctx.setFillStyle('red')
```

用 `fillRect(x, y, width, height)` 方法绘制一个矩形, 填充为刚刚才设置的红色

```js
ctx.fillRect(10, 10, 150, 75)
```

第三步: 画图

告诉 `<canvas>` 组件你要将刚刚的描述绘上去

```js
ctx.draw()
```

**坐标系**

canvas 是一个在二维网格中, 左上角坐标为 `(0, 0)`

我们使用 `fileRect()` 方法

含义是从左上角 `(0, 0)` kaish8i, 画一个 `150*75 px` 的矩形

代码示例

我们可以在<canvas> 中加上一些事件, 来观测他的坐标系

```html
<canvas 
        canvas-id="myCanvas"
        style="margin: 5px; border:1px solid #ddd"
        bindtouchstart="start"
        bindtouchend="end"
        />

<view hidden="{{hidden}}">Coordinates: ({{x}}, {{y}})</view>
```

```js
Page({
    data: {
        x: 0,
        y: 0,
        hidden: true
    },
    start(e) {
        this.setData({
            hidden: false,
            x: e.touches[0].x,
            y: e.touches[0].y
        })
    },
    move(e){
        this.setData({
            x: e.touches[0].x,
            y: e.touches[0].y
        })
    },
    end(e){ 
        this.setData({
            hidden: true
        })
	}
})
```

**渐变**

渐变能用于填充一个 矩形, 圆, 线, 文字等. 填充色可以不固定

我们提供了两种颜色渐变方式

- `createLinearGradient(x, y, x1, y1)` 创建一个线性渐变
- `createCircularGadient(x, y, r)` 创建一个从圆心开始的渐变

一旦我们创建了一个渐变对象, 我们必须添加两个颜色渐变点

`addColorStop(postion, color)` 方法用于指定颜色渐变点的位置和颜色, 位置必须位于 0-1 之间

可以用`setFillStyle` 和 `setStrokeStyle` 方法设置渐变, 然后进行画圆描述

使用 `createLinearGradient()`

```js
const ctx = wx.createCanvasContext('myCanvas')
const grd = ctx.createLinearGradient(0, 0, 200, 0)
grd.addColorStop(0, 'red')
grd.addColorStop(1, 'write')

ctx.setFillStyle(grd)
ctx.fillRect(10, 10, 150, 80)
ctx.draw()

```

### 分包加载

某些情况下, 开发者需要将小程序划分成不同的子包, 在构建时打包成不同的分包, 用户使用时按需进行加载

在构建小程序分包项目时, 构建会输出一个或多个分包. 每个分包小程序必定含一个主包. 所谓的主包, 即放置默认启动页面/TabBar页面, 以及一些所有分包都必须用到的公共资源/JS脚本; 而分包则根据开发者额的配置进行划分

在小程序启动时, 默认会下载主包并启动主包内的页面, 当用户进入分包内某个页面, 客户端会把对应分包下载, 下载完成进行展示

目前小程序分包大小有以下限制:

- 整个小程序所有分包大小不超过 8M
- 单个分包/主包大小不能超过 2M

对小程序进行分包, 可以优化小程序首次启动的下载时间, 以及在多团队共同开发时可以更好的解耦协作

##### 使用分包

**配制方法**

假设支持分包的小程序目录结构如下

```
├── app.js
├── app.json
├── app.wxss
├── packageA
│   └── pages
│       ├── cat
│       └── dog
├── packageB
│   └── pages
│       ├── apple
│       └── banana
├── pages
│   ├── index
│   └── logs
└── utils
```

开发者通过在 app.json `subpackages` 字段声明项目分包结构

```json
{
    "pages": ["pages/index", "pages/logs"],
    "subpackages": [
        {
            "root": "packageA",
            "pages": ["pages/cat", "pages/dog"]
        },
        {
            "root":"packageB",
            "name":"pack2",
            "pages": ["pages/apple","pages/banana"]
        }
    ]
}
```

`subpackages` 中, 单个分包的配置有以下几项

- root 分包根目录
- name 分包别名, 分包预下载时可以使用
- pages 分包的页面路径, 相对分包根目录
- independent 分包是否是独立分包

**打包原则**

- 声明 `subpackages` 后, 将按 `subpackage` 配置路径进行打包, `subpackages` 配置路径外的目录将被打包到 `app` (主包) 中
- app (主包) 也可以由自己的 pages (最外层的pages 字段)
- `subpackage` 的根目录不能是另外一个 `subpackage` 内的子目录
- `tabBar` 页必须在 app (主包) 内

**引用原则**

- `packageA` 无法 require `packageB` 的JS 文件, 但是可以 require `app`, 自己的 package 内的 JS 文件
- `packageA`  无法 import `packageB` 的 `template`, 但可以 import  `app` , 自己 package 内 的 template
- `packageA` 无法使用 `packageB` 的资源, 但是可以使用 `app`, 自己的 package 内的资源

**低版本兼容**

由于微信后台编译来处理旧版本的客户端的兼容, 后台会编译两份代码包, 一份是分包后代码, 另外一份是整包的兼容代码, 新客户端用分包, 老客户端还是用整包, 完整包会把各个 `subpackage` 里面的路径放到 pages 中.

##### 独立分包

独立分包是小程序中一种特殊类型的分包, 可以独立与主包和其它分包运行. 从独立分包中的页面进入小程序时, 不需下载主包, 当用户进入普通分包或主包内页面时, 主包才会被下载.

开发者可以按需将某些具有一定功能的独立性的页面配置到独立分包中, 当小程序从普通的分包项目启动时, 需要首先下载主包; 而毒瘤分包不依赖主包即可运行. 可以很大程度提升分包页面启动速度

一个小程序中可以有多个分包.

**配置方法**

假设小程序目录结构如下

```
├── app.js
├── app.json
├── app.wxss
├── moduleA
│   └── pages
│       ├── rabbit
│       └── squirrel
├── moduleB
│   └── pages
│       ├── pear
│       └── pineapple
├── pages
│   ├── index
│   └── logs
└── utils
```

开发者可以在 `app.json` 的 `subpackages` 字段中对应的分包中定义 `independent` 字段声明对应包为独立分包

```json
{
    "pages": ["pages/index", "pages/logs"],
    "subpackages": [
        {
            "root": "moduleA",
            "pages": ["pages/rabbit", "pages/squirrel"]
        },
        {
            "root": "moduleA",
            "pages": ["pages/pear", "pages/pineapple"],
            "independent": true
        }
    ]
}
```

独立分包属于分包的一种, 普通分包的所有限制都对独立分包有效.. 独立分包中插件, 自定义组件的处理方式同普通分包.

此外,  使用独立分包时要注意

- 独立分包中不能依赖主包和其他分包中的内容, 包括 js , template , wxss, 自定义组件, 插件等, 主包中的 app.wxss 对独立分包无效, 应避免在独立分包中使用 app.wxss 中的样式
- app 只能在主包内定义, 独立分包中不能定义 app
- 独立分包中暂不支持使用插件

**注意事项**

1. 关于 getApp()

   与普通分包不同, 独立分包运行时, App 不一定被注册, 因此 getApp() 也不一定可以获得 App 对象

   - 当用户从独立分包页面启动小程序时, 主包不存在, App 也不存在, 此时调用 getApp() 获取到的是 `undefined`, 当用户进入普通分包或主包页面时, 主包才会被瞎子啊, App 才会被注册
   - 当用户是从普通分包或主包内页面内跳转到独立分包页面时, 主包已经存在, 此时掉用 getApp() 可以获得真正的 App

   由于以上限制, 开发者无法通过 APP 对象实现独立分包和小程序其它不部分的全局变量共享

   为了在独立分包中满足这一需求, 基础库2.2.4 版本开始 getApp  支持 allowDefault 参数, 在 App 未定义时返回一个默认实现, 当主包加载,  App 被注册, 默认实现中定义的属性会被覆盖合并到真正的 App 中

   示例代码

   - 独立分包中

   ```js
   const app = getApp({allowDefault: true})
   app.data = 456
   app.global= {}
   ```

   - app.js中

   ```js
   App({
       data: 123,
       other: 'hello'
   }),
   console.log(getApp()) //	{global: {}, data: 456, other: 'hello'}
   ```

2.关于 App 的生命周期

​	当从独立分包启动小程序时, 主包中 App 的 `onLaunch` 和 首次 `onShow` 会从独立分包页面首次进入主包或其它分包页面时调用. 由于独立分包中无法定义 app, 小程序生命周期函数的监听可以使用 `wx.onAppShow`, `wx.onAppHide` 完成. App 上的其他事件可以使用 `wx.onError` `wx.onPageNotFound` 监听

在兼容模式下, 主包中的 app.wxss 可能灰度独立分包中的页面产生影响, 一次你应该避免在独立分包中使用 app.wxss 中的样式

##### 分包预下载

开发者可以通过配置, 在进入小程序某个页面时, 由框架自动预下载可能需要的分包, 提升进入后续分包页面时的启动速度. 对于独立分包, 也可以预下载主包

分包预下载目前只支持通过配置方式使用, 暂不支持通过API完成

**配制方法**

预下载分包行为在进入某个页面时触发, 通过在 `app.json` 增加 `preloadRule` 配置来控制

```json
{
    "pages": ["pages/index"],
    "subpackages": [{
        "root": "sub1",
        "pages": ["index"]
    },{
        "root": "sub2",
        "pages": ["index"]
    },{
        "root": "sub3",
        "pages": ["index"],
      	"independent": true
    }],
    "preloadRule": {
        "pages/index": {
            "network": "all",
            "packages": [""]
        },
        "sub1/index": {
          "packages": ["hello", "sub3"]
        }
    }
}
```

`preloadRule` 中, `key` 是页面路径, `vcalue` 是进入此页面的预下载配置, 每个配置有以下几项

- packages: 进入页面后预下载分包的 `root` 或 `name`
- network: 指定网洛预下载 all/wifi

**限制**

同一个分包中的页面共享有共同的预下载带小限额 2M, 限额会在工具中打包时校验.

页面A 和 B 都在同一个分包中, A 中下载总代小为 0.5M的分包, B中最多只能预下载 1.5M 的分包

### 多线程 Worker

一些异步处理的惹怒, 可以放置于 Worker 中运行, 带运行结束后, 再把结果返回给小程序主线程. Worker 运行于一个单独的全局上下文与线程中, 不能直接调用主线程的方法

Worker 与主线程之间的数据传输, 双方使用 Worker.postMessage() 来发送数据, Worker.onMessage() 来接收数据, 传递的数据并不是直接共享的, 而是吧被复制的.

**使用线程**

1. 配置 Worker 信息

   在 `app.json` 中可配置 `Worker` 代码放置的目录, 目录下的代码将被打包成一个文件

   配置示例:

   ```json
   {
       "workers": "workers"
   }
   ```

2. 添加 Worker 代码文件

   根据步骤 1 中的配置, 在代码目录下新建以下两个入口文件

```
workers/request/index.js
workers/request/utils.js
workers/response/index.js
```

​	添加后, 目录结构如下:

```
├── app.js
├── app.json
├── project.config.json
└── workers
    ├── request
    │   ├── index.js
    │   └── utils.js
    └── response
        └── index.js
```

1. 编写 Worker 代码

   在 `workers/request/index.js` 编写 Worker 响应代码

   ```js
   const utils= require('./utils')
   //	在 Worker 线程中执行上下文会全局暴露一个 worker 对象, 直接调用 worker.onMessage/postMessage 即可
   worker.onMessage(function(res){
       console.log(res)
   })
   ```

2. 在主线程中初始化 Worker

   ```js
   const worker = wx.createWorker('workers/request/index.js')	//	文件制定 worker 的入口文件路径, 绝对路径
   ```

3. 主线程向 Worker 发送消息

   ```js
   worker.postMessage({
       msg: 'hello worker!'
   })
   ```

**注意事项**

- Worker 最大并发数量限制为 1 个, 创建下一个前请用 Worker.teerminate() 结束当前 Worker
- Worker 内代码只能 require 指定 Worker 路径内的文件, 无法引用其他路径
- Worker 内的入口文件由 wx.createWorker() 时指定, 开发者课动态指定 Worker 入口文件
- Worker 内不支持 wx 系列 API
- Workers 之间不支持发送消息

## 硬件能力

### 蓝牙

蓝牙适配器模块生效周期为调用 `wx.openBluetoothAdapter` 至调用 `wx.closeBluetoothAdapter` 或小程序被销毁位置.

在小程序蓝牙适配器模块期间, 开发者才能正常调用蓝牙相关小程序API, 并收到蓝牙模块相关的事件回调

注意

- 系统限制, Android 上获取到的 `deviceId` 为设备 MAC 地址, IOS 上则无设备uuid. 因此 `deviceId` 不能硬编码到代码中.

**低功耗能蓝牙 (BLE) 注意事项**

- ios 上对特征值的 `read`, `write`, `notify	` 操作, 由于系统需要获取特征值实例, 传入的 `serviceId` 与 `characteristicId` 必须由 `wx.getBLEDeviceServices` 与`wx.getBLEDeviceCharacteristic` 中获取到后才能使用. 建议双平台统一在建立连接后先执行 `wx.getBLEDeviceServices` 与 `wx.getBLEDeviceCharacteristics` 后再进行与蓝牙设备的数据交互

### NFC

暂只支持 HCE (基于主机的卡模拟) 模式, 即将安卓手机模拟成实体智能卡.

- 适用机型: 支持 NFC 功能, 且系统为5.0+
- 适用卡范围: 符合 ISO 14443-4 标准的 CPU 卡

### Wi-Fi

在小程序中支持搜索周边的 Wi-Fi, 同时可以针对指定 Wi-Fi, 传入密码发起连接.

该系列接口为系统原生能力

注意

- Wi-Fi 相关接口暂不可用 `wx.canIUse` 接口判断.
- Android 6+ 版本, 在没有打开定位开关的时候会导致设备不能正常获取周边 Wi-Fi 信息.

## 开放能力

### 用户信息

##### 小程序登录

小程序可以通过微信官方提供的登录能力方便地虎丘微信提供的用户身份标识, 快速建立小程序内的用户体系

**登录流程时序**

![1546352529492](C:\Users\Administrator\Documents\GitHub\notes\wx\1546352529492.png)

说明: 

1. 调用 `wx.login()` 获取 零时登录凭证 code, 并回传到开发者服务器
2. 调用 `code2Session` 接口. 换取 **用户唯一标识 OpenID ** 和 **会话密匙 session_key**.

之后开发者服务器可以根据用户标识来生成自定义登录态, 用于后续业务逻辑中前后端交互时识别用户身份

**注意**

1. 会话密钥 `session_key` 是对用户数据进行 `加密签名` 的密钥, 为了应用自身数据安全, 开发者 **不应该把会话密匙下发到小程序, 也不应该对外提供这个密钥** 
2. 临时登录凭证 code 只能使用一次

##### UnionID 机制说明

如果开发者拥有多个移动应用, 网站应用 和公众账号 (包括小程序), 可通过 UnionID 来区分用户的唯一性, 因为只要是同一个微信开放平台账号下的移动应用, 网站应用和公众账号, 用户的 UnionID 是唯一的. 换句话说, 同一用户, 对同一个微信开放平台下的不同应用, unionid 是相同的.

**UnionID 获取途径**

绑定了开发者账号的小程序, 可以通过以下途径获取 UnionID.

1. 调用接口 `wx.getUserInfo`. 从解密数据中获取 UnionID, 注意本接口需要用户授权, 开发者需要妥善处理用户拒绝授权后的情况.
2. 如果开发者账号下存在 **同主体的** 公众号, 并且该用户已经关注了公众号. 开发者可以直接通过 `wx.login` + `code2Session` 获取到该用户 UnionID, 无需用户再次授权.
3. 如果开发者账号下存在 **同主体的** 公众号或移动应用, 并且该用户已经授权登录过该公众号或移动应用. 开发者也可以直接通过 `wx.login` + `code2Session` 获取到该用户 UnionID, 无需用户再次授权.
4. 用户在小程序中支付完成后, 开发者可以直接通过 `getPaidUnionid` 接口获取该用户的 UnionID, 无需用户授权. 注意本接口仅在用户支付完成后 5分钟内有效
5. 小程序端调用 `云函数` 时, 如果开发者账号下存在 **同主体** 的公众号, 并且用户已经关注了公众号, 可以在云函数中通过 `cloud.getWXContext` 获取 UnionID.
6. 小程序段调用 `云函数` 时, 如果开发者账号下存在 **同主体** 的公众号或移动应用, 并且该用户已经授权登录过该公众号或移动应用. 也可以在云函数中通过 `cloud.getWXContext` 获取 UnionID.

**微信开放平台绑定小程序流程**

登录微信开放平台 ---- 管理中心 ----- 小程序 ----- 绑定小程序

![1546354417870](C:\Users\Administrator\Documents\GitHub\notes\wx\1546354417870.png)

##### 授权

部分接口需要用户授权同意后才能调用. 我们把这些接口按使用范围分成多个 `scope`, 用户选择对 `scope` 来进行授权, 当授权给一个 `scope` 之后, 其对应的所有接口都可以直接使用.

部分接口需要获得用户授权同意后才能调用. 此类接口调用时

- 如果用户未接受或拒绝过此权限, 会弹窗询问用户, 用户点击同意方可调用接口
- 如果用户已授权, 可以直接调用接口.
- 如果用户已拒绝授权, 则不会弹窗, 直接进入接口 fail 回调, 我们要兼容用户拒绝授权的场景

**获取用户授权设置**

开发者可以使用 `wx.getSetting` 获取用户当前授权状态

**打开设置界面**

用户可以在小程序设置界面([右上角] - [关于] - [右上角] - [设置] ) 中控制对该小程序的授权状态

开发者可以调用 `wx.openSetting` 打开设置界面, 引导用户开启授权.

**提前发起授权请求**

开发者可以使用 `wx.authorize` 在调用需授权 API 之前, 提前向用户发起授权请求

**Scope 列表**

| scope                  | 对应接口                                            | 描述         |
| ---------------------- | --------------------------------------------------- | ------------ |
| scope.userInfo         | wx.getUserInfo                                      | 用户信息     |
| scope.userLocation     | wx.getLocation, wx.chooseLocation                   | 地理位置     |
| scope.address          | wx.chooseAddress                                    | 通讯地址     |
| scope.invoiceTitle     | wx.chooseInvoiceTitle                               | 发票抬头     |
| scope.invoice          | wx.chooseInvoice                                    | 获取发票     |
| scope.werun            | wx.getWeRunData                                     | 微信运动步数 |
| scope.record           | wx.startRecord                                      | 录音功能     |
| scope.writePhotosAlbum | wx.saveImageToPhotosAlbum,wx.saveVideoToPhotosAlbum | 保存到相册   |
| scope.camera           | <camera /> 组件                                     | 摄像头       |

**注意事项**

1. `wx.authorize({scope: "scope.userInfo})` 不会弹出授权窗口, 我们需要使用 `<button open-type="getUserInfo">` 
2. 需要收取 `scope.userLocation` 时必须配置地理位置用途说明

##### 开放数据校验与解密

小程序可以通过各种前端接口获取微信提供的开放数据. 考虑到开发者服务器也需要获取这些开放数据, 微信会对这些数据做签名和加密出米.

开发者后台拿到的开放数据后可以对数据进行校验签名和解密, 来保证数据不被篡改.

![1546355965102](C:\Users\Administrator\Documents\GitHub\notes\wx\1546355965102.png)

签名校验以及数据加解密涉及用户的会话密匙 `session_key` , 开发者应该事先通过 `wx.login` 登录流程获取会话密钥 `session_key` 并保存在服务器. 为了数据不被篡改, 开发者不应该把 `session_key` 传到小程序客户单等服务器外的环境.

**数据签名校验**

为了确保开放接口返回用户数据的安全性, 微信会对明文数据进行签名. 开发者可以根据业务需求对数据包进行签名校验, 确保数据的完整性.

1. 通过调用接口 (如 `wx.getUserInfo`) 获取数据时. 接口会同时返回 `rawData` `signature`, 其中 `signature=sha1(rawData + session_key)` 
2. 开发者将 `sinature`, `rawData` 发送到开发者服务器进行校验. 服务器利用用户对应的 `session_key` 使用相同算法计算出签名 `signature2`, 比对 `signature` 和 `signature2` 即可校验数据的完整性

如 `wx.getUserInfo` 的数据校验

接口返回的 rawData

```json
{
  "nickName": "Band",
  "gender": 1,
  "language": "zh_CN",
  "city": "Guangzhou",
  "province": "Guangdong",
  "country": "CN",
  "avatarUrl": "http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"
}
```

用户的 session-key

```
HyVFkGl5F5OQWJZZaNzBBg==
```

用于签名的字符串为

```
{"nickName":"Band","gender":1,"language":"zh_CN","city":"Guangzhou","province":"Guangdong","country":"CN","avatarUrl":"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"}HyVFkGl5F5OQWJZZaNzBBg==
```

使用 sha1 得到的结果为

```
75e81ceda165f4ffa64f4068af58c64b8f54b88c

```

**加密数据解密算法**

接口如果涉及敏感数据 (如 `wx.getUserInfo` 当中的 openId 和unionId), 接口的明文内容将不包括这些敏感数据. 开发者如需要获取敏感数据, 需要对接口返回的 **加密数据(encryptedData)** 进行对称解密. 解密算法如下

1. 对称解密使用算法为 `AES-128-CBA`, 数据采用 `PKCS#7` 填充
2. 对称解密的目标密文为 `Base64_Decode(encryptedData)`
3. 对称解密秘钥 `aeskey = Base64_Decode(session_key)`, aeskey 是 16字节.
4. 底层解密算法初始向量为 `Base64_Decode(iv)` 其中 iv 由数据接口返回

微信官方提供了多种编程语言的示例代码, 每种语言类型的接口名字均一致, 调用方式可以参照示例

另外,为了应用能校验数据有效性, 会在敏感数据加上数据水印(watermark)

watermark参数说明

- appid 敏感数据归属 appId, 开发者可校验此参数与自身 appId 是否一致
- timestamp 敏感数据获取的时间戳, 开发者可以用于数据时效性校验

如接口 `wx.getUserInfo` 敏感数据当中的 `watermark`

```json
{
    "openId": "OPENID",
    "nickName": "NICKNAME",
    "gender": GENDER,
    "city": "CITY",
    "province": "PROVINCE",
    "country": "COUNTRY",
    "avatarUrl": "AVATARURL",
    "unionId": "UNIONID",
    "watermark": {
        "appid": "APPID",
        "timestamp": TIMESTAMP
    }
}
```

注: 解密后得到的 json 数据根据需求可能会增加新字段, 旧字段不会改变和删减, 开发者需要预留足够空间

**会话密钥 session_key 有效性**

开发者如果遇到因为 sesion_key 不正确而校验签名失败或解密失败, 请关注 下面几个与 session_key 有关的注意事项

1. `wx.login` 调用时, 用户 `session_key` 可能会被更新而致使旧 `session_key` 失效(刷新机制存在最短周期, 如果同一个用户短时间内多次调用 `wx.login` 并非每次调用都导致 session_key 刷新) 开发者应该在明确需要重新登录时才调用 `wx.login` , 即使通过 `code2Session` 接口更新服务器存储的 `session_key`
2. 微信不会把 `session_key` 的有效期告知开发者, 我们会根据用户使用小程序的行为对 `session_key` 进行续期, 用户越频繁使用小程序, `session_key` 有效期越长
3. 开发者在 `session_key` 失效时, 可以通过重新执行登录流程获取有效 `session_key`, 使用借口 `wx.checkSession` 可以校验 `session_key` 是否有效, 以此避免小程序反复执行登录流程
4. 当开发者在实现自定义登录态时, 可以考虑以 `session_key` 有效期作为自身登录态有效期, 也可以实现自定义时效性策略.

##### 获取手机号码

获取微信用户绑定的手机号, 首先调用 `wx.login` 接口

因为需要用户主动触发才能发起获取手机号接口, 所以该功能不能有 API 来调用, 需要 <button> 组件点击来触发

注意: 目前该接口针对非个人开发者, 且完成了 认证的小程序开放, 若该用户举报较多或被发现在不必要场景下使用, 微信有权永久回收小程序的该接口权限

**使用方法**

需要将 <button> 组件 `open-type` 的值设置为 `getPhoneNumber`, 当用户点击并同意之后,可已通过 `bindgetphonenumber` 事件回调获取到微信服务器返回的加密数据, 然后在嗲三分服务端结合 `session_key` 以及 `app_id` 进行解密获取手机号.

**注意**

在回调中调用 `wx.login` 登录, 可能会刷新登录状态, 此时服务器使用 `code` 换取的 `sessionKey` 不是加密时使用的 `sessionKey`, 导致解密失败, 建议开发者提前进行 `login` 或在回调汇总先使用 `checkSession` 进行登录态检查, 避免 `login` 刷新登录态

示例代码

```html
<button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"></button>
```

```js
Page({
    getPhoneNumber({detail}) {
        console.log(detail.errMsg)
        console.log(detail.iv)
        console.log(detail.encryptedData)
    }
})
```

返回参数说明

- encryptedData 包括敏感数据在内的完整用户信息的加密数据
- iv 加密算法的初始量

`encryptedData` 解密后为以下 JSON 结构

```json
{
    "phoneNumber": "13580006666",
    "purePhoneNumber": "13580006666",
    "countryCode": "86",
    "watermark": {
        "appid": "APPID",
        "timestamp": TIMESTAMP
    }
}
//	参数说明
//	phoneNumber 用户绑定的手机号
//	purePhoneNumber 没有区号的手机号
//	countryCode	区号
```

##### 生物认证

小程序通过 `SOTER` 提供以下生物认证

目前暂时只支持指纹识别认证, 设备支持的生物认证方式可使用 `wx.checkIsSupportSoterAuthentication` 查询

**流程步骤说明**

1. 调用 `wx.startSoterAuthentication` 获取 `resultJSON` 和 `resultJSONSignature`
2. (可选) 签名校验. 此处 `resultJSONSignature` 使用 `SHA256widthRSA/PSS` 作为签名算法进行验签
3. 维修提供后台接口用于可信的密钥签服务, 微信将保证该接口返回的验签结果的正确性和可靠性, 并且对于 Android root 情况下该接口具有上述特性(将返回是否保证root情况安全性)

接口地址

```
POST htto://api.weixin.qq.com/cgi-bin/soter/verify_signature?access_token = %access_token

```

post 数据内容(JSON 编码)

```json
{
    "openid": "$openid",
    "json_string": "$resultJSON",
    "json_signature": "$resultJSONSignature"
}
```

### 转发

**获取更多转发信息**

通常开发者希望转发出去的小程序被二次打开的时候能够获取到一些信息, 例如群的标识. 现在通过调用 `wx.shoShareMenu` 并且设置 `withShareTicket` 为true, 当用户将小程序转发到任意群聊之后, 此转发卡片在群聊中被其他用户打开时, 可以再 `App.onLaunch` 或 `App.onShow ` 获取到一个 `shareTicket` 通过调用 `wx.getShareInfo` 接口传入此 `shareTicket`  可以获取到转发信息

**页面内发起转发**

通过给 button 组件设置属性 `open-type="share"` 可以在用户点击按钮后触发 `Page.onShareAppMessage` 事件 , 如果当前页面没有定义该事件, 点击无效

**使用指引**

转发按钮 , 旨在帮助用户更流畅地与好友分享内容和服务. 转发, 应是用户自发的行为, 且在需要时触手可及. 开发者在使用时若遵从以下指引, 会得到更佳的用户体验

1. 含义清晰: 明确, 一目了然的图形按钮, 将为用户减少理解的时间, 在我们的资源下载中心, 可以找到这样的按钮素材并直接使用. 或者可以根据自己业务的设计风格, 灵活设计含义清晰的按钮样式. 当然, 也尅一直接使用带文案的按钮, 如"转发给好友"

- 方便点击: 按钮点击热区不宜过小, 不宜过大. 同时转发按钮与其他按钮一样, 热区不宜过密, 以免用户误操作
- 按需出现: 并非所有页面都适合放置转发按钮, 涉及用户隐私的非公开内容, 或可能打断用户完成当前操作体验的场景, 该功能不推荐使用, 同时, 由于转发过程中, 我们将截取用户屏幕图形作为配图, 因此, 需要注意帮助用户屏蔽个人信息
- 尊重意愿: 理所当然, 并非所有的用户都喜欢与朋友分享你的小程序, 因此, 他不应该成为一个诱导或强制行为, 如转发后才能解锁某项功能等. 这类做法不仅不被推荐, 还肯呢个违反我们 `<<运营规范>>` 

##### 动态消息

2.4.0+ 支持转发动态消息. 动态消息对比普通消息具备以下特点

1. 消息发出去之后, 开发案这颗已通过后台接口修改部分消息内容
2. 消息有对应提醒按钮, 用户点击提醒按钮可以订阅提醒, 开发者可以通过后台修改消息状态并推送一次提醒消息给订阅了提醒的用户

**消息属性**

动态消息, 文字内容, 文字颜色

**状态**

消息有两个状态, 分别有其对应的文字内容和颜色. 其中状态 0 可以转移到状态 0 和 1, 状态1无法再转移

- 0  "成员正在加入, 当前{member_count}/{room_limit}人"
- 1  "已开始" 

**状态参数**

每个状态转移的时候可以下带参数

- member_count 状态0时有效, 文字内容模板中的 member_count 的值
- room_limit 状态0时有效, 文字内容模板中的 room_limit 的值
- path 状态1时有效, 点击 [进入] 启动小程序时使用的路径. 可以用于传递查询字符串(query), 如` "?foo=bar"`
- version_type 状态1时有效, 点击进入启动小程序时使用的版本. 有效参数值为: `develop(开发版)` `trial(体验版)` `release(正式版)`

**使用方法**

1. 差UN关键爱你 activity_id

   每条动态消息都可以理解为一个活动, 活动发起前需要通过 `createActivityId` 接口创建 `activity_id`. 后续转发动态消息以及更新动态消息都需要传入这个 `activity_id`

   活动的默认有效值是  24h, 活动结束后 消息内容会变成统一的样式

   - 文字内容: "已结束"
   - 文字颜色: #00ff00

2. 在转发之前声明消息类型为动态消息

   通过调用 `wx.updateShareMenu` 接口, 传入 `isUpdatableMessage: true` 以及 `templateInfo`, `activityId` 参数. 其中 `activityId` 从步骤一中获得

   ```js
   wx.updateShareMenu({
       withShareTicket: true,
       isUpadatableMessage: true,
       activityId: '',	//	活动 ID
       templateInfo: [{
           name: "member_count",
           value: "1"
       },{
           name: "room_limit",
           value: '3'
       }]
   })
   ```

3.修改动态消息内容

动态消息发出去之后, 可以通过 `setUpdatableMsg` 修改消息内容

对于不支持动态消息的客户端版本, 收到动态消息后会展示成普通消息

### 打开 App

此功能需要用户主动触发才能打卡 APP, 所以不由 API 调用, 需要使用 `open-type="launchApp"` 的 <button> 组件的点击来触发

当小程序从 APP 分享消息卡片的场景打开 (场景 1036, APP分享小程序) 或从 APP 打开的场景打开时(场景1069), 小程序会获得 打开 APP 的能力, 此时用户点击阿牛可以打开分享该小程序卡片/ 拉起概小程序的 APP, 即**小程序不能打开任意 APP , 只能跳回 APP**.

在一个小程序的生命周期内, 只有再特定条件下, 财局有打开 `APP` 的能力.

当小程序从 1069 场景打开时, 可以打开 APP

当小程序从非1069场景打开时, 会在小程序框架内部管理一个状态, 为true 则可以打开 APP, 为false则不可以打开 APP, 这个状态的维护遵循以下骨子额

- 当小程序从 App 分享消息卡片(1036) 打开时
- 当小程序从以下场景打开时, 保持上一次打开小程序时打开 APP 的能力的状态
  - 从其它小程序返回小程序(1038) 
  - 小程序从聊天顶部场景 (1089) 中 [最近使用] 内打开
  - 长按小程序右上角菜单换出最近使用历史 (1090) 打开
- 当小程序从非以上场景打开时, 不具备打开 APP 的能力, 改状态置为 false

![1546428964744](C:\Users\mengbao\AppData\Roaming\Typora\typora-user-images\1546428964744.png)

**使用方法**

小程序端

需要将 <button> 组件 `open-type` 值设置为 `launchApp` 如果需要在打开 APP 时向 APP 传递参数, 可以设置 `app-parameter` 为要传递的参数, 通过 `binderror` 可以监听打开 APP 的错误事件

app 端

APP 需要接入 OpenSDK

Android 第三方 app 需要处理 `showMessageFromWX.req` 的微信回调, ios则需要将 appId 添加到第三方 app 工程所需 plist 文件 URLtypes 字段, `app-parameter` 的获取方法, 参考 [Android SDKSample](https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/WeChatSDK_sample_Android.zip) 中 WXEntryActivity 中的 onResp 方法以及 [iOS SDKSample](https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/WeChatSDK_sample_iOS_1.4.2.1.zip) 中 WXApiDelegate 中的 onResp 方法。

代码示例

```html
<button open-type="launchApp" app-parameter="wechat" binderror="launchAppError">打开 APP</button>
```

error 事件参数说说明 

- invalid scene 调用场景不正确, 即此时的小程序不具备打开 APP 的能力

### 消息

##### 模板消息

基于微信的通知渠道, 我们为开发者提供了可以高效触达用户的模板消息能力, 以便实现服务的闭环并提供更佳的体验.

- 模板推送位置: 服务通知
- 模板下发条件: 用户本人在微信体系内与页面由交互行为后触发
- 模板跳转能力: 点击查看详情仅能跳转下发模板的该账号的各个页面

**使用说明**

步骤一: 获取模板 ID

有两个方法可以获取模板 ID:

1. 通过模板消息管理接口获取模板 ID
2. 在微信公众平台手动配置获取模板 ID

登录 https://mp.weixin.qq.com 获取模板，如果没有合适的模板，可以申请添加新模板，审核通过后可使用

![1546429657372](C:\Users\mengbao\AppData\Roaming\Typora\typora-user-images\1546429657372.png)

步骤二: 页面的 <form /> 组件, 属性 `report-submit` 为 true 时, 可以声明为需要发送信息的模板消息, 此时点击按钮提交表单可以获取 `formId`, 用于发送模板消息. 或者当用户完成 支付行为, 可以获取 `prepay_id` 用于发送模板消息

步骤三: 调用接口下发消模板消息

使用效果

![1546429775060](C:\Users\mengbao\AppData\Roaming\Typora\typora-user-images\1546429775060.png)

**下发条件说明**

1. 支付

   当用户在小程序内完成支付行为, 可允许开发者向用户在 7 天内推送有限条数的模板消息(1次支付可下发3条, 多次支付下发条数独立, 互不影响)

2. 提交表单

   用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的, 开发者需要向用户提供服务时, 课允许开发者向用户在 7 天内推送有限条数的模板消息(1次提交表单可下发1条, 多次提交下发条数独立, 互不影响)

**审核说明**

1. 标题
   1. 标题不能存在相同
   2. 标题意思不能存在过度相似
   3. 标题必须以 "提醒" 或 "通知" 结尾
   4. 标题不能懈怠特殊符号等
   5. 标题必须体现服务场景
   6. 标题不能涉及营销相关内容
2. 关键词
   1. 同一个标题下, 关键词不能存在相同
   2. 同一标题下, 关键词不能过度相似
   3. 关键词不能懈怠特殊符号等
   4. 关键词内容示例必须与关键词对应匹配
   5. 关键词不能太过宽泛, 需要具有限制性

消费优惠间类, 购物返利类, 商品更新类, 优惠券类, 代金券类,...活动类等营销倾向通知

##### 统一服务消息

为便于开发者对用户进行服务消息触达, 简化小程序和公众号模板消息下发了流程, 小程序提供统一服务消息下发接口

##### 客服消息

**在页面使用客服消息**

需要将 <button> 组件 `open-type` 的值设置为 `contact`, 当用户点击后就会进入客服会话, 如果用户在会话中点击了小程序消息, 则返回到小程序, 开发者可以通过 `bindcontact` 事件回调获取用户所点消息的页面路径 `path` 和对应参数 `query` 

代码示例

```html
<button open-type="contact" bindcontact="handleContact"></button>
```

```js
Page({
    handleContact(e) {
        console.log(e.path)
        console.log(e.query)
    }
})
```

- path 小程序消息指定的路径
- query 小程序消息指定的查询参数

**后台接入消息服务**

接入微信小程序消息服务, 开发者需要按照如下步骤完成

1. 填写服务器配置
2. 验证服务器地址的有效性
3. 据接口文档实现业务逻辑

第一步: 填写服务器配置

登录小程序官网后, 在小程序逛网的 "设置- 消息服务器" 页面, 管理员扫码启用消息服务, 填写服务器地址 (URL). Token 和 EncodingAESKey

- URL 是开发者用来接收微信消息和事件的借口 URL.
- Token 可由开发者任意填写, 用作生成签名 (该 Token 会和接口 URL 中包含的 Token 进行对比, 从而验证安全性).
- EncodingAESKey 由开发者手动填写或随机生成, 将用作消息体和加密密钥

同时, 开发者可选择消息解密方式: 明文模式, 兼容模式和安全模式. 可以选择消息数据格式: XML 格式 或 JSON 格式. 加密方式的默认状态是明文格式, 而数据格式的默认状态是 XML 格式.

模式的选择与服务器配置在提交后都会立即生效, 请开发者谨慎填写及选择. 切换加密方式和数据格式需要提前配置好相关代码, 详情参考 消息加解密说明

![1546442158505](C:\Users\mengbao\AppData\Roaming\Typora\typora-user-images\1546442158505.png)

第二步: 验证消息却来自微信服务器

开发者提交信息后, 微信服务器将发送 GET 请求到填写服务器地址URL上, GET请求携带参数如下表所示

| 参数      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| signature | 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。 |
| timestamp | 时间戳                                                       |
| nonce     | 随机数                                                       |
| echostr   | 随机字符串                                                   |

开发者通过检验 `signature` 对请求进行校验, 若确定此次GET请求来自微信服务器, 请原样返回 `echostr` 参数内容, 则接入生效, 成为开发者成功, 否则将接入失败, 加密/校验流程如下

1. 将 token, timestamp, nonce 三个参数进行字典序排序
2. 将三个参数字符串拼成一个字符串进行 sha1 加密
3. 开发者获得加密后的字符串与 signature 对比, 标识该请求来源于微信

检验 `signature` 的PHP代码示例

```php
private function checkSignature()
{
    $signature = $_GET["signature"];
    $timestamp = $_GET["timestamp"];
    $nonce = $_GET['nonce'];
    
    $token = TOKEN;	//	TOKEN 常量, token
    $tmpArr = array($token, $timestamp, $nonce);
    sort($tmpArr, SORT_STRING);
    $tmpStr = implode($tmpArr);
    $tmpStr = sha1($tmpStr);
    
    if($tmpStr === $signature){
        return true;
    }else{
        return false;
    }
}
```

第三步: 依据接口文档实现业务逻辑

验证 URL 有效性成功后即接入生效, 成为开发者. 至此用户向小程序客服发送消息, 或者进入会话等情况时, 开发者填写的服务器配置URL 将得到微信服务器推送过来的消息和事件, 开发者可以依据自身业务逻辑进行响应.

另外注意: 开发者所填写的URL 必须以 `http://` 或 `https://`开头, 分别支持端口 80和 443

###### 接收消息和事件

在页面中使用 `<button open-type="contact" />` 可以显示进入客服会话按钮

当用户在客服会话发送消息(或进行某些特定的用户操作引发的事件推送时), 微信服务器会将消息(事件) 的数据包(JSON/XML) 格式 POST请求道开发者服务器, 开发者收到请求后可以使用 `发送客服消息` 接口进行异步回复.

微信服务器在将用户的消息发给小程序开发者服务器地址后, 微信服务器在五秒内收不到响应会断掉连接, 并且重新发起请求, 总共重试三次, 如果在调用中, 发现用户无法接收到响应的消息, 可以检查是否消息处理超时, 关于重试的消息拍重, 有 msgid 的消息推荐使用 msgid 排重. 事件类型消息推荐使用 FromUserName + CreateTime 排重.

服务器收到ingIQU币徐作出下述回复, 这样微信服务器才不会对此作任何处理, 并且不会发起重试, 否则将出现严重的错误提示, 详见下面说明

```
1. 直接回复 success (推荐)
2. 直接回复空串(指字符长度为0的空字符串, 而不是结构体中content字段的内容为空)

```

一旦遇到以下情况,微信都会在小程序会话中, 向用户下发系统提示 "该小程序客服暂时无法提供服务, 请稍后再试"

```
1.开发者在5秒内未回复任何内容
2.开发者恢复了异常数据

```

如果开发者希望增强安全性, 可以在开发者中心处开启消息加密, 这样用户发给小程序的消息以及小程序被动回复的消息都会继续加密

各类消息类型的推送 `JSON`  `XML`数据包结构如下

**文本消息**

用户在客服会话中发送文本消息时将产生如下数据包:

XML 格式

```xml
<xml>
   <ToUserName><![CDATA[toUser]]></ToUserName>
   <FromUserName><![CDATA[fromUser]]></FromUserName>
   <CreateTime>1482048670</CreateTime>
   <MsgType><![CDATA[text]]></MsgType>
   <Content><![CDATA[this is a test]]></Content>
   <MsgId>1234567890123456</MsgId>
</xml>
```

JSON 格式

```json
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "text",
  "Content": "this is a test",
  "MsgId": 1234567890123456
}
```

参数说明

| 参数         | 说明                |
| ------------ | ------------------- |
| ToUserName   | 小程序的原始ID      |
| FromUserName | 发送者的openid      |
| CreateTime   | 消息创建时间(整型） |
| MsgType      | 类型 text           |
| Content      | 文本消息内容        |
| MsgId        | 消息id，64位整型    |

**图片消息**

XML 格式

```xml
<xml>
      <ToUserName><![CDATA[toUser]]></ToUserName>
      <FromUserName><![CDATA[fromUser]]></FromUserName>
      <CreateTime>1482048670</CreateTime>
      <MsgType><![CDATA[image]]></MsgType>
      <PicUrl><![CDATA[this is a url]]></PicUrl>
      <MediaId><![CDATA[media_id]]></MediaId>
      <MsgId>1234567890123456</MsgId>
</xml>
```

JSON 格式

```json
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "image",
  "PicUrl": "this is a url",
  "MediaId": "media_id",
  "MsgId": 1234567890123456
}
```

| MsgType | image                                                        |
| ------- | ------------------------------------------------------------ |
| PicUrl  | 图片链接（由系统生成）                                       |
| MediaId | 图片消息媒体id，可以调用[获取临时素材]((getTempMedia)接口拉取数据。 |

**小程序卡片消息**

用户在客服会话中发送小程序卡片消息

XML 格式

```xml
<xml>
	<ToUserName><![CDATA[toUser]]></ToUserName>
	<FromUserName><![CDATA[fromUser]]></FromUserName>
	<CreateTime>1482048670</CreateTime>
	<MsgType><![CDATA[miniprogrampage]]></MsgType>
	<MsgId>1234567890123456</MsgId>
	<Title><![CDATA[Title]]></Title>
	<AppId><![CDATA[AppId]]></AppId>
	<PagePath><![CDATA[PagePath]]></PagePath>
	<ThumbUrl><![CDATA[ThumbUrl]]></ThumbUrl>
	<ThumbMediaId><![CDATA[ThumbMediaId]]></ThumbMediaId>
</xml>
```

JSON 格式

```json
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "miniprogrampage",
  "MsgId": 1234567890123456,
  "Title": "title",
  "AppId": "appid",
  "PagePath": "path",
  "ThumbUrl": "",
  "ThumbMediaId": ""
}
```

| PagePath     | 小程序页面路径        |
| ------------ | --------------------- |
| Title        | 标题                  |
| ThumbUrl     | 封面图片的临时cdn链接 |
| ThumbMediaId | 封面图片的临时素材id  |

**进入会话事件**

XML 格式

```xml
<xml>
    <ToUserName><![CDATA[toUser]]></ToUserName>  
    <FromUserName><![CDATA[fromUser]]></FromUserName>  
    <CreateTime>1482048670</CreateTime>  
    <MsgType><![CDATA[event]]></MsgType>  
    <Event><![CDATA[user_enter_tempsession]]></Event>  
    <SessionFrom><![CDATA[sessionFrom]]></SessionFrom> 
</xml>
```

JSON 格式

```json
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "event",
  "Event": "user_enter_tempsession",
  "SessionFrom": "sessionFrom"
}
```

| Event       | 事件类型，user_enter_tempsession                             |
| ----------- | ------------------------------------------------------------ |
| SessionFrom | 开发者在[客服会话按钮](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)设置的 session-from 属性 |

###### 发送客服信息

当用户和小程序客服产生特定动作的交互时, 微信将会把消息数据推送给开发者, 开发者可以在一段时间内(48小时)调用客服接口, 通过调用 `发送客服消息接口` 来发送消息给普通用户, 此接口主要用于客服等有人工消息处理环节的功能, 方便开发者为用户提供更佳优质的服务

目前允许的动作列表如下, 不同动作触发后, 允许的客服接口下发消息条数和下发时限不同

| 用户动作     | 允许下发条数限制 | 下发时限 |
| ------------ | ---------------- | -------- |
| 用户发送消息 | 5 条             | 48 小时  |

###### 转发客服消息

如果小程序设置了消息推送, 普通微信用户向小程序客服发消息时, 微信服务器会先讲消息 POST 到开发者服务器填写的 URL 上, 如果希望将消息转发到网页版客服工具, 则需要开发者在响应包中返回 MsgType 为 transfer_customer_service 的消息, 微信服务器收到响应后会把当次法搜的消息转发至客服系统

用户被客服接入以后, 客服关闭会话以前, 处于会话过程中时, 用户发送的消息均会被直接转发至客服系统. 当会话超时30分钟客服没有关闭时. 微信服务器会自动停止转发至客服, 而将消息回复发送到开发者服务器上

用户在等待队列中时, 用户发送的消息仍会被推送至开发者服务器上

这里特别注意, 只针对微信用户发来的消息才进行转发, 对于其它事件(比如用户从小程序唤起客服会话) 都不应该转发, 否则客服在客服系统上就会看到一些无意义的消息了

**消息转发到网页版客服工具**

开发者只在响应包中返回 MsgType 为 transfer_customer_service 的消息, 微信服务器接收到响应后就会把当次发送的消息转发至客服系统

```xml
<xml>
    <ToUserName><![CDATA[touser]]></ToUserName>
    <FromUserName><![CDATA[fromuser]]></FromUserName>
    <CreateTime>1399197672</CreateTime>
    <MsgType><![CDATA[transfer_customer_service]]></MsgType>
</xml>
```

| 参数         | 是否必须 | 描述                       |
| ------------ | -------- | -------------------------- |
| ToUserName   | 是       | 接收方帐号（收到的OpenID） |
| FromUserName | 是       | 开发者微信号               |
| CreateTime   | 是       | 消息创建时间 （整型）      |
| MsgType      | 是       | transfer_customer_service  |

###### 客服输入状态

开发者可以通过调用客服输入状态接口, 返回客服当前输入状态给用户

1. 此接口需要客服消息接口权限
2. 如果不满足发送客服消息的触发条件, 则无法下发输入状态
3. 下发输入状态, 需要客服之前30s内和用户有过消息交互
4. 再输入态中(15s), 不可重复下发输入态
5. 再输入状态中, 如果向用户下发消息, 会同时取消输入状态

###### 在客服消息中使用临时素材

开发者可在接受和发送客服消息的过程中获取或上传临时素材.

**获取临时素材**

接收到用户消息后, 课通过`获取临时素材接口` 获取消息中的临时素材

**上传临时素材**

通过 `上传临时素材接口` 可以上传临时素材, 并在`发送消息接口` 中使用.

### 卡卷

说明

小程序卡卷接口在小程序中领取/查看/使用公众号 AppId 创建会员卡, 票, 劵.

**使用条件**

目前只有认证的小程序才能使用卡卷接口

**接口**

小程序内可以通过 `wx.addCard` 接口给用户添加卡卷, 通过 `wx.openCard` 让用户选择已有卡卷

### 获取二维码

通过后台接口可以获取小程序任意页面二维码, 扫描而为卡可直接进入小程序对应页面, 所有生成的二维码永久有效, 可以放心使用

为满足不同需求和场景, 这里提供了三个接口, 开发者可以挑选适合接口

- 接口 A: 适用于需要的码数量较少的业务场景
  - 生成小程序码，可接受 path 参数较长，生成个数受限。
- 接口 B：适用于需要的码数量极多的业务场景
  - 生成小程序码，可接受页面参数较短，生成个数不受限。
- 接口 C：适用于需要的码数量较少的业务场景
  - 生成二维码，可接受 path 参数较长，生成个数受限。

**注意事项**

1. 接口只能生成已发布的小程序的二维码
2. 接口 A 加上接口 C，总共生成的码数量限制为 100,000，请谨慎调用。
3. 接口 B 调用分钟频率受限(5000次/分钟)，如需大量小程序码，建议预生成。

### 可用性

##### 性能

###### setData

setData 是小程序开发中使用最频繁的接口, 也是最容易引发性能问题的接口

**工作原理**

小程序的视图目前使用 `WebView` 作为渲染载体, 而逻辑层时由独立的 `JavaScriptCore` 作为运行环境, 在架构上, `WebView` 和 `JavaScriptCore` 都是独立的模块, 并不具备数据直接共享通道. 当前, 视图层和逻辑层的数据传输, 实际上通过两边提供的 `evaluateJavaScript` 所实现. 即用户传输数据, 需要将其转换为字符串形式传递, 同时把转换后的数据内容拼成一份 JS 脚本, 在通过 执行 JS 脚本的形式传递到两边独立环境 而`evaluateJavaScript` 的执行会受到很多方面的影响, 数据达到视图层并不是实时的

**常见的 setData操作错误**

1. 频繁地调用 setDta

   在我们分析过的一些案例中, 部分小程序会频繁地去 setData, 导致两个后果

   - Android 下用户在滑动时会感觉到卡顿, 操作反馈延迟严重, 因为JS线程里一致在编译执行渲染, 未能及时将用户操作事件传递到逻辑层, 逻辑层亦无法及时将操作处理结果及时传递到视图层
   - 渲染有出现延时, 由于 `WebView` 的 JS 线程一直处于忙碌状态, 逻辑层到页面层的通信耗时上升, 视图层收到的数据消耗时上升, 视图层收到的数据消息距离发出时间已经过去了几百毫秒, 渲染的结果并不实时

2. 每次 setData 都传递大量的新数据

   由于 setData 的底层实现克制, 我们的数据传输实际是一次 `evaluateJavaScript` 脚本过程, 当数据量过大时会早呢更加脚本编译执行时间, 占用 `WebView` JS线程

3. 后台态页面进行 setData

   当页面进入后台态, 不应该继续进行 setData, 后台态页面的渲染用户是无法感受的, 另外后台态页面去 setData 会强占前台的执行

###### 图片资源

**图片对内存的影响**

IOS上, 小程序的页面是由多个 WKWebView 组成的, 在系统内存紧张时, 会回收掉一部分 WKWebView, 大图片和长列表图片会硬气 WKWebView 回收.

**图片对页面切换的影响**

除了内存问题外, 大图片也会造成页面切换卡顿, 我们分析过的案例中, 有一部分小程序会在页面中引用大图片, 在页面后退切换中出现掉帧卡顿的情况.

当前我们建议开发者减少使用大图资源

###### 代码包大小的优化

小程序一开始时代码包限制为 1MB , 现在增加到了 2MB, 代码包上限的增加对于开发者来说, 能够实现更丰富的功能, 对于用户来说, 增加了下载流量和本地空间的占用

开发者而在实现业务逻辑同时也有必要尽量减少代码包的大小, 因为代码包大小直接影响到下载速度, 从而影响用户首次打开体验, 除了代码自身的重构优化外, 还可以从页面着手优化代码大小

**控制代码包内图片资源**

小程序代码包经过编译后, 会放在维修的 CDN 上供用户下载, CDN 开启了 GZIP 压缩, 所以用户下载的是压缩后的 GZIP 包, 其大小比代码包原体积会更小. 我们分析数据发现, 不同的小程序之间的代码包压缩比差距也挺大. 部分可以达到 30%, 部分只有 80%, 造成这部分差异的一个原因, 就是图片资源的使用. GZIP 对基础文本资源压缩效果最好, 在压缩较大文件时往往可高达 70%-80%的压缩率, 而如果对已经压缩的资源(入大多数的图片格式)则效果很小

**及时清理没有使用到的代码和资源**

在日常开发的时候, 我们可以引入一些新的库文件, 而过一段时间后, 由于各种原因又不再使用这个库了, 我们常常会去掉了代码里的引用, 而忘记删除这类库文件, 目前小程序打包是会将工程下所有文件都打入代码包内, 也就是说, 这些没有被实际使用到的库文件和资源也会被打入到代码包里, 从而影响到整体代码包的大小

##### 分析工具

###### 性能 Trace 工具

提供了 Trace 导出工具, 开发者可以在开发者工具 Trace Panel 中使用该功能

###### 性能面板

提供了性能面板让开发者了解小程序的性能, 开发者可以在开发版小程序下打开性能面板, 打开方法: 进入开发者小程序, 点击更多按钮, 点击 [显示性能窗口]

### 基础库

#### 兼容

小程序的功能不断的增加, 但是旧版本的微信客户端并不支持新功能, 所以在使用新功能的时候要做兼容

开发者可以通过以下方式进行低版本的兼容

1. 版本号比较

   维修客户端和小程序基础库的版本号风格为 Major.Minor.Pathch(主版本号, 次版本号,修订版本号)

   文档中会在组件,  API 等页面描述中带上各个功能所要求的最低基础库版本号.

   开发者可以在小程序中调用 `getSystemInfo ` 或 `wx.getSystemInfoSync` 获取到当前小程序运行的基础库的版本号, 通过版本号比较的方式进行运行低版本的兼容逻辑

2. API 存在的判断

   对于新增 API, 可以通过判断 API 是否存在来判断支持用户使用的基础库版本

   ```js
   if(wx.openBluetoothAdapter){
       wx.openBluetoothAdapter()
   }else{
       //	如果希望用户在最最新版本的客户端上体验您的小程序, 可以这样题还是
       wx.showModel({
           title: '提示',
           content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'
       })
   }
   ```

3. wx.canIUse

   除了直接通过版本号判断, 也可以通过 `canIUse` 来看是否可以在该基础版本上直接使用. 

   API 参数或返回值

   ```js
   wx.canIUse('showModle.cancel')
   ```

   组件

   对于组件, 新增的组件或熟悉在旧版本上不会被处理, 不过也不会报错, 如果特殊场景需要对旧版本做一些降级处理. 可以如此

   ```js
   Page({
       data: {
           canIUse: wx.canIUse('cover-view')
       }
   })
   ```

   ```html
   <video controls="{{!canIUse}}">
   	<cover-view wx:if="{{canIUse}}">play</cover-view>    
   </viode>
   ```

   设置最低基础库版本

   为便于开发者而结局低版本基础库无法兼容小程序的新功能的问题, 开发者可设置小程序最低版本基础库版本要求

   开发者可以登录小程序管理后台, 进入 [设置-基础设置-基础库最低版本设置] 进行配置. 配置前, 开发者可以查看近30天内访问当前小程序的用户所使用的基础库版本占比, 以帮助开发者了解当前用户使用的情况

   ​
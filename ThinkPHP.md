# ThinkPHP

##　开始

### 介绍

**什么是框架**	

- 一堆代码的集合
- 半成品应用
- 优秀的**设计模式**

> **定义: ** 框架是一堆**包含了常量, 方法和类代码的集合**, 它是一个半成品应用, 只包含了一些项目开发的时候所使用的底层架构, 并**不包含业务逻辑**, 框架还**包含了一些优秀设计模式**, 如单例模式, 工厂模式, AR模式等等

**为什么使用框架**

在实际开发中, 会有一个成型的开发流程

![1540703334516](.\php\1540703334516.png)

如果不使用框架进行开发, 会遇到哪些问题? 

- 代码风格不一样, 维护困难, 可能造成项目生命周期短
- 一处小的修改, 会牵扯出很多地方的修改
- 在后期满足客户需求方面(功能扩展) 存在局限性

**使用框架的好处**

- 使用框架会帮助我们**简单, 快捷, 高效**地开发项目
- **有更多的时间去关注业务逻辑的开发**, 不需要过度关注底层的架构.
- 便于处理多人协助开发中遇到的问题.

**常见框架介绍**

- YII 

  是重量级框架, 是美国华人开发的框架, 作者是 薛强, 中文称之为"易框架", 最大的特点就是将代码的重用性发挥到了极致

- Larvel 轻量级框架

- **ThinkPHP**

  一款国人开发的框架, 目前有中文的社区, 官网, 文档. 在国内使用普遍

####　MVC

**什么是mvc**

mvc 是一个设计模式. 它强制将用户的输入, 逻辑, 输出向分离. 将整个项目分为三个部分: **Controller, Model, View**

**编程阶段**

在整个编程开发历史中, 一共经历了三个阶段

第一个阶段: **混合编程阶段**

​	就是 "混编" : 将php代码和html代码写在一个文件中

​	优点: 效率高 

​	缺点: 不易于维护

第二个阶段: **模板引擎阶段**

​	典型如 **smarty**

​	优点: 将前端的输出 和 后端逻辑代码相分离

​	缺点: 效率比第一阶段低

第三个阶段: **mvc 设计阶段**

​	优点: 强制将用户的输入, 逻辑, 输出 相分离, 维护上简单性提高了很多 

​        缺点: 效率最低



### ThinkPHP 介绍

> **简述: **

 	ThinkPHP 框架最早诞生于06年初. 最初名是 FSC., 07年更名 ThinkPHP, 同时官网上线, ThinkPHP 是一款国人自主开发的框架, 有中文文档, 论坛, 代码中包含丰富中文注释.

>  **下载**

[官方网址](http://www.thinkphp.cn/)

>  **文件目录介绍**

![1540889432164](.\php\1540889432164.png)

Application 

#### ThinkPHP目录介绍

![1540889725214](.\php\1540889725214.png)

- Common/functions.php 系统函数库
- Config/
  - **convention.php**	系统配置文件
    - 在ThinkPHP中除了该配置文件外, 还有其他的配置文件, convention.php 是**系统级别的配置文件**, 还有一个是**应用级别的配置文件**, 最后还有一个**分组级别的配置文件**
    - 从作用范围说: 系统 > 应用 > 分组
    - 从优先级上说: 分组 > 应用 > 系统
  - debug.php

- Lang/
  - en-us 英文
  - pt-br 
  - zh-cn 简体中文
  - zh-tw 繁体中文

- Tpl
  - dispath_jump.tpl	   跳转模板
  - page_trace.tpl          跟踪信息模板
  - think_exception.tpl 异常模板

- **Library/**
  - Behavior   行为文件目录
  - Org            功能扩展目录
  - **Think         最核心的目录**
    - MVC 的父类
      - Controller.class.php
      - Model.class.php
      - View.class.php
    - 功能类
      - Image.class.php图片处理类
      - Page.class.php  数据分页类
      - Verify.class.php 验证码类
    - 底层类
      - DB.class.php
  - Vendor       第三方的目录

#### 项目部署(重点)

**第一步: 创建站点目录**

![1540890643793](.\php\1540890643793.png)

**第二步: 配置Apache虚拟主机目录**

![1540892333681](.\php\1540892333681.png)

**第三步: 重启Apache**

**第四步: 修改hosts文件, 将配置文件中声明的域名作绑定(解析)**

运行中, 输入drivers, 打开drivers文件, 选择 etc 中的hosts文件作修改

![1540891861056](.\php\1540891861056.png)

通过cmd ping命令测试是否解析成功

![1540891843491](.\php\1540891843491.png)

**第五步: TP压缩包目录中复制 Think目录文件 和 index.php 到站点目录中**

![1540892443411](.\php\1540892443411.png)

##### Application 的目录文件介绍

**在首次允许 index.php 入口文件的时候会产生对应的目录结构(Application).**

![1540892733632](.\php\1540892733632.png)

![1540892883158](.\php\1540892883158.png)

#### 细节问题

1. **自动生成**

   在首次允许 index.php 入口文件的时候回产生相应的目录结构, **目录的名字取决于**在 index.php 定义的**常量 APP_PATH**

2. **目录安全文件**

   在自动生成的文件夹中, 都有一个空白的 index.html文件, 我们称之为目录安全文件. 

​	在Apache配置文件中有 options+indexes, 默认展示站点目录, 如果在站点目录中不存在 index 开头的文件, 则会展示目录结构, 有了 index.html(目录安全文件) 之后就不会展示结构了.

**index.html 作用就是防止列出站点文件的结构**

3. **文件生成**

   当我们首次运行入口文件的时候, 系统给我生成了一些目录, 这些目录文件是如何生成的呢?

   文件夹/文件的生成主要取决于 ThinkPHP 的流程(架构中->[系统流程](https://www.kancloud.cn/manual/thinkphp/1704))

4. 默认访问

   在部署之后访问会看到一个笑脸, 如何输出?

   **默认分组/平台: Home**

   **默认控制器: Index**

   **默认方法: index**

   上述默认值, 可以在系统配置文件中找到.

   ![1540895900589](.\php\1540895900589.png)



### TP中的控制器

#### 控制器的创建

命名规则:  **控制器名 + Controller(关键词) + .class.php**

​	例如: 创建商品控制器: **GoodsController.class.php** ; 用户控制器: **UserController.class.php**

​	案例: 在 Home 分组中创建一个用户控制器

​	![1540896359352](.\php\1540896359352.png)

控制器结构代码:

​	第一步: **声明**当前类的控制器(类)的**命名空间**

​	第二步: **引入父类**控制器(类)

​	第三步: **声明控制器(类)并继承父类**

说明: 

​	第一: **命名空间是在 php5.3 版本中引入**的概念, 所以 ThinkPHP要求PHP版本大于等于 5.3

​	第二: 命名空间本身和目录没有关系, 在 ThinkPHP中命名空间的声明和使用, 必须和目录挂钩.

案例: 参考上述结构代码的完善三个步骤, 完善 UserController.class.php

![1540896879330](.\php\1540896879330.png)

访问我们的控制器 **m&c&a**

![1540897106337](.\php\1540897106337.png)



### 路由形式(重点)

>  **路由**: 是指访问项目中具体某个方法的 URL 地址.

在 ThinkPHP 中系统提供了 4 中路由形式

- 普通形式路由
- Pathinfo形式路由
- Rewrite形式路由

- 兼容形式路由

#### **普通形式路由(get形式)**

路由形式: **`http://网址/入口文件?m=分组名&c=控制器名&a=方法名&参数名=参数值&..`**

例如: 访问 Home 分组下的 User 控制器中的 index 方法. 并传递参数, id = 1

 http://www.studyTP.com/index.php?m=Home&c=User&a=index&id=1

 问题: URL传递的任何东西都会在 URL 地址栏中显示出来, 既不安全也不好看.

#### pathinfo 路由形式(TP默认√)

路由形式: **`http://网址/入口文件/分组名/控制器名/方法名/参数名1/参数值1/参数值2/....`**

例如: 访问 Home 分组下的 User 控制器中的 index 方法. 并传递参数, id = 100

http://www.studyTP.com/index.php/Home/User/index/id/100

#### rewrite 路由形式

路由形式: **`http://网址/分组名/控制器名/方法/参数名1/参数值1/参数名2/...`**

例如: 访问 Home 分组下的 User 控制器中的 index 方法. 并传递参数, id = 100

http://www.studyTP.com/Home/User/index/id/100

注意: 该路由形式不能直接使用, 需要配置完成才能使用.

配置步骤: 

 1. 修改 Apache 配置文件 httpd.conf

    ![1540898079640](.\php\1540898079640.png)

	2. 给需要修改虚拟主机配置文件, 给需要开启重写的站点目录配置处添加 allowoverride, 并赋值为 all

    ![1540898163115](.\php\1540898163115.png)

3. 重启 Apache

4. 将ThinkPHP压缩中的 .htaccess 文件复制到入口文件的同级目录

   ![1540898374344](.\php\1540898374344.png)

   注意: PHP 拥有好几个运行模式, 每个运行模式的使用 .htaccess 的方式可能不一样.

   ![1540898478093](.\php\1540898478093.png)

   这种路由形式需要 Apache 的支持, 除了 Apache 以外拂去其软件还有 nginx 等, 所以第三种路由形式一般情况不推荐使用

####  兼容路由形式

路由形式: **`http://网址/入口文件?s=/分组名/控制器名/方法名/参数名1/参数值1/参数值2/....`**

问题: 兼容路由形式有几个参数?

答:    上述路由形式只有 1 个参数, 参数名是 s, 等于号后面都是 s 参数的值

例如: 访问 Home 分组下的 User 控制器中的 index 方法. 并传递参数, id = 110

http://www.studyTP.com/index.php?s=/Home/User/index/id/100

#### 补充

**关于 ThinkPHP 中路由形式的配置**

路由形式在 ThinkPHP 系统配置文件中是有所体现的

![1540899178134](.\php\1540899178134.png)

**特别说明: ** **路由形式的配置值不影响我们在地址栏中的输入其它访问方式. 该配置项的值影响的是 ThinkPHP 系统封装的 URL 组装函数(U函数) 生成 url 地址的形式**



### 分组

> **分组**: 一般的项目都会根据某个功能的使用对象来区分代码. 这个时候放到一起之后会形成一个文件夹, 这个文件夹就可以称之为分组. 分组就是我们平时所指的平台 (前台, 后台)

例如: 在刚部署的 ThinkPHP 系统中 Home 就是一个分组目录, 后期如果需要使用更多的分组, 则需要自己去创建分组

如何创建新的分组呢?

步骤: 参考 Home 分组的目录结构, 重新创建一个新的目录, 在其中依照 Home 中的结构创建对应的目录即可

第一步: 创建 Admin 分组中的目录结构

![1540899828857](.\php\1540899828857.png)

分组创建好了之后, 可以在 Controller 控制器目录中创建一个测试控制器, 并执行其方法进行测试, 编写结构代码

![1540900093423](.\php\1540900093423.png)

[点击进行访问测试](http://www.studyTP.com/index.php?m=Admin&c=Test&a=test)

![1540900220585](.\php\1540900220585.png)

### 控制器中的跳转

#### URL组装(U函数)

> **url组装**: 根据某个规则, 组成一个 url 地址, 这个功能就叫做 url 组装. 在 ThinkPHP 中, 系统提供了一个封装的函数来处理 url 的组装, 这个方法就叫做 U 方法. U方法是系统提供的快速方法, 除了 U 方法这样大写字母的方法外, 还有一些其它的快速方法: 如 A, B, C, D, E, F, G, I, M, R, S

这些方法都定义在系统的函数库文件中(functions.php)

![1540900564089](.\php\1540900564089.png)

**U语法格式:** U('URL路径', 参数数组);

例如: 要使用 U方法组装出当前控制器下 index 方法的地址, 则可以写成: **`U('index')`**

![1540900867095](.\php\1540900867095.png)

再例如: 使用 U 函数, 组装出另一个控制器 Index 中的 index 方法的访问, 则可以写成 **U('Index/index')**

![1540901007371](.\php\1540901007371.png)

如果需要指定平台也是如此.

如果说需要指定参数, 又该如何?

例如: 给 Index 控制器下的index方法传递一个 id = 10086 , 则我们需要如下写法

```php
U('Index/index',array('id'=>10086,'type'=>'c'));
```

![1540901282979](.\php\1540901282979.png)

总结出了一个通用的格式:

​	**`U('[分组名/控制器名/]方法名', array('参数名'=>参数值, '参数名2'=>参数值2))`**

####　跳转方法

在 ThinkPHP 中系统有 2个 跳转方法, 分别是 成功跳转 和 失败跳转

**成功: ** **$this->success(跳转提示[, 跳转地址, 等待时间]);**

**失败: ** **$this->error(跳转提示[,跳转地址, 等待时间]);**

说明:  跳转提示参数必须要有, 地址和时间可以没有, 如果没有则指定跳转到上一页

演示1: 成功跳转 

![1540902046292](.\php\1540902046292.png)

演示2: 失败跳转

![1540902105902](.\php\1540902105902.png)

说明: **上述案例中使用 success 和 error 方法在当前控制器中并没有定义, 其是 父类控制器中 已经定义好的方法, 由于当前控制器继承了父类, 所以可以直接使用**

### TP中的视图

> **视图: ** 视图就是 MVC 三大组成中的 V(view), 主要负责信息的输出和展示

#### 视图的创建

**创建的位置, 需要在分组目录下的 View 目录下与控制器同名的目录中**, 例如 Test 控制器中的 login 方法, 需要有一个模板, 则该模板文件 login.html 需要放到 View/Test/login.html

例如: 创建 Test控制器的 login 和 register 方法 对应的 login视图 和 register视图

![1540903319252](.\php\1540903319252.png)

如果有多个模板文件, 按照以上要求创建即可

#### 视图的展示

在 smarty 中展示模板是用的方法是 display, 在ThinkPHP 中同样也是 display 方法. Display 在 ThinkPHP 中的语法格式:

- **$this->display();** 		                                                                              展示当前控制器下与当前请求方法名称一致的模板文件
- **$this->display('模板文件名(不带后缀)');**                                                展示当前控制器下的指定模板文件
- **$this->display('View 目录下的目录名/模板文件名(不带后缀)');**         展示指定控制器目录下的指定目标文件

案例1 : 

  	在 Test 控制器中的 login 方法中展示 login.html

![1540905438429](.\php\1540905438429.png)

​	在 Test 控制器中的 register方法中展示 register.html

![1540905546201](.\php\1540905546201.png)

案例2 :

​	在 Test 控制器中的 test 方法中展示 login.html

![1540905741351](.\php\1540905741351.png)

案例3: 

​	在 Test 控制器中的 test 方法中展示 View/Demo/test.html

![1540906219000](.\php\1540906219000.png)

#### 变量分配(初阶)

在实际开发中的时候, 不仅仅只是展示模板如此简单, 往往还需要展示数据, 这时变量还在控制器的方法中, 需要将数据传递给模板中并展示, 这个过程叫做变量分配

在ThinkPHP 中系统封装好了一个变量的分配的方法, 这个方法叫做 assign, 具体语法

​	**$this->assign('variables',\$variables)**

案例: 变量分配

![1540908026554](.\php\1540908026554.png)

目前已经将 variables 变量传递给了模板文件 login.html, 在模板文件中如何展示数据呢? ThinkPHP 中**默认**的展示基本变量方法如下: **{$模板中的变量名}**

![1540908229353](.\php\1540908229353.png)

#### 变量分隔符

在 ThinkPHP 中, 默认的左右分割符是 `{` 和 `}`, 他们是可以被更改的, 可以在系统配置文件(Conf/convention.php)中找到具体的配置项

![1540909337697](.\php\1540909337697.png)

#### 模板常量的替换机制

在实际开发中, 会出现这么一个问题, 在引入图片, css, js 文件的时候. 往往需要写一些复杂的路径.所以这个时候, 我们比较期望能有一些特殊的常量将复杂路径简单化, 此时可以考虑使用**模板常量替换机制**

在ThinkPHP中, 系统默认给我们提供了以下几个常用的**模板常量**

**\_\_MODULE\_\_** : 从域名后面开始, 一直到分组结束的路由

**\_\_CONTROLLER\_\_** : 从域名后面开始, 一直到控制器结束的路由

**\_\_ACTION\_\_** : 从域名后面开始, 一直到方法名结束的路由

**\_\_PUBLIC\_\_** : 站点根目录下的 Public 目录的路由

**\_\_SELF\_\_** : 从域名后面开始, 一直到路由的最后(如果没有参数, 则\_\_SELF\_\_ 和 \_\_ACTION\_\_ 表达意思是一致的)

![1540912153674](.\php\1540912153674.png)

为什么上述几个常量就可以表示上面输出的路由呢?

在 ThinkPHP 中 "模板常量" 是通过模板内容替换机制来实现的, 并非是常量的定义, 

替换机制可以查看行为文件. ContentReplace.Behaviour.class.php 

![1540910557987](.\php\1540910557987.png)

**其模板常量的实现核心就是字符串的替换**

为了后期使用方便, 我们可以在配置文件中定义一个自定义的模板常量

说明: 在开发的时候, **不到万不得已, 不要去修改系统配置文件**. 可以将需要修改的配置项在分组/应用级别的配置文件中定义

![1540910987188](.\php\1540910987188.png)

测试自定义常量的使用

![1540911348039](.\php\1540911348039.png)

#### 综合案例-实现OA系统的登录页面的展示

控制器: 		PublicController.class.php

发光法: 		login

模板文件: 	login.html

**第一步: 创建控制器, 并编写结构性代码**

**第二步: 控制器编写方法, 展示登录视图**

```PHP
<?php
//  定义命名空间
namespace Admin\Controller;
//  引入基础类
use Think\Controller;
//  创建public控制器并继承基础类
class PublicController extends Controller{
    //  登录视图的显示
    public function login(){
        $this->display();
    }
}
```

![1540913667399](.\php\1540913667399.png)

**第三步: 将模板视图复制到指定的位置**

![1540953407810](.\php\1540953407810.png)

**第四步: 相应的静态资源文件复制到指定位置**

![1540953380491](.\php\1540953380491.png)

**第五步: 修改模板视图中的静态资源路径**

![1540953356993](.\php\1540953356993.png)

**展示结果**

![1540953447908](.\php\1540953447908.png)



#### 模板内容的获取方法

在 ThinkPHP 中有一个方法和 display 方法有点相似. 这个方法是 **fetch** 方法

Display方法: `$this->display();` 展示模板

Fetch 方法:  `$this->fetch(); ` 获取模板(有返回值)

在 ThinkPHP 中, 系统封装好了一个**打印很友好**的方法, 该方法就是 dump() 方法: 

​	语法格式: **dump(需要打印的变量);** 封装在系统函数库文件 functions.php中

![1540953701716](.\php\1540953701716.png)

在底层事件上的差异: 

Display() 方法: `替换模板中的常量/变量 -> 获取模板内容 -> 输出模板内容`

Fetch()  方法: `替换模板中常量/变量 -> 获取目标内容`

**Display()方法的前两个步骤其实就是通过Fetch()方法拉实现的**

![1540954070949](.\php\1540954070949.png)

#### 视图中的注释

视图中的注释特指 ThinkPHP 中视图的注释.

回顾HTML中的注释写法: **\<!--注释内容-->**

![1540956712796](.\php\1540956712796.png)

在 ThinkPHP 中的模板注释

行注释: 语法格式:	 **{//行注释内容}**

块注释: 语法格式:	 **{/\*注释内容*/}**

测试效果如下: 

![1540957042356](.\php\1540957042356.png)

**经典题: **

ThinkPHP中的行注释和块注释与普通的 html 注释有什么区别?

答: 普通的 html 注释属于 **客户端注释**, 会在浏览器的源代码中输出; 而 ThinkPHP中模板注释则属于 **服务端注释**, 不会被客户端(浏览器)输出.

注意点: 

​	第一: 行注释不要当做块注释来写(横跨多行)

​	第二: 在行注释和块注释当中(大括号里面), 不要再出现大括号(模板变量), 会解析错误.

#### 变量分配(进阶)

- **简单变量输出(初阶)**

- **一维数组的输出**
- **二维数组的输出**
- **对象变量的输出**

##### 一维数组的输出

在 ThinkPHP 中的变量的分配 (不考虑变量类型), 都是使用 **assign ** 语法格式

​	**$this->assign('变量名', 变量值)**

![1540957691335](.\php\1540957691335.png)

在 php 中输出数组的具体元素可以通过下表的形式输出: $array[key]

关于数组在模板中输出的语法格式:

​	支持中括号形式: **{$array[key]}**

​	中也支持 . 形式: **{$array.key}**

![1540958027403](.\php\1540958027403.png)

##### 二维数组的输出

在方法中定义一个二维数组, 将其分配到模板中

![1540958256919](.\php\1540958256919.png)

在模板中我们要如何展示.

![1540958512633](.\php\1540958512633.png)

##### 对象变量的分配

对象在实例化之后, 一般会保存到一个实例化变量中去, 这个变量也可以被分配到模板中去.

创建一个对象

![1540958872360](.\php\1540958872360.png)

类的实例化

![1540958908541](.\php\1540958908541.png)

需要注意: **在命名空间的语法需求中, 如果不予命名空间(也不使用 include 和 require), 系统会默认先从当前空间下寻找需要的元素, 如果找不到, 则会报错**.

![1540961930201](.\php\1540961930201.png)

在 php 中如何去输出一个对象的属性呢? 可以通过 **$obj->attr/\$obj::attr** 这种形式输出对象的属性.

在 ThinkPHP 的模板中输出属性的值, 可以通过下面两种方式实现: 

​	支持箭头的形式: **{$obj->attr}**

​	支持冒号得形式: **{$obj:attr}**

![1540963309256](.\php\1540963309256.png)

切记: 在 ThinkPHP 模板中, 在输出对象属性的时候, 千万不要使用 . 形式, 因为 ThinkPHP不允许将对象作为数组使用

#### 系统变量

在 ThinkPHP 中系统提供了以下几个系统级别的变量(超全局变量再模板中的使用)

- **$Think.server**	等价于 $_SERVER, 获取服务器的相关信息

- **$Think.get**  		等价于 $_GET, 获取 get 请求的信息

- **$Think.post**   	等价于 $_POST, 获取 post 请求的信息

- **$Think.request**	等价于 $_REQUEST, 获取 get 和 post 中的信息

- **$Think.cookie**	等价于 $_COOKIE, 获取 cookie 中的信息

- **$Think.session**	等价于 $_SESSION, 获取 session 中的信息

- **$Think.config**	获取 ThinkPHP 中所有配置文件的一个总和, 如果后面指定了元素, 则获取指定配置.

上述 7 个系统变量的语法都是一样的, 哎模板中使用的语法格式是

​	**{$Think.xxx.具体的元素下标}**

例如: 获取需要 get 请求中的 id, 可以写成 {$Think.get.id}

案例: 在模板中输出部分系统变量 path 信息

![1540964975636](.\php\1540964975636.png)

其它系统变量的测试情况

![1540965466162](.\php\1540965466162.png)

#### 视图中使用函数(重点)

在实际开发的时候, 有些变量在模板中不能直接使用, 举例: 在数据表中存储的时间一般都是时间戳格式, 在显示视图的时候需要处理格式化, 需要遍历, 操作相对而言比较繁琐. 这个时候可以在视图中使用函数的方式来解决这个问题.

​	语法格式:

​		**{$变量|函数名1|函数名2=参数1,参数2...}**

​	参数说明:

​		`$变量` 	: 模板变量

​		`|` 	    	: 变量修饰器

​		`函数名1` : 表示需要使用的第一个函数

​		`函数2`	: 表示需要使用的第二个函数

​		`参数1` 	: 表示函数需要的参数

​		`=`		: 表示该函数有参数, 类似 php 中函数名后面的()

​		`###` 	: 表示变量自身

案例1(经典): 时间戳的格式化. (100%工作中使用)

![1540966647804](.\php\1540966647804.png)

分析: PHP中格式化时间戳使用的函数是 date, 语法格式是 date('Y-m-d H:i:s', 时间戳);

![1540966940120](.\php\1540966940120.png)

特别说明: 

​	第一: **`###` 什么时候该写, 什么时候不该写?	当需要使用的函数, 只有一个参数并且参数是变量自身的时候, `###` 可以省略不写; 当一个函数有多个参数, 但是第一个参数是变量自身的时候, 也可以省略不写 `###**`

​	第二: **函数名的说明, 函数名对应的函数必须是 php 内置的函数, 或者是在函数库文件中定义好的函数; 其他的主观臆造的函数不可以使用**

案例2: 定义一个字符串, 截取前 5 个字符并转换成大写

分析: 截取字符串使用函数 **substr**, 转换大写使用函数 **strtoupper**

![1540967661263](.\php\1540967661263.png)

####　默认值

使用场景: 比如在论坛用户个性签名处, 一般会看到一句提示 "这个家伙很懒, 什么都没有留下...", 这句话只有当用户个性签名未填写时显示.

默认值: 就是当某个**变量不存在或者为空**时, 就会显示默认的字符, 默认的字符就是变量的默认值.

语法格式: 

​	**{$变量名|default=默认值}**

集合视图中使用函数的语法格式, 可以得知 default 其实就是 ThinkPHP 封装的一个函数, 默认值是其参数

![1540968529071](.\php\1540968529071.png)

![1540968642152](.\php\1540968642152.png)

#### 运算符

在 ThinkPHP 中同样支持在模板中对变量进行运算, 运算的规与以往相同

`+`		{\$a+\$b}			变量相加

`-`		{\$a-\$b}			变量相减

`*`		{\$a*\$b}			变量相乘

`/`		{\$a/\$b}			变量相除

`%`		{\$a%\$b} 		变量取余

`++`		{\$a++} 或 {++$a}	变量自增

`--`		{\$a--}   或 {--$a}	变量自减

![1540969483587](.\php\1540969483587.png)

#### 文件包含

在实际开发的时候, 一般情况下, 会把网站的公共部分, 如头部, 尾部等可以单独存放到一个文件中, 在后期的使用, 可以直接引入到该部分, 在后期维护的时候只需要维护一份代码即可. 如果说公共部分不单独拿出来, 会造成两个问题: 一是代码重复, 再是后期维护的时候麻烦

在 ThinkPHP中, 系统提供了一个模板的标签, 可以让我们引入一些公共的代码文件, 这个标签是 **include** 标签

​	语法格式: 

​		**<include file='需要引入的模板文件'/>**

路径说明: **路径可以是相对路径, 是相对于入口文件的** 

案例: 使用 include 的标签, 来实现页面的首位引入效果

1. 创建三个模板文件(顶部, 主体, 尾部)

2. 控制器中创建显示视图的方法

   ![1540971291940](.\php\1540971291940.png)

3. 在主体中引入其它两个模块

   ![1540971452873](.\php\1540971452873.png)

说明: 在实际开发中, 上述路径很长容易写错, 往往我们会将其写成另外一种比较简单的方法

​	**<include file='View 目录名/模板文件名' />**

改写成如下结果: 

除了使用include 标签来引入文件之外, **include 标签还有另外一个用法: 用来传递参数给引入的模板文件**

​	**<include file='需要引入的模板文件' 参数名='参数值' />**

上述语法格式是给引入的文件传递参数. 用于个别文件显示不同参数所使用: **模板文件使用参数方式: [参数名]**, 如若参数名变量不存在, 则会原样输出

![1540971662473](.\php\1540971662473.png)

#### 遍历循环(重点)

在ThinkPHP中, 系统提供了两个标签来实现数组在模板中的遍历操作

- **volist**

  语法格式: 

  ```html
  <volist name='variables' id='value'>
  	<!--循环体-->
  </volist>
  ```

- **foreach**

  语法格式: 

  ```html
  <foreach name="variables" item="value">
      <!--循环体-->
  </foreach>
  ```

从上述的语法格式发现 volist 标签和 foreach 标签的语法结构上大体是相同的. 但是他们有所区别:

区别在于: **volist 除了上述的 name 和 id 属性之外, 还支持更多的属性对, 比如 mod, key, length, offset,等,  而 foreach 标签除了支持 name 和 item 以外只支持 key , 可以理解为 foreach 是 volist 的简化版本**

后期在使用的时候, 可以根据实际情况选择性地使用 volist 标签 和 foreach 标签

##### 一维数组的遍历

![1540972676483](.\php\1540972676483.png)

##### 二维数组的遍历

![1540973890019](.\php\1540973890019.png)

![1540974012781](.\php\1540974012781.png)

#### 流程控制 if 

在 php 中 if 语句的作用, if是用于流程控制的.

在 ThinkPHP中 if 标签作用也是如此.

​	语法格式: 

```html
<if condition='条件表达式'>
输出结果1
<elseif condition='条件表达式2' />
输出结果2
<elseif condition='条件表达式3' />
....
<else />
最后结果
</if>
```

案例: 在php输出今天的星期数字, 然后传递给模板, 在模板中使用 if 标签判断今天是周几

编写输出数据

![1540975783731](.\php\1540975783731.png)

模板中使用if流程控制, 显示数据

![1540975738346](.\php\1540975738346.png)

#### 内置比较标签

![1542031201913](.\php\1542031201913.png)

#### php 标签

 php 标签就是指在模板中使用 php 语法格式. 模板中的 php 标签 ThinkPHP 支持  2 中形式:

​	第一种:	PHP内置的php标签; 语法格式: **<?php PHP代码段 ?>**

​	第二种:   ThinkPHP封装的php标签: 语法格式: **<php>PHP代码段</php>**

分别使用两种php标签

![1540976219589](.\php\1540976219589.png)

在实际开发的时候, 一般不建议在模板中使用 php 标签. 在配置项中有一个配置项可以禁用 php 标签, 该配置项叫做 **TMPL_DENY_PHP**

![1540976377562](.\php\1540976377562.png)

禁用PHP标签之后, 只是禁用掉原生PHP代码, 并不会禁用 ThinkPHP 标签, 我们不建议禁用, 系统跳转方法的模板文件使用了原生的PHP标签代码

![1540976621207](.\php\1540976621207.png)



###	 TP中的模型

#### 配置数据库的连接

数据库的链接设置项可以在系统中主配置文件查看 convention.php

![1540976931777](.\php\1540976931777.png)

在实际开发中, 我们一般会在应用层级的配置文件中进行数据库的相关配置

![1540977462413](.\php\1540977462413.png)

#### 创建数据库/数据表

```mysql
create database db_tp;
use db_tp;
create table if not exists sp_dept(
	id int not null auto_increment primary key,
    name varchar(50) not null,
    pid int not null default 0,
    sort int not null default 50,
    remark varchar(255)
)engine=myisam default charset=utf8;
```

![1540978024609](.\php\1540978024609.png)

#### 什么是模型

> **定义**: 模型是MVC三大组成部分的 M(model). 作用是负责与数据表的数据的交互 (CURD)

![1540980493051](.\php\1540980493051.png)

####　模型的创建

命名规范:  **模型名(要求是不带前缀的表名并且首字母大写) + Model关键字 + .class.php**

代码结构规范: 

​	第一步: 声明命名空间

​	第二步: 引入父类模型 Model.class.php

​	第三步: 创建模型并继承父类

案例: 创建一个部门模型文件

命名: DeptModel.class.php

![1540981062428](.\php\1540981062428.png)

空模型能否进行数据的基本操作?

答: 能, 因为继承了基础模型类. 基础模型类中已经完成了基本的 CURD 的函数的封装

#### 模型的实例化操作 (重点)

模型虽然已经被创建了, 但是由于模型的本质是一个类, 类在使用的时候需要进行实例化操作.

##### 普通实例化

普通实例化方法是指, 通过自己编写代码来 new 一个对象.

​	**$obj->new 类名();**

在控制器中定义一个方法来实例化模型, 使用普通方式实例化

![1540981695704](.\php\1540981695704.png)

通过 打印结果, 我们发现模型在实例化的时候关联了数据库 sp_dept

上述的普通的实例化方法虽然可以进行实例化操作, 但是使用上比较麻烦, 还需要考虑命名空间, 所以 ThinkPHP 为了简单, 快速, 高效开发, 为我们提供了2个快速方法, 可以对模型进行实例化操作

##### 快速的实例化方法

​	**M** 方法和 **D** 方法

**D方法实例化**

​	**D(['模型名']);**

表达的含义: 实例化我们自己创建的模型(分组/Model的目录中); **如果传递了模型名, 则实例化指定的模型, 如果没有指定模型名 或 不存在, 则直接实例化父类模型. 也就是(Model.class.php)**

**M方法实例化**

​	**M(['不带前缀的表名'])**

表达的含义: 直接实例化父类模型(Think目录下的Model.class.php); **如果指定了表名,则实例化父类模的时候关联指定的表; 如果没有指定表名(没有传递参数) 则不关联表, 一般用于执行原生的 sql 语句(M()->query(原生sql语句))**

案例: 使用快速方法 D 和 M方法对模型进行实例化操作

**D方法实例化自定义模型或父类模型**

![1540983212846](.\php\1540983212846.png)

![1540983271962](.\php\1540983271962.png)

**M方法实例化父类模型**

![1540983373807](.\php\1540983373807.png)

![1540983410608](.\php\1540983410608.png)

经典面试题: 

问: 实例化方法中 D 方法和 M方法有什么区别

答: **D方法是实例化自定义模型, 如果自定义模型不存在则实例化父类模型. M方法本身就是实例化父类模型. 两者差异就是实例化对象不一.**

在后期开发的时候, 如何选择使用 D方法 还是 M 方法呢?

可以根据自身情况, **如果需要使用的操作, 父类中已经存在, 则可以直接使用 M 方法直接实例化父类模型. 如果说父类中的方法不能满足我们的开发需求, 需要自己定义方法, 这个时候可以使用 D 方法实例化自定义模型类**

#### CURD 操作

CURD 操作也是模型操作数据表的基本操作. C(create), U(update), R(read), D(delete) 就是增删改查操作.

##### 增加操作

回想一下, 在mysql中增加操作使用的语法格式是: insert into 语句.

在 ThinkPHP中系统给我们封装好了模型中的放, 可以通过方法来实现数据库的增加操作.

这个方法叫做 **add** 方法

​	**$model->add(一维数组);**

**一维数组要求必须是键值(关联)数组, 键必须和数据表中的字段名要匹配, 如果不匹配则在增加的时候会被 ThinkPHP过滤掉.**

**Add 方法的返回值是新增记录的主键id值**

案例: 往部门表中使用 add 方法添加一条记录.

![1540984985566](.\php\1540984985566.png)

![1540985133054](.\php\1540985133054.png)

补充: 如果需要添加多个记录, 我们要如何实现呢?

方法1: 循环使用 add 方法;

方法2: 可以使用另外一个方法 addAll()  语法: **$model->addAll(二维数组);**

​	**要求: 最里面那层数组也必须是关联数组(键名和数据表字段匹配), 外层数组必须是下标从0开始的连续索引数组.**

![1540985630481](.\php\1540985630481.png)

如果使用批量添加时返回值是第一个添加到数据库中的数据的主键id值

**addAll 方法需要注意的点有很多, 需要谨慎使用.**

#####　修改操作

在 mysql 中修改操作使用的是: **update table 语句**.

在 ThinkPHP 中使用的是 **save** 方法, 语法格式:

​	**$model->save(一维关联数组);**

**条件需要一维关联数组必须要有主键信息. 如果没有主键信息, 返回值是 false, 表示修改失败**

返回 false 表示修改操作没有执行, 而不是mysql执行失败.

案例: 使用 save 方法实现部门表中财务部门的信息的修改.

![1540986458352](.\php\1540986458352.png)

函数执行成功, 表示受到影响的行数.

##### 查询操作

Mysql 中查询操作使用的语法是: **select 语句**.

在 ThinkPHP 中系统封装了方法 可以直接用于查询: **select** 方法和 **find** 方法

Select 方法语法:

​	**$model->select()**		表示查询全部的信息

​	**$model->select(id)**		表示查询指定id信息

​	**$model->select('id1,id2,id3,id4,...')**	表示查询指定id集合的信息 等价于 mysql中的 in 语句

Find 语法:

​	**$model->find()**			表示查询当前表中的第一条记录(相当于 limit 1)

​	**$model->find(id)**		表示查询表中的指定 id 的记录

返回值:	 

​	**Select 方法返回的值是一个二维数组**, 就是查询的是一条记录, 返回也是二维数组

​	**Find 方法返回值是一维数组.**

案例: 使用 select 和 find 方法查询部门表的数据

![1540987035965](.\php\1540987035965.png)

![1540987090238](.\php\1540987090238.png)

![1540987134848](.\php\1540987134848.png)

![1540987174594](.\php\1540987174594.png)

![1540987208426](.\php\1540987208426.png)

##### 删除操作

在MySQL中删除使用的是 **delete from语句**.

在 ThinkPHP中可以使用系统封装的 **delete** 方法:

​	**$model->delete();**	不能使用, 删除方法必须要有条件, 不能执行没有条件的删除操作

​	**$model->delete(id);**		删除指定 id 对应的数据

​	**$model->delete('id1,id2,id3,...')**		删除多个id对应的记录

关于删除的说明:

​	删除分为两种删除: **物理删除, 逻辑删除**

​		物理删除:	 真删除.

​		逻辑删除:	是指假删除, 本质是修改操作. 在数据表中定义一个状态字段, 比如 status, 取值是0 或者1, 在查询的时候, 读取状态是1的, 当用户点击删除之后触发修改操作, 将状态从1修改成 0. 下步读取操作因为查询只查询状态为1的, 用户就读不到数据了.

案例: 使用 **delete** 方法执行删除操作

![1540987857325](.\php\1540987857325.png)

![1540987885756](.\php\1540987885756.png)

删除操作返回受影响行数



### TP中的实用项(调试)

在开发的时候我们往往会需要一些开发的错误, 需要去解决错误, 一般这个时候我们比较需要借助开发工具/调试工具, 比如说浏览器自带的 "审核元素", 在 ThinkPHP 中系统为了方便我们在开发的时候对代码进行调试, 也封装了一些列的调试方法

- 跟踪信息
- 两种模式
- Sql 调试
- 性能调试

#### 跟踪信息

> **定义**: 跟踪信息就是查询/展示系统的执行的相关状况

在 ThinkPHP 中跟踪信息默认是关闭的. 如果需要使用, 则需要开启. 可以通过配置项: **SHOW_PAGE_TRACE**.

上述的配置项, 在主配置文件中是不存在的(在ThinkPHP中除了主配置文件中已经列出的配置项外, 还存在一些比较零星的配置项, 这些配置项在主配置文件中不存在, 但是其他地方有使用). **需要使用的话, 可以自己在配置文件中定义.** 

![1541038010374](.\php\1541038010374.png)

在开启跟踪信息之后, 在页面右下角会出现一个小图标, 左侧是TPlogo, 右边显示请求秒数

![1541038031400](.\php\1541038031400.png)

点击图标会出现类似控制台的数据供我们查看

![1541038190463](.\php\1541038190463.png)

在 **当前模式** 下

基本信息中的数据:

![1541038485205](.\php\1541038485205.png)

在文件选项卡中可以找到系统还加载系统函数库文件 functions.php 和 三大类配置文件:

![1541038712018](.\php\1541038712018.png)

在开发阶段, 我们就可以**使用跟踪信息查看一些具体的信息**.

#### 两种模式

在 ThinkPHP 中, 系统为了方便开发, 提供了以下两种模式: 开发(调试)模式, 生产模式.

**调试模式**: 指在开发调试阶段所使用的模式, 错误信息比较详细.

**生产模式:** 指项目上线的时候所使用的模式, 错误信息比较模糊.  

在 ThinkPHP 中两种模式其**默认是生产模式**, 其配置项名字叫做 **APP_DEBUG**. 定义的位置在入口文件中:

**当 app_debug 为 false 的时候表示开启生产模式, true 表示开启调试模式.**

![1541039174804](.\php\1541039174804.png)

**错误提示的区别体现** 

调试模式下报错

![1541039276531](.\php\1541039276531.png)

生产模式下报错

![1541039354727](.\php\1541039354727.png)

**跟踪信息的区别体现**

生产模式下:

![1541039442190](.\php\1541039442190.png)

在文件加载上存在的差异: 生产模式下系统函数库文件 functions.php, 系统配置文件, 应用的配置文件 没有被加载, 但是多了 common~runtime.php 文件(没有加载的配置项和函数库文件, 都被编写到了 common~runtime.php 文件中)

![1541039711911](.\php\1541039711911.png)

**相比调试模式, 生产模式下使用了缓存文件 common~runtime.php, 所以效率上比调试文件高**

问: 如果在生产模式下修改主配置文件/应用级别配置文件/系统函数库文件, 是否会生效呢?

答: 不会生效, 因为生产模式下上述的几个配置文件不会被加载, 所以修改无效, 如果想要其生效, **可以把缓存文件(common~runtime.php) 删除掉, 下次访问从新生成. 或者开启调试模式, 去修改, 修改完成切换回生产模式.**

针对跟踪信息和两种模式的说明:

**因为跟踪信息和两种模式中地调试模式都会输出系统执行的相关信息, 所以在项目上线的时候应该关掉跟踪信息, 开启生产模式.**

#### Sql 调试

在开发的时候, 难免会遇到 sql 的错误, 这个时候我们需要对 sql 进行调试, 因为 ThinkPHP 在执行查询或者其他的CURD操作的时候, 是让开发者写方法, 并不是很直观的 sql:

​	**$model->getLastSql();**

表达的含义: **获取当前模型中最后一条执行成功的 sql 语句.**

案例: 使用 getLastSql 方法去获取最后一个 SQL 语句

![1541040423365](.\php\1541040423365.png)

打印结果: 跟踪信息中的其中一条与我们打印的一般无二, 另外一条是模型实例化的时候执行的sql

补充说明: 

上述的 getLastSql 方法在写的时候不方便, 所以 ThinkPHP3.2版本之后, 系统增加了一个别名方法: _sql()

​	**$model->_sql();**

所以测试如下:

![1541040620553](.\php\1541040620553.png)

##### fetchSsql 方法

前面介绍了 sql 调试的方法 getLastSql 或者别名 __sql(). 但是这个方法要求最后一条成功执行的 sql, 如果拿这个方法来调试 sql , 只能是调试逻辑错误, 并不能拿来调试语法错误, 所以这里介绍新的 sql 调试方式: fetchSql() 方法

语法:

​	**$model->order()->whrer()...->fetchSql(true)->CURD操作;**

**fetchSql 使用的时候可以完全看成是一个辅助方法, 所以要求必须在 model 之后, CURD 操作之前, 顺序无所谓, fetchSql 方法只能在 thinkphp3.2.3以后使用.**

在控制器中测试

![1541056813182](C:/Users/mengbao/Desktop/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/php/1541056813182.png)

通过跟踪信息和返回值, 我们可以发现, **使用 fetchSql() 之后原有的连贯操作没有被执行(在跟踪信息中没有sql显示). 而是直接将连贯操作的语法组成的 sql 语句直接返回.

#### 性能调试(了解)

在以往写过如此小功能, 测试一段代码的执行时间. 在ThinkPHP 中, 系统提供了一个 **性能测试** 的快速方法. 这个快速方法叫做 **G** 方法.

语法: 

​	**G('开始标记');**

​	**需要统计效率的代码段**...

​	**G('结束标记');**

​	**G('开始标记', '结束标记', '数字/字符m');**

针对 G 方法的第三个参数, 如果参数是数字, 则表示统计代码的执行时间, 数字表示精确的小数位数, 单位是 秒, 如果是字符m, 则表示统计内存开销, 单位是 byt(需要服务器的支持).

案例: 使用 G 方法来统计某段代码执行开销

![1541041297467](.\php\1541041297467.png)



###　AR 模式(CURD)

#### 介绍

> AR 模式即 Active Record 模式, 是一个对象关系 **映射** (ORM) 技术, 每个 AR 类代表一张数据表(视图), 数据表的(视图) 的字段在AR类中体现为类的属性, 一个 AR 实例则表示表中的一行记录

AR 模式的核心:  三个映射/对应

**AR类 		==== 	表(模型类关联了数据表)**

**AR类的属性	====	表的字段**

**AR类的实例	====	表的记录**

![1541044737063](.\php\1541044737063.png)

AR 模式的语法格式:

AR 模式在 ThinkPHP 中的典型的应用: CURD 操作

``` 映射
//	实例化模型
$model =  M('关联表');
//	字段映射到属性
$model	->	属性/表中字段	=	字段值;
$model	->	属性/表中字段	=	字段值;
//	AR实例(操作)映射到表中的记录
$model	-> CURD操作;
```

#### AR模式的 CURD 操作

在 ThinkPHP 中除了之前的 curd 操作方法外. 还支持使用 AR 模式来完成

##### 增加操作

使用 ar 模式来对数据表进行数据增加操作

![1541045655282](.\php\1541045655282.png)

数据库中的结果

![1541045714567](.\php\1541045714567.png)

通过数据表中的记录可以得知, 其返回值和之前 add 的操作返回值是一样的, 都表示新增记录的主键 ID

通过上述代码, 可能会有两个疑问: 

​	**\*问题1: 难道父类模型中真的有 name, pid, sort, remark 属性吗?**

**答: 通过观察父类模型的底层实现, 我们找到一个特殊的魔术方法 __set, 参考手册得知**

![1541046092489](.\php\1541046092489.png)

然我们查看该魔术方法要执行的操作

![1541046266925](.\php\1541046266925.png)

再对不可访问的属性进行操作时, 触发魔术方法. 给 data属性赋值成功后, 我们打印下模型中存在的属性 data:

![1541046420522](.\php\1541046420522.png)

​	**\*问题2: 为什么 add 方法没有参数也能执行添加操作?**

**答: ** 通过问题1的解答, 我们可以得知如果使用 AR 模式的话, data 属性是有值的, 然后通过查看 add 发光法的底层实现:

![1541046638985](.\php\1541046638985.png)

其中判断是否给add 方法传递参数, 如果没有传递, 则使用父类模型中的 data 属性中的值, 而 data 的值恰恰就是问题1中的数据. 

所以没有给 add 方法传递参数的情况下, 也可以实现数据的添加操作.

#####　修改操作

案例: 使用 AR 模式实现针对部门记录的修改操作

需要注意: 不管是直接通过 save() 传递数组, 还是通过 AR 模式, 修改时候的主键 id 必须需要.

![1541047182080](.\php\1541047182080.png)

返回结果和之前 save 方法传递数组一样, 表示受影响的行数.

查看父类中的属性 data 是否是设置的数据

![1541047252504](.\php\1541047252504.png)

之所以 save 方法和 add 方法一样不传递参数, 是因为他也有和 add 方法中一样的判断参数为空情况下需要执行的另外操作.

![1541047295701](.\php\1541047295701.png)

##### 查询操作

在  ThinkPHP 中, AR模式没有查询操作. 这里的查询操作还是使用之前的 select 和 find 方法进行查询

#####　删除操作

需要注意: 删除操作的时候必须指定主键信息

案例: 使用 ar 模式对表中记录进行删除操作

![1541047706181](.\php\1541047706181.png)

返回结果是受影响行数

##### 补充说明

在 AR 模式中, **U(修改)** 和 **D(删除)** 操作必须指定**主键信息**, 但是有一种情况下可以不指定主键也能执行 U, D 操作: 

**在执行 U, D 之前有做过查询, 则后面再次执行查询未指定主键信息也可以对数据进行修改**. 简单地说就是 **在之前做过查询语句, 则后面如果没有指定主键, 就会操作当前查询到的记录.**

演示如下 : (修改和删除操作同理)

![1541048330690](.\php\1541048330690.png)

![1541048441640](.\php\1541048441640.png)

**为了正确执行操作, 我们还是在执行 U, D 操作的时候指定id. 我们需要如此谨慎 ^_^**



### TP中的辅助方法(重点)

在原始的 sql 语句中, 除了目前所使用的基本操作之外, 还有类似于 group, where, order, limit 等等子句. 在后期如果需要用到上述的子句方法, 以目前的知识储备肯定是不够的, 所以 ThinkPHP 封装了相应的子句方法.

- **where	表示限制查询的条件**
- **limit	表示限制输出的条数**
- **field	表示限制输出的字段, 也就是 select id, pid, name from xxx**
- **order	表示按照指定字段进行指定的排序**
- **group	表示按照指定字段进行分组查询**
- **join**         **表示连表查询条件**

#### where 方法

作用: 限制查询的条件.

在原生的 sql 语句中: **select 字段 from 表 where 条件;**

在 ThinkPHP中系统封装了一个 **where** 方法来实现在原生的 sql 语句中 where 效果.

语法: 

​	**$model->where(条件表达式);**  	//	在ThinkPHP中条件表达式支持字符串形式, 也支持数组形式.

​	**$model->CURD操作;**

案例: 使用 where 方法查询部门表中 id > 5 的数据.

使用原生的 sql : **select * from sp_dept where id>5;**

使用 ThinkPHP 提供的辅助方法 where 

![1541049884638](.\php\1541049884638.png)

跟踪信息中的 sql

![1541050030957](.\php\1541050030957.png)

回顾: 在 mysql 中除了 where 子句之外, 还有一个语法个是也能限制查询条件. 这个语法是 having 语法

问题: **where 子句和 having 子句有什么区别?**

答: 两个语句都表示限制查询条件, 但是意义上有差异, **where 要求条件中的字段必须是数据表中存在的字段; 而 having 要求条件中的字段必须是结果集中的字段.** 简单的说就是 **having 限制的条件字段必须出现在结果集中**.

![1541050480294](.\php\1541050480294.png)

![1541050510058](.\php\1541050510058.png)

#### limit 方法

作用: 显示输出的条数. (典型应用: 数据分页)

在原生的 sql 语句中: **select 字段 from 表 where 条件 limit 限制条数;**

在 ThinkPHP 中, 系统提供了 limit 方法来实现原生的 sql 语句中的限制条数的效果:

​	第一种: **$model->limit('n');**			//	n表示大于 0 的数字, 表示输出表中的前 n 行

​	第二种; **$model->limit('起始位置, 长度');**	//	表示从起始位置开始, 往后查询指定长度的条数, 在实际使用的时. 该方法还可以写成 **$model->limit('起始位置', '偏移量' );** 

案例: 使用 limit 方法, 限制查询条数

![1541051158388](.\php\1541051158388.png)

![1541051509067](.\php\1541051509067.png)

后期使用的分页效果, 起始就是使用 limit 的第二种语法格式.

#### field 方法

作用: 表示限制输出的结果集字段

语法:

​	**$model->field('字段1,字段2[as 别名],...');**	//	参数就是 select 之后到 from 之前的那一串字符串.

案例: 使用 field 方法查询部门表中的数据, 只显示id 和 name 

原生的sql: **select id,name form sp_dept;**

使用 ThinkPHP 查询

![1541051988672](.\php\1541051988672.png)

**说明: 上述三个辅助方法在父类模型中都是真实存在的.**

#### order 方法

作用: 指按照指定字段进行指定规则的排序

在原生 sql 语法中使用是: **order by 字段 排序规则(降序desc/升序asc)**.

语法格式:

​	**$model->order('字段名 排序规则');**	//	注意只有一个参数, 中间使用空格隔开

案例: 使用 order 方法, 查询部门表中的数据, 并且按照 id 进行降序排列

原生 sql: **select * from sp_dept order by id desc;**

使用 ThinkPHP 查询

![1541052781966](.\php\1541052781966.png)

显示的跟踪信息

![1541052832396](.\php\1541052832396.png)

#### group 方法

作用: 分组查询

在 ThinkPHP 中 group 分组可以使用 **group** 方法来实现

​	**$model->group('字段名');**

案例: 使用 group 方法去查询部门表要求查询出部门名称和出现的次数

原生的sql: **select name,count(*) as count from sp_dept group by name;**

**使用 group 和 field 辅助方法实现**上述的 sql

![1541053266078](.\php\1541053266078.png)

**说明: order 和 group 方法在父类模型中是不存在的, 所以走到了__call魔术方法(访问类不存在的方法, 则调用call魔术方法) 他们在使用的时候, 是通过 \_\_call 来实现后续的处理**

### 连贯操作(重点)

> **定义: ** 所谓连贯操作, 就是将辅助方法全部写在一行上的写法.

如下形式: 

​	**$model->where()->limit()->order()->field()->select();**

**注意点: 辅助方法的顺序, 在连贯操作中没有要求. 只要符合模型在最前面, CURD 方法在最后面即可.**

案例: 将group和field辅助方法案例使用连贯操作形式改写

![1541053996555](.\php\1541053996555.png)

**解疑: 连贯操作上的辅助方法为什么可以一行上呢?**

答: **原因就是每一个辅助方法的返回值都是\$this, 而\$this就是值当前模型类, 由模型类去调用后续的辅助方法, 这个是可以行得通的. 这也是为什么要求 CURD 方法必须放到最后的原因. 因为CURD返回值不是模型对象.**

在日后开发过程中, 不管是我们还是伙伴写的代码, 都**遵循使用连贯操作的形式**来替代每一个辅助方法单独一行的写法.



### TP中的统计查询

在 ThinkPHP 中系统提供了以下几个查询方法的使用, 方便后期做统计的时候使用.

- **count()**	查询表中总的记录数

- **nax()**	查询某个字段的最大值

- **min()**	查询某个字段的最小值

- **avg()**	查询某个字段的平均值

- **sum()**	求出某个字段的总和

#### count 方法

语法:

​	**$model->[where()->]count();**

案例: 查询出部门表中总的记录数

![1541054771257](.\php\1541054771257.png)

#### max 方法

语法:

​	**$model->max('字段名');**

案例: 查询部门表中id最大的id信息.

![1541054981484](.\php\1541054981484.png)

在以后实际开发的时候有这么一个应用, 通过 max 方法查询出最后注册的会员 id.

#### main 方法

语法:

​	**$model->min('字段名');**

案例: 查询部门表中id最小的id信息.

![1541055078679](.\php\1541055078679.png)

在以后的使用也有一个典型的应用: 查询最早注册的会员 id.

![1541055144213](.\php\1541055144213.png)

#### avg 方法

语法:

​	**$model->avg('字段名');**

案例: 查询部门表中 id 平均值.

![1541055788811](.\php\1541055788811.png)

#### sum 方法

语法:

​	**$model->sum('字段名');**

案例: 查询部门表中字段 id 总和.

![1541055950771](.\php\1541055950771.png)



### TP中的模型(进阶)

#### 数据对象创建(create)

**数据对象也就是父类模型中的 $this->data**, 我们在学习 AR 模式的时候使用到了数据对象, 在模型实例化的时候数据对象还是一个空数组, 后来使用魔术方法 __set 来设置了数据对象值.

从上述一个流程中我们可以看出: 既然 data 属性之前是空数组, 后期使用的时候需要先给其赋值, 也就是说, **在使用数据对象的时候必须先创建数据对象. ** 而 __set 是设置数据对象的一种方法; 但是这种方式在使用的时候并不方便, 原因是设置一个属性就得写一行单; 因此在 ThinkPHP 中系统还提供了另外一种**批量设置数据对象的方法:** **create** 方法

​	**$model->create();**

![1541069445084](.\php\1541069445084.png)

通过实现代码, 可以发现如果不给 create 方法传递参数, 默认使用 post 中的数据

![1541069422083](.\php\1541069422083.png)

在结尾处的两行代码中, 其做了 2 个操作:

​	**第一: 将处理完的 data 数据复制给 data 属性, 这步就是创建数据对象**

​	**第二: 将处理完成的数据返回出去.**

案例: 改写之前编写的部门信息入库的一个代码, 使用数据对象的创建方式

![1541070176090](.\php\1541070176090.png)

说明: 如果表单中的字段和数据表中字段不匹配, 则在创建数据对象的时候会被过滤掉

![1541070683654](.\php\1541070683654.png)

关于是否接收数据对象创建方法返回值说明:

如果想使用打印方法去查看数据是否正确则可以接收返回值, 如果不想也可不接收, 则在**使用 CURD 操作的时候也不需要给具体的操作方法传递参数. **

**\*如果需要在使用自动验证, 则必须接收返回值**

#### 自动验证

> **定义: ** 自动验证就是在提交数据的时候, 系统会按照指定规则进行数据的有效性, 合理性的验证. 

上述提及的规则, 系统默认是没有的, 如果需要使用自动验证, 规则需要我们自己去定义.

在前端 JavaScript 的验证叫做前端验证, 在 ThinkPHP 中也存在验证机制, 我们可以称之为后端验证.

自动验证语法: 没有语法, 由 数据对象创建方法 create 方法 去实现自动验证, 我们需要写的就是验证规则.

![1541071259265](.\php\1541071259265.png)

**因为在 create 方法中执行了自动验证的处理, 如果需要使用自动验证, 则必须要用 数据对象创建方法 进行接收数据**

那如何去定义所谓的 "规则" 呢?

![1541071398397](.\php\1541071398397.png)

在父类模型中存在一个成员属性 $_validate, 这个属性保存着验证的规则.

一般情况下,我们不会在父类模型中直接更改属性,  所以我们可以将该属性复制到在自定义模型中进行重新的定义.

![1541072028834](.\php\1541072028834.png)

必选参数: 

​	验证字段: 表单中每一个表单项的 name 值

​	验证规则: 就是针对验证字段的要求格式的显示, 常见的规则有 require 不为空、email 邮箱、url URL地址、
currency 货币、number 数字。 

​	错误提示: 在验证不合理的时候给用户的提示信息

可选参数: 

​	验证条件: 0 表示字段存在就验证(默认), 1表示必须验证, 2表示字段不为空的时候验证.

​	附加规则: 结合验证规则, 两者配合起来使用. 具体支持方法可参考手册--自动验证

​	验证时间: 1 表示新增数据的验证, 2表示编辑的时候验证, 3表示全部情况下都验证(默认)

**案例: 针对部门添加功能, 使用自动验证, 验证数据的合法性**

![1541073069837](.\php\1541073069837.png)

说明: 如果在自动验证中使用函数 (function) 来验证字段的合理性, 则第二个参数要求是函数名(php内置函数)或定义好(functions.php)的函数.

注意: 因为自动验证重新定义在了自定义模型中, 所以此时我们创建模型需要使用 D 方法创建自定义模型, 而非M方法.

![1541073525928](.\php\1541073525928.png)

自动验证失败, 则 create 方法返回 false, 如果验证成功, 则返回正常的数组

输出用户提示的错误信息:

​	**$model->getError();**

![1541074063105](.\php\1541074063105.png)

![1541074026355](.\php\1541074026355.png)

**批量验证**

系统支持数据的批量验证功能，只需要在模型类里面设置 **patchValidate** 属性为 true（ 默认为false）

![1541074680337](.\php\1541074680337.png)

此时错误提示返回信息是一个关联数组

![1541074749512](.\php\1541074749512.png)

#### 字段映射

> **映射就是表示对应关系. 此处的字段映射作用是用来提高系统的安全性.**

应用场景: 在目前表单中的 name 值和数据表中的 字段名 都是一样的, 有不法人员可能通过当前功能和表单的 name 值猜测到数据表中的数据字段和表结构, 后期就可能会找到系统的漏洞对系统进行攻击. 系统的安全性由此存在威胁.

因此我们可以使用一个障眼法, 将 name 值随机指定, 如此 name 值和表的 字段 就不一致了. 不法人就猜测不到了.

因为如果表单name和数据表中的字段不匹配, 在操作的时候会被系统自动过滤, 所以需要有一个对照列表, 告知系统, 不对应的 name 值是数据表中的某字段.

**字段映射 和 自动验证一样, 没有语法, 只有规则定义:** 

​	成员属性: **$_map** 

![1541075262324](.\php\1541075262324.png)

因为成员属性是父类模型中的, 一般我们不会在父类模型中直接修改, 需要在自定义模型中重新定义类的成员属性 字段映射($_map)

![1541075571804](.\php\1541075571804.png)

**因为数据对象中使用了字段映射的检查, 此处如果需要使用字段映射, 则必须使用 数据对象创建($model->create()) 来接收数据**

![1541075809034](.\php\1541075809034.png)

在使用了字段映射之后, 被映射的字段会被放到数组的最后, 按照映射的顺序进行重新排列.

#### 特殊表的实例化操作

在实际开发的时候可能会遇到有特殊表的情况, 可能表会没有前缀, 也可能是表的前置不是在配置文件中定义的前缀.

模拟一张特殊表: 

​	表名 : szphp

![1541076110588](.\php\1541076110588.png)

创建模型文件:

​	命名: SzphpModel.class.php

![1541076236563](.\php\1541076236563.png)

Szphp的实例化操作

![1541076595948](.\php\1541076595948.png)

分析原因: 是因为在实例化的时候回默认给我们添加上之前在配置文件中定义的表前缀, 这个时候表名就变成了 sp_szphp了

解决办法: 

![1541080780287](.\php\1541080780287.png)

我们**通过父类属性中的成员属性 $trueTableName 属性, 进行表名的指定, 告诉模型表名的真实名字是什么, 让其不再关联上表前缀.** 我们会在自定义模型中重新定义该属性.

![1541080990928](.\php\1541080990928.png)

特殊表的实例化模型操作

![1541081082512](.\php\1541081082512.png)



### TP中的实用项(会话)

#### 会话控制

会话支持一般都是指 **cookie** 和 **session**. 在 php 核心中有说及 php 对于 cookie 和 session 的支持, 在 ThinkPHP 中, 系统为了方便开发的使用, 也封装了相应的 cookie 和 session 方法.

##### session 的支持

在 ThinkPHP 中, 系统封装了一个方法, 用来实现对于 session 的操作: **session ** 方法, 定义在系统函数库文件中(functions.php)

![1541570592649](.\php\1541570592649.png)

- **session('name', 'value')**	创建一个名为 name 的 session 值, 只是 value

- **$value = session('name')**	读取 session 中的 name 元素值, 赋值给 $value

- **session('name', null)**		删除名为 name 的 sesson元素的值

- **session(null)**			删除全部的 session 元素

- **session()**				读取全部的 session 信息

- **session("?name")**		判断名为 name 的 session 元素是否存在, 存在返回 true, 否则 false

案例: 在方法中使用 session 方法, 对 session 进行操作

![1541126119595](.\php\1541126119595.png)

##### cookie 的支持

- **cookie('name', 'value')**		设置一个名为 name 的 cookie 值, 值是 value, 有效期是 会话结束

- **cookie('name', 'value', 3600)**	设置一个名为 name 的 cookie 值, 值是 value, 有效期是 3600秒

- **$value = cookie('name')**		读取名为 name 的cookie 赋值给 $value

- **cookie('name', null)**			删除名为 name 的 cookie 值

- **cookie()**						获取全部的 cookie

- cookie(null)					删除全部的 cookie (有毒)

案例: 通过 cookie 方法进行 cookie 操作

![1541127524751](.\php\1541127524751.png)

**注意: 上述的几个方法使用中, cookie(null) 这个方法有问题, 虽然手册上写了如此方法可以删除全部 cookie, 但是实际使用的时候并不能达到想要的效果. 如果想要这个操作可以实现则需要更改底层的实现代码(functions.php)**

![1541126781795](.\php\1541126781795.png)

![1541127379182](.\php\1541127379182.png)

#### 文件加载

文件加载在 ThinkPHP中系统提供了三个方式:

##### *函数库形式加载

函数库在 ThinkPHP 中有三大类: **系统函数库文件(functions.php), 应用级别函数库文件, 分组级别函数文件.**

**上述三大类文件只有系统函数库默认是存在的. 其它两类默认不存在, 需要自行创建(于应用/分组级别配置文件中创建).**

**上述三大类文件只有系统函数库文件名叫做 functions.php, 另外两大类文件名叫做 function.php.**

案例: 使用函数库文件的形式定义需要的函数, 函数名gbk2utf8

![1541128080811](.\php\1541128080811.png)

定义好的函数库文件中的函数, 在使用的时候遵循 php 内置函数语法的要求, 只要直接写函数名()调用即可. 有参数带参数.

![1541128188093](.\php\1541128188093.png)

![1541128248686](.\php\1541128248686.png)

说明:

​	**第一: 不需要引入 function.php. 系统在执行的时候自动帮我们引入文件 function.php**

​	**第二: 如果函数定义在应用级别的函数库文件中, 则能在全部分组(整个应用) 使用; 如果函数定义在某个分组的函数库文件中, 则只能在当前分组中使用, 否则会报函数在该分组中未定义.**

##### 通过配置项动态加载

在系统的执行流程中, 有一个 App.class.php 文件会被执行到.

![1541128798565](.\php\1541128798565.png)

在run方法中执行了 load_ext_file() 函数, 该函数不是 php 内置函数, 我们在系统函数库函数文件中找到了该方法

该方法是在系统函数库文件中定义的:

![1541128924750](.\php\1541128924750.png)

**扩展: C 方法**

C 方法也是快速方法之一, 其作用是操作 ThinkPHP 中的配置项

- **C(name, value);**		设置配置项 name 的值为 value

- **C(name);**			读取配置项 name 的值

- **C();**					读取全部的配置项

![1541129464183](.\php\1541129464183.png)

**通过代码的阅读, 可以发现配置项 LOAD_EXT_FILE 的配置项格式应该是类似于下面这种新会:**

**LOAD_EXT_FILE =>'abc,cde,efg,...'**

**而且上述文件应该是位于应用级别的函数库目录中.**

配置项: 

在应用级别的配置文件中定义配置项 LOAD_EXT_FILE, 引入文件 info.php

![1541129767485](.\php\1541129767485.png)

在应用函数库文件目录中, 定义一个 info.php

![1541129852413](.\php\1541129852413.png)

测试 LOAD_EXT_FILE 引入, 通过 load_ext_file 配置项

![1541129938520](.\php\1541129938520.png)

**上述需要注意的是, 同样文件在系统封装的方法中已经进行了引入, 所以在使用具体的函数的时候不需要再对文件进行单独引入, 只需要像使用函数库文件的形式直接编写需要的函数名及传递相应参数即可.**

##### 通过 load 方法加载

语法:

​	**load('@/不带后缀名的 php 文件名')**

**需要注意的是, 文件必须存在于分组级别的函数库目录中, 并且只能用于定义的分组中.**

案例: 通过自己在分组配置目录中创建 hello.php, 然后在其中定义一个函数, 使用 load 方法加并用函数

![1541131410709](.\php\1541131410709.png)

测试 load 方法加载 hello.php文件:

![1541131528437](.\php\1541131528437.png)

说明: 上述三个文件的加载方式在实际开发的时候都可以使用, 但是一般以第一种为主(同函数库形式自动加载). 其它两种参考即可.



### TP中的功能类(验证码类)

> **验证码: ** **captcha(全自动识别机器与人类的图灵测试)**. 常见验证码可以分为三种: 页面上的**图片**形式, **短信验证**码, **语言验证**码.

在 ThinkPHP 中, 为了提高开发效率, 系统封装了一个验证码类: **Verify.class.php**

####**介绍**

方法:

**构造方法: 在验证码实例化的时候可以传递一个配置数组, 用于和成员属性config 进行合并, 生成新的配置.**

![1541132566170](.\php\1541132566170.png)

**check 方法: 校验验证码, 传递参数, 用户输入的验证码**

![1541132650289](.\php\1541132650289.png)

**entry 方法: 输出图片, 保存验证码到 session 中**

![1541132703561](.\php\1541132703561.png)

#### 生成常规验证

常规验证码是由数字和大小写字母组成的验证码.

第一步: 实例化

第二步: 输出验证码

![1541134976903](.\php\1541134976903.png)

####　生成中文验证码

需要字体文件, 字体文件可以在自己计算机中找到

打开 [控制面板] - 切换到 [大图标], 找到 [字体] - 搜索 '黑体' - 复制 [黑体常规]

复制到 zhttfs 目录中

![1541135771007](.\php\1541135771007.png)

使用中文验证码的代码

![1541135723566](.\php\1541135723566.png)

生成效果

![1541135812446](.\php\1541135812446.png)

#### 补充说明

​	第一: 以后在实际开发的时候, 不到万不得已不要使用中文验证码.

​	第二: 中文验证码需要中文字体的支持. 中文字体可以在windows/fonts中找到, 也可以在[字体网](chinaz.com)下载

​	第三: 使用中文验证码, 必须开启 php 的扩展 mbstring.

扩展开启: 打开 php.ini, 开启扩展, 保存文件, 重启 Apache

![1541136185388](.\php\1541136185388.png)

### TP中的功能类(分页类)

数据分页它是通过 limit 语法来实现的. 分页类的核心就是 limit 语法.

在 ThinkPHP 中系统封装好了一个分页类: **Page.class.php**

#### 介绍

**属性**

![1541230563882](.\php\1541230563882.png)

**方法**

**构造方法:** 有三个参数, 但是至少得传递第一个参数(总记录数), 一般还要指定第二个参数(每页显示记录数, 默认20)

![1541230579616](.\php\1541230579616.png)

**setConfig**: 通过 public 类型的 setConfig 来设置私有属性config[配置项]

![1541230706525](.\php\1541230706525.png)

**show** 方法: 生成页码及页面页码上的 URL 连接

![1541231530475](.\php\1541231530475.png)

#### **制作分页的步骤(七个步骤)**

![1541231518782](.\php\1541231518782.png)

**第一步: 查询数据总条数**

**第二步: 实例化分页类, 传入总记录数及显示条数**

**第三步: (可选步骤) 定制分页提示文字, 使用 setConfig 方法.**

**第四步: 通过 show 方法输出分页页码的链接**

**第五步: 使用 litmit 快速方法进行分页查询, 注意参数是 page 类的属性**

**第六步: 使用 assign 将查询的数据和分页链接数据传递给模板**

**第七步: 输出模板**

#### 使用数据分页类实现职员管理分页功能

1. 查询总的记录数 $model->count();

2. 实例化分页类

   ![1541234645472](.\php\1541234645472.png)

3. 可选步骤, 指定提示文字及相关显示配置

   ![1541234659016](.\php\1541234659016.png)

4. 通过 show 方法输出分页的 URL 连接

   ![1541234692465](.\php\1541234692465.png)

   show 方法返回值值类似下面形式

   ![1541233269342](.\php\1541233269342.png)

5. **使用 limit 方法配合查询数据**

   ![1541234718718](.\php\1541234718718.png)

6. 传递数据

   ![1541234731050](.\php\1541234731050.png)

7. 展示数据

   ![1541234778170](.\php\1541234778170.png)

   ![1541234941731](.\php\1541234941731.png)

### TP中的功能类(上传类)

#### 介绍

上传文件的一个核心操作: 移动临时文件(move_upload_file).

在 ThinkPHP 中, 系统为了方便适用, 封装了一个上传类: Upload.class.php

方法:

- 构造方法

![1541311147995](.\php\1541311147995.png)

可以在实例化的时候, 传递一个配置数组, 由内部进行合并配置操作.

- getError 方法: 用于获取最后一次上传信息

![1541311260039](.\php\1541311260039.png)

语法:	**$upload->getError()**

- **uploadOne() : 上传单个文件**

![1541311325993](.\php\1541311325993.png)

参数是 $_FILES 中的子元素. 返回值是上传的结果.(成功返回一个具有九个元素的一维数组, 失败返回 false)

- **upload(): 上传多个文件**

![1541311461242](.\php\1541311461242.png)

参数通常是 $_FILES 整个数组, 返回值是上传的结果, 是二维数组, 失败返回 false

#### 案例(上传)

完善添加公文中完善附件上传功能

**注意点: **

1. 表单要有 enctype 属性
2. 要求表单中文件域 type 类型必须是 file
3. 表单提交方式必须是 post

![1541311857592](.\php\1541311857592.png)

开始:

第一步: 修改 add 方法中的表单数据处理部分

为了符合 mvc 的设计规范, 我们需要自定义一个模型, 然后将文件上传以及数据保存在模型中封装一个方法, 由这个方法执行数据的保存.

创建模型文件: DocModel.class.php

![1541312104679](.\php\1541312104679.png)

更改 控制器 add 方法, 让数据操作给模型处理. 并模型方法, 实现数据保存. saveData

![1541312396562](.\php\1541312396562.png)

第二步: 正式处理文件上传

打印 $_FILES['file'] 的结果

![1541312568596](.\php\1541312568596.png)

关于上传地址路径的说明:

​	**如果地址是给服务器端使用, 则可以使用相对入口文件的相对路径, 也可以使用带盘符的绝对路径**

​        **如果是给客户端浏览器用的, 则地址应该写成 "/" 形式, 站点域名后的地址**

在上传的案例整个过程中都不会传递给客户端. 则属于上述第一种形式. 在上传的时候, 保存的路径建议写成带盘符的形式.

在开发的时候可以将带盘符的绝对路径进行拆分:

例如: D\www\itcast\01_10086(工作目录)  \Public\Upload(上传根目录)

而工作目录可以由魔术常量 __DIR\_\_ 表示, 则上述的2个部分可以使用常量代替. 在入口文件(index.php)定义常量

![1541313629901](.\php\1541313629901.png) 

文件上传打印结果

![1541314045821](.\php\1541314045821.png)

**特别注意: 在保存上传文件的路径的时候, 在数据表中千万别写带盘符的路径, 因为上传的文件一般都要被浏览器使用, 如果使用了带盘符的路径. 则会导致 http 协议 和 file 协议冲突.**

![1541314912611](.\php\1541314912611.png)

检查此时接收的参数

![1541314811685](.\php\1541314811685.png)

**说明: 如果后期在写 CURD 操作的时候, 只是简单的基本你操作, 则可以直接写在控制器中, 如果数据需要处理, 则最好写在模型中进行数据的 curd 操作.**

![1541315104933](.\php\1541315104933.png)

##### 实现公文列表附件下载

**在附件后面添加一个下载按钮, 点击实现下载**

分析: 如果有附件, 则可以显示下载按钮, 没有则不显示. 有没有附件可以取决于hasfile字段. 使用if标签进行判断

![1541315535093](.\php\1541315535093.png)

除了使用hasfile字段, 我们还可以使用 filepath,filename字段进行判断, 如果不为空, 则表示有附件.

此时可以使用另外一个标签: **empty 或者 notempty 标签**



![1541315695351](.\php\1541315695351.png)

![1541315819762](.\php\1541315819762.png)

编写下载方 download:

```php
//	php下载代码
header('Content-type:application/octet-stream');
header('Content-Disposition: attachment; filename="'. basename($file) . '"');
header('Content-Length: '. filesize($file));
readfile($file);
```

![1541317478288](.\php\1541317478288.png)

### TP中的功能类(图像处理)

ThinkPHP 封装了一个图像处理的功能类: **Image.class.php** 

**注意: 如果使用 图像处理类, 必须开启 gd2 扩展库**

![1541332532435](.\php\1541332532435.png)

#### 缩略图制作

##### **介绍**

**方法**:

​	构造方法: __construct

![1541332585624](.\php\1541332585624.png)

其中形参都是可选的, 所以在实例化的时候可以不传递任何的参数.

​	**open 方法: 打开图片, 一般情况下, 参数是图片的路径, 建议使用绝对路径**

![1541332702157](.\php\1541332702157.png)

​	**save 方法: 保存图片, 只需要传递第一个参数图片保存完整路径即可**

![1541332750873](.\php\1541332750873.png)

​	**thumb 方法: 缩略图制作. 参数一般只需要传递宽高即可(等比缩放)** 

![1541332880550](.\php\1541332880550.png)

​	其它图片处理方法...

根据上述的方法: 我们可以归纳制作缩略图的步骤大致为

​	**第一步: 打开图片**

​	**第二步: 制作缩略图**

​	**第三步: 保存图片**

![1541333211045](.\php\1541333211045.png)

特别说明: 因为在图形处理类中所有的执行方法返回值都是 $this 说明 2点, 第一点就是可以使用连贯操作的形式, 第二点就是没有办法判断图片处理是否成功.

##### 案例

**知识添加功能过程中, 图片上传时保存缩略图地址的处理**

![1541333877008](.\php\1541333877008.png)

测试结果

![1541333897987](.\php\1541333897987.png)

### 联表查询(重点)

在原生的 sql 中使用 join 语法来进行数据的联表查询.

在 ThinkPHP 中, 系统也是支持联表查询操作, 可以归纳成两种方式. **table方法**. **join 方法**.

#### **table 方法**

原生的语法中 table 方法的语法: **select 表1.字段, 表2.字段 from 表1 as 别名1, 表名2 as 别名2 where 表1.字段 = 表2.字段; **

Where 的语句含义: 也就是通过 where 语法来进行两个表的关联操作.

案例: 查询每一个职员的全部信息, 要求使用 table 语法

分析: 因为职员信息中有一个字段 dept_id 对应部门表中的 主键, 所以此处应该读出部门的名称. 所以要求关联部门表, 关联的条件时职员表中的dept_id = 部门表中的 id.

主表: Sp_user	别名:t1

从表: Sp_dept	别名:t2

**select t1.*,t2.name as deptname from Sp_user as t1, Sp_dept as t2 where t1.dept_id = t2.id;**  

在 navicat 执行结果如下

![1541240168228](.\php\1541240168228.png)

将上述案例, 使用 ThinkPHP 语法实现查询结果

**方法1: 可以使用原生的 sql 语句进行查询**

![1541240522400](.\php\1541240522400.png)

**方法2: 可以使用 table 方法实现**

在 ThinkPHP 中一般不建议频繁使用执行原生 sql 语句方法执行 sql, 所以上述方法还可以写成另外一种形式:

​	**$model->table('表名1[as 别名1], 表名2 [as 别名2]...')**	

**table 也是连贯操作中的一个辅助方法. 在使用 table 方法后, 模型会自动关联上 table 方法中指定的数据表**

使用 table 方法改写实现如下: 

![1541240978045](.\php\1541240978045.png)

#### join 方法

![1541241135165](.\php\1541241135165.png)

在 join 语法中, 内联和左联用得比较多

在原生 sql 中, join语法: **select 表1.字段, 表2.字段 from 表1 [as 别名] \[inner/left/reight/full\]  join 表2 as 别名 on 表1.字段 = 表2.字段;**

案例: 查询部门的详细信息, 要求列出每一条部门信息中的 pid 对应的部门名称:

说明: **在以后的实际使用中, 会遇到一种关联情况, 就是自己关联自己, 自联查询.**

主表: sp_dept	别名 : t1

从表: sp_dept	别名 : t2

条件: t1.pid = t2.id

原生: **select t1.*, t2.name as deptname from sp_dept as t1 left join sp_dept as t2 on t1.pid = t2.id;**

![1541241653070](.\php\1541241653070.png)

**join 联表语法: **

​	**$model -> join('联表方式 join 表名 [as 别名] on 表1.字段 = 表2.字段');** 

join 方法也是连贯操作的辅助方法之一, 只有一个参数.

如果需要给当前模型关联的表起别名的话, 则可以使用 alias 方法: 

​	**$model->alias('别名');** 也是辅助方法之一

在 ThinkPHP 中执行上述代码结果如下:

![1541242240062](.\php\1541242240062.png)

跟踪信息中的sql如下:

![1541242379511](.\php\1541242379511.png)



### RBAC 权限管理

​      	权限就是是否能够访问某个页面. 而某个页面对应代码中就是具体的方法. 通过代码控制不同的管理员能够访问某个方法的过程就是权限控制. 经常实现权限控制的方式就是使用 RBAC 方式

#### RBAC 方式权限控制

​	基于角色的权限控制. 一个管理员属于某种角色. 而某种角色具备了多个操作的权限. 因此管理员也具备了角色对应的权限

![1542027355285](.\php\1542027355285.png)

#### RBAC 具体实现的功能

1. 实现用户的管理功能(对用户的增删改查)
2. 实现角色的管理功能(对角色的增删改查)
3. 实现权限的管理功能(对于权限的增删改查一般由开发者决定, 需要对应控制器)
4. 实现能够给用户赋予角色
5. 实现能够给角色赋予权限

6. 根据用户的角色不同显示不同的导航菜单, 方便用户进行操作

7. 针对所有的用户访问每一个方法都进行判断是否具备访问的权限
8. 预留一个默认的超级管理员角色
9. 预留一个超级管理员的用户

##### RBAC数据表创建

**管理员表**

```mysql
create table if not exists `blog_admin`(
		`id` int(11) not null auto_increment primary key,
    `username` varchar(30) not null default '' comment '用户名',
    `password` varchar(32) not null default '' comment '密码'
)charset=utf8;
```

**角色表**

```mysql
create table if not exists `blog_role`(
	`id` int(11) not null auto_increment primary key,
    `role_name` varchar(30) not null default '' comment '角色名称'
)charset=utf8;
```

**用户角色的中间表**

```mysql
create table if not exists `blog_admin_role`(
	`id` int(11) not null auto_increment primary key,
	`admin_id` int(11) not null default 0 comment '用户id',
	`role_id`  int(11) not null default 0 comment '角色id'
)charset=utf8;
```

**权限表**

```mysql
create table if not exists `blog_rule`(
	`id` int(11) not null auto_increment primary key,
    `rule_name` varchar(30) not null default '' comment '权限名称',
    `module_name` varchar(30) not null default '' comment '模型名称',
    `controller_name` varchar(30) not null default '' comment '控制器名称',
    `action_name` varchar(30) not null default '' comment '控制器名称',
    `parent_id` int(11) not null default 0 comment '上级权限id, 0表示顶级权限',
	`is_show` tinyint(1) not null default 1 comment '是否导航菜单显示 1表示显示 0表示不显示'
)charset=utf8;
```

**角色权限中间表**

```mysql
create table if not exists `blog_role_rule`(
    `id` int(11) not null auto_increment,
    `role_id` int(11) not null default 0 comment '角色id',
    `rule_id` int(11) not null default 0 comment '权限id'
)charset=utf8;
```

##### 角色管理

1. 角色控制器(RoleController)
2. 角色模型(RoleModel)
3. 角色视图目录(role)

- 控制器

  - add 方法实现添加角色和添加视图的显示

    ![1542029854525](.\php\1542029854525.png)

  - 调用模型 listData 方法获取数据, 并赋值结果给模板显示角色列表

    ![1542030263679](.\php\1542030263679.png)

  - dels 方法 调用模型的 remove 方法实现删除角色(超级管理员除外)

    ![1542031656801](.\php\1542031656801.png)

  - edit 方法实现数据的修改操作和修改视图的显示

    ![1542032220571](.\php\1542032220571.png)

- 模型
  - 字段定义 / 自动验证

    ![1542029630134](.\php\1542029630134.png)

  - 模型 listData 方法获取角色信息

    ![1542030673894](.\php\1542030673894.png)

  - 模型 remove 方法删除角色

    ![1542031712515](.\php\1542031712515.png)

- 视图

  - 添加角色模板的拷贝及 form 表单的修改

  - 角色列表模板的拷贝及页面内容的修改(超级管理员数据无编辑和删除操作)

    ![1542030915057](.\php\1542030915057.png)

  - 删除按钮绑定删除角色的方法路径

  - 修改按钮绑定修改角色的方法路径

  - 修改视图的表单项修改, 表单添加隐藏input

##### 管理员管理

1. 控制器 AdminController
2. 模型 AdminModel
3. 视图 Admin

- 控制器

  - add 方法实现管理员添加视图显示和添加业务(视图显示需要角色数据)

    ![1542032819367](.\php\1542032819367.png)

  - index 方法调用模型 listData 实现列表显示

    ![1542035644088](.\php\1542035644088.png)

  - dels 方法删除管理员(中间表数据的删除)

    ![1542068422881](.\php\1542068422881.png)

  - edit 方法显示修改视图及修改业务的完成

    ![1542069387497](.\php\1542069387497.png)

- 模型

  - 模型创建, 定义字段/自动验证 编写

    ![1542034460755](.\php\1542034460755.png)

  - 模型中编写自动完成(密码md5加密)和钩子函数实现中间表的数据入库

    ![1542034533714](.\php\1542034533714.png)

  - 模型中 listData 实现三表联查获取管理员信息及对应的角色

    ![1542035489454](.\php\1542035489454.png)

  - 模型中remove方法删除对应id的管理员信息和中间表中管理员对应角色的信息(两者相互联系, 要么全留, 要么全删--事务管理)

    ![1542068653936](.\php\1542068653936.png)

  - 模型中实现方法获取管理员信息(联表查角色名称)

    ![1542069194397](.\php\1542069194397.png)

  - 模型中修改业务的数据操作实现

    ![1542069701648](.\php\1542069701648.png)

- 视图

  - 添加视图遍历显示角色下拉菜单, 表单项的修改
  - 首页视图遍历显示管理员列表
  - 首页视图删除标签修改删除指向地址
  - 首页视图编辑标签修改编辑指向地址, 编辑表单内容的修改

##### 权限管理

控制器: RuleController

模型:RuleModel

视图: rule

- 控制器

  - add 方法添加视图显示及添加业务的实现

    ![1542070959331](.\php\1542070959331.png)

  - index 方法实现权限列表渲染

    ![1542071327595](.\php\1542071327595.png)

  - dels 方法的编写

    ![1542071533361](.\php\1542071533361.png)

  - edit 方法

    ![1542071912637](.\php\1542071912637.png)

- 模型

  - 自定义字段/自动验证的修改

    ![1542070416925](.\php\1542070416925.png)

  - 模型中编写添加数据操作业务

  - 模型中删除数据操作的业务

    ![1542071672975](.\php\1542071672975.png)

  - 模型中修改数据操作的业务

    ![1542072238745](.\php\1542072238745.png)

- 视图

  - 权限添加视图表单项的修改 

  ![1542071224744](.\php\1542071224744.png)

  - 权限列表视图的编辑
  - 修改视图的编辑

##### 为角色分配权限

1. 显示所有的权限信息

   ![1542163820543](.\php\1542163820543.png)

2. 实现权限分配的入库

   ![1542163782281](.\php\1542163782281.png)

3. 完善显示的所有的权限信息

##### 权限验证

1. 分析权限认证实现

   1. 实现管理员能够登录到后台(session记录登录的管理员状态记录)

   2. 针对所有控制器下的方法都进行判定已经登录(公共控制器中构造方对当前登录管理员进行session验证)

   3. 对所有的方法都判断当前用户是是否具备访问的权限

      首先获取得到当前管理员的角色信息如果是默认的超级管理员, 则不进行权限验证, 否则需要对权限进行认证

      - 超级管理员直接忽略权限验证
      - 普通管理员, 通过普通管理员所对应角色信息获取拥有的权限信息. 将从数据库中获取到的权限信息的二维数组按照格式将模型,控制器, 方法组合成一个一维数组. 在根据当前请求的url地址将当前的模型控制器方法组合成为一个字符串.再与一维数组进行比较. 如果说存在说明有权限访问, 否则无权访问

   4. 实现根据不同的管理员显示出不同的导航菜单

      - 超级管理员获取所有的权限信息
      - 普通管理员获取角色所对应的权限信息
      - 将权限信息赋值给模板, 由模板进行显示

2. 权限认证步骤实现

   - 获取登录用户的所有权限信息
     - 两个属性, 一个表示是否验证, 另一个保存登录用户信息

       ![1542176712407](.\php\1542176712407.png)

     - 登录用户信息(查询获取用户角色id)

     - 根据用户角色id 获取角色信息 

       ![1542176755940](.\php\1542176755940.png)

     - 根据角色id获取权限信息

       ![1542198053353](.\php\1542198053353.png)

   - 将用户权限信息转为一维数组, 结果保存到登录用户信息属性(user)中

     - 根据保存的 rules 属性进行权限判断是否可以访问

     ![1542198144468](.\php\1542198144468.png)

3. 根据权限构建管理菜单

   - 首页显示的时候, 获取当前登录用户的信息, 赋值给视图

     ![1542198293157](.\php\1542198293157.png)

   - 首页视图菜单的修改

     ![1542198643707](.\php\1542198643707.png)

#### 使用文件的方式存储

##### **实现步骤**

1. 当需要获取用户信息时, 在数据库获取信息之前, 先到当前用户对应的文件中读取信息. 如果读取到了数据直接使用, 否则到 mysql 中读取信息然后在将信息写入文件中, 方便下次使用

2. 当某个角色对应的权限信息发生变化, 需要将当前角色下的所有用户的文件信息全部删除

##### **代码实现**

1. 从文件中获取用户信息

   ![1542244609956](.\php\1542244609956.png)

2. 根据获取到的用户信息判断是否进行数据库操作获取数据

   ![1542246397675](.\php\1542246397675.png)

3. 当数据获取成功后, 写入到文件中

   ![1542246374948](.\php\1542246374948.png)

4. 如果是超级管理员, 则不进行权限验证

   ![1542245130152](.\php\1542245130152.png)

5. 角色权限发生变化的时候, 删除保存该用户信息文件

   ![1542247803663](.\php\1542247803663.png)

存在问题: 在增加新权限时, 针对超级管理员信息文件(缓存文件), 导致菜单更新不出来的问题

解决: 在权限控制器中, 添加一个方法, 针对超级管理用户信息文件(缓存文件) 的"更新"

1. 在权限管理中, 添加方法处理超级管理员缓存问题

   ![1542249497736](.\php\1542249497736.png)

2. 权限新增的时候调用该方法, 触发超级管理员缓存文件删除

   ![1542249574240](.\php\1542249574240.png)

   权限删除和修改也需要调用该方法清除超管的缓存文件

   ![1542249773885](.\php\1542249773885.png)

## 知识扩展

### 在 ThinkPHP 中获取 IP 信息扩展

在 ThinkPHP 中系统封装了一个获额取 ip: **get_client_ip()** [系统函数库文件中]

![1541321827970](.\php\1541321827970.png)

语法: 

​	**get_client_ip(可选参数数字)**

​	如果参数是0的话或者不写(默认), 则表示返回正常的 ipv4 地址.

​	如果参数是1的话则表示返回 ipv4 地址对应的数字地址.

关于数字地址和ip地址的计算方法

![1541321850995](.\php\1541321850995.png)

**重点是如何在 ThinkPHP 中将 ip 地址转换成 物理地址**

类似于如下

![1541321931801](.\php\1541321931801.png)

在ThinkPHP中系统提供了一个工具类, 能实现转换, 但是系统不听转化所使用的数据, 也就是说需要自己去寻找对应的数据库.

数据库可以从纯真官网去寻找(http://www.cz88.net)

![1541322104798](.\php\1541322104798.png)

![1541322307333](.\php\1541322307333.png)

下载安装的程序之后,在其安装目录中可以找到 qqwry.dat 文件. 就是数据库文件

![1541322431799](.\php\1541322431799.png)

**ThinkPHP 提供了ip查询地址的类: IpLocation.class.php** 

构造方法: 

![1541322637064](.\php\1541322637064.png)

可以得知, 在实例化的时候可以传递一个文件名, 文件名所在的位置和当前类是同级目录 

**getlocation 方法**: 需要传递 ip 地址, 如果为空, 则表示查询当前用户的 ip 地址

![1541322811421](.\php\1541322811421.png)

#### 案例 

**根据 id 查询指定地址**

第一步: 复制数据库文件到 Ip 类的同级目录文件下

![1541322999534](.\php\1541322999534.png)

第二步: 编写代码

![1541323670640](.\php\1541323670640.png)

### 空操作

**介绍**

> 空操作是指系统在找不到指定的操作方法的时候, 会定位到空操作的方法来执行(针对控制器也是如此). 利用这个机制, 我们可以实现 **错误页面** 和一些 URL 的优化.

关于空操作的说明:

1. 空操作方法: 在控制器中可以定义一个操作方法名字叫做  **_empty()**

   **空方法的实现**: 

   例如, 下面的操作方法, 我们在 Test 控制器中, 访问一个该控制器中不存在的方法, 则会默认范围 _empty方法.

   ![1541390105343](.\php\1541390105343.png)

2. 空操作控制器: 在ThinkPHP 存在一个空的控制器, **当指定控制器找不到, 则会去访问空的控制器**. 空控制器文件名叫做 **EmptyController.class.php**

   **空控制器实现:**

   ![1541390572729](.\php\1541390572729.png)

#### 案例

**使用 空控制器空方法实现404页面**

第一步: 创建空操作控制器和空方法, 在其中展示静态页

第二步: 空方法中编写展示丢失模板

![1541391566220](.\php\1541391566220.png)

第三步: 丢失模板放置指定位置, 修改静态资源路径

![1541391544437](.\php\1541391544437.png)

测试结果如下

![1541391592382](.\php\1541391592382.png)





## 插件扩展

### highcharts 图标插件

#### 介绍

一款以及 jQuery 开发的图标插件. 国外插件, 国内类似的有 echarts(百度)

[官网链接](http://www.highcharts.com)

[下载地址](https://www.highcharts.com/download)

[文档demo](https://www.highcharts.com/demo)

1. 目录结构

![1541243484868](.\php\1541243484868.png)

#### 案例

综合案例: 使用 highcharts 实现部门人数的统计

案例要求: 使用图标统计每个部门人数

**第一步: 从 examples 目录中找到适合案例的demo代码**

​	确定使用目录为 column-rotated-labels 中的代码

**第二步: 分析 demo**

分析使用步骤:

 	1. 引入 jquery 文件
 	2. 替换 data 数据
 	3. 引入 highcharts.js 和 modules 目录下的 exporting.js
 	4. 声明一个 div 放置图标(图标容器)

**第三步: 修改模板文件 User/showList.html. 将下面的统计按钮设置链接, 跳转指定页面**

![1541243968028](.\php\1541243968028.png)

定义图标页面的方法: charts, 写在 UserController.class.php 中, 展示图标的模板文件

**第四步: 将图标 demo 文件复制到模板位置(User/charts.html)**

复制 highcharts整个目录到 /Public/plugin 下(后期使用的插件都放置于此目录)并更名 charts

修改 charts.html 中静态资源路径

![1541246720436](.\php\1541246720436.png)

**第五步: 查询获取真实数据, 替换charts.html中修改显示真实数据** 

统计部门有多少人, 最终的形式应该是类似于:

​	**产品部: 10,**

​	**管理部: 5,**

​	**技术部: 20**

​	**...**

需要联表查询(sp_user, sp_dept)

主表:	sp_user		t1

从表:	sp_dept		t2

关联条件: t1.dept_id = t2.id

原生sql写法: **select t2.name as deptname,count(1) as count from sp_user as t1,sp_dept as t2 where t1.dept_id = t2.id group by deptname**

navicat 中执行结果如下

![1541245190293](.\php\1541245190293.png)

ThinkPHP 连贯操作查询数据: 

**$model->field('t2.name as deptname, count(1) as count')->table('sp_user as t1,sp_dept as t2')->where('t1.dept_id=t2.id')->group('deptname')->select()**

定义字符串处理得到的数据, 赋值到模型中替换假数据

![1541301526955](.\php\1541301526955.png)

**第五步: 细节处理, 显示结果**

![1541301604014](.\php\1541301604014.png)

![1541301569964](.\php\1541301569964.png)

### ueditor 编辑器

> **介绍**: Ueditor 是一款在线编辑器插件, 又名 "富文本编辑器". 作用是为了方便图文混排操作, 国外也有类似插件, CKeditor.

UE 是百度公司开发的在线编辑器, [官网](https://ueditor.baidu.com/website/index.html)

![1541307589244](.\php\1541307589244.png)

#### **使用步骤**

**第一步: 引入资源文件**

![1541307859499](.\php\1541307859499.png)

ueditor.config.js

ueditor.all.min.js

zh-cn.js

**第二步: 指定标签, 设置容器的位置 (编辑器显示的位置)**

![1541307896336](.\php\1541307896336.png)

**第三步: 实例化容器, 生成富文本编辑器**

![1541307931724](.\php\1541307931724.png)

#### 案例

使用 ueditor 替换公文管理的指定表单.

第一步: 引入ueditor资源

![1541308729562](.\php\1541308729562.png)

第二步: 容器代码修改

![1541308721559](.\php\1541308721559.png)

第三步: 实例化容器

![1541308749865](.\php\1541308749865.png)

优化样式后显示效果如下

![1541309038813](.\php\1541309038813.png)

测试ue提交结果

![1541309179268](.\php\1541309179268.png)

![1541309204284](.\php\1541309204284.png)

问题1: ue 编辑器默认的 name 是 editorValue, 默认值和数据表中字段名是不一样的, 在后期添加业务的时候会被过滤, 如何解决?

解决方法: 只需要给当前容器添加一个name属性即可.

问题2: ue 编辑器原码中的一些样式会被转换成实体字符, 是谁去转换的实体字符呢?

答: 此处的转码是由 ThinkPHP 的 I 方法去转换的. 使用的是 htmlspecialchars 进行转码的. 

![1541309556887](.\php\1541309556887.png)

在读取的时候需要将数据表中实体字符进行还原, 可以使用函数 htmlspecialchars_decode 进行内容还原.

#### 关于使用UE的说明

1.  **防止SQL注入和xss**: 光通过 **I** 方解决不了, 在后面我们会使用一个插件 **htmlpurifiy** 来对指定标签进行过滤

2. 关于 ue 中的表情使用, 这个功能需要联网

3. 关于图片上传, 在 ue/php/config.json , 需要指定路径. 否则会自动创建一个目录

   ![1541309826582](.\php\1541309826582.png)

### layer

> layer 是基于 JQ开发的一款美化弹窗的插件, 作用于美化弹窗效果

[官网](https://layer.layui.com/)

[在线手册](https://www.layui.com/doc/modules/layer.html)

**下载**

![1541318382087](.\php\1541318382087.png)

**使用**

第一步: 引入 js文件(jquery文+layer.js)

第二步: 编写 js 代码即可

#### 案例

**使用layer查看公文的内容**

要求: 点击公文后面 [查看] ,弹窗显示公文内容(content字段)

第一步: layer 目录放置静态资源文件目录下

第二步: showList.html 引入layer 插件资源

![1541319471418](.\php\1541319471418.png)

第三步: 给 查看元素 绑定点击事件, 绑定属性传递 id 值. 

![1541319508937](.\php\1541319508937.png)

后期可以通过 jq 的 attr() 获取 data-id 值

第四步:  实现弹出效果.

![1541320946584](.\php\1541320946584.png)

第五步: 编写方法, 展示公文内容 showContent

![1541321121899](.\php\1541321121899.png)

结果查看

![1541321141503](.\php\1541321141503.png)



## 综合案例

###　实现后台的登录

控制器: PublicController.class.php

模板: login.html

方法: login, captcha, checkLogin

第一步: 控制器的编写及模板相关处理, 正常显示登录界面.

![1541145750822](.\php\1541145750822.png)

第二步: 在控制器中创建 captcha 方法, 引入验证码类, 生成常规验证码 .

![1541146565029](.\php\1541146565029.png)

第三步: 在登录模板(login.html)中输出验证码. 使用 img 标签地址指向验证码地址. 

给 img 标签绑定点击事件. 实现局部刷新(刷新验证码)

![1541147054074](.\php\1541147054074.png)

![1541147660847](.\php\1541147660847.png)

第四步: 准备一个用户数据表及相关数据

```mysql
create table if not exists sp_user(
	`id` int(11) not null auto_increment primary key,
    `username`	varchar(40) not null,
    `password`	char(32) not null,
    `nickname`	varchar(40) default null,
    `truename`	varchar(40)	default null,
    `dept_id`	int(11) default null,	#部门id
    `sex`	varchar(10) not null,
    `birthday`	date not null,
    `tel`	varchar(11) not null,
    `email`	varchar(50) not null,
    `remark`	varchar(255) default null,	#备注
    `addtime`	int(11) default null,
    `role_id`	int(11) default null	#角色
)engine=MyISAM default charset=utf8;
```

第五步: 检查表单是否符合处理要求, 并做正确的修改(name, action), jq提交表单

![1541148159623](.\php\1541148159623.png)

第六步: 编写checkLogin 方法, 处理用户登录操作.

使用 I 函数接收数据(验证码的特殊处理)

![1541148197976](.\php\1541148197976.png)

问题: 对于接收数据(密码, 用户名, 验证码), 先验证谁?

答: 先验证验证码, 如果验证码正确, 再去验证用户名和密码

用户信息持久化, 保存 session 数据(id, username, role_id)

![1541154400922](.\php\1541154400922.png)

第七步: 首页基本信息展示和退出的实现

修改登录后台首页中展示基本信息.

![1541154727870](.\php\1541154727870.png)

修改退出按钮的跳转地址并且实现退出方法: 跳转目标 User/logout 方法

logout 方法实现 session 清除并跳转 

![1541156055748](.\php\1541156055748.png)

**注意: 在 ThinkPHP中, 不能在 javascript 文件, css等非模板文件中使用任何模板引擎的东西.** 所以js中跳转路径只能写绝对路径

![1541155068117](.\php\1541155068117.png)

### 后台首页的展示

控制器: IndexCOntroller.class.php

方法: index, home

模板: index.html, home.html

第一步: 创建控制器文件 **IndexController.class.php**

第二步: 在控制器中增加两个方法: index 和 home. 作用是展示模板

![1541062273855](.\php\1541062273855.png)

第三步: 复制模板文件到视图文件中

第四步: 复制静态资源到 Public 目录的对应位置, 修改模板文件中的静态资源

![1541061914721](.\php\1541061914721.png)

第五步: 修改home页面在index中的引入路径: 

![1541061962167](.\php\1541061962167.png)

Index 控制器和 index 方法是默认的控制器和默认方法, 可 以省略不写, 由于 pathinfo 路由形式他的相对路径会受到 "/"的影响, 所以不写默认的控制器和方法的时候, 会影响到相对路径.

![1541062183469](.\php\1541062183469.png)

另一种方式:

在模板中也可以使用 U 方法来指定个URL地址.

**U方法在模板中使用的时候, 需要注意使用方式 {:U('视图')}**

![1541062039965](.\php\1541062039965.png)

### 部门管理的功能

#### 显示添加部门视图并完成添加部门业务

- 设计部门管理的二级导航

第一步: 复制 [导航信息管理] 中的代码, 黏贴到 [组织结构管理] 下

![1541062888801](.\php\1541062888801.png)

第二步: 修改二级导航的数目以及跳转地址

- 实现部门的添加功能

控制器: DeptController.class.php

方法: add 

模板文件: add.html

第一步: 创建 add 方法, 作用: 展示添加部门模板

![1541062923402](.\php\1541062923402.png)

第二步: 复制模板文件 add.html 到指定位置

第三步: 修改模板文件中静态资源文件引入路径

![1541062984379](.\php\1541062984379.png)

第四步: 检查表单, 修改提交地址, name属性等

- 通过 jquery 来处理表单的提交和内容重置

![1541063137452](.\php\1541063137452.png)

第五步: 展示 [上级部门] 的信息

- 查询顶级部门
- 修改绑定数据到视图中去

![1541067604986](.\php\1541067604986.png)

- 视图中展示数据 volist 遍历操作

![1541067582334](.\php\1541067582334.png)

第六步: 处理表单信息的提交操作

- 改写 add 方法, 判断请求类型(post处理表单提交, get显示视图)

  扩展: 如何判断请求是否是post.

  答: **以前我们可以使用 if($_POST)来判断**, 但是在 ThinkPHP中系统为我们封装了几个比较实用的常量, 可以通过判断常量来判断, 常量常见的如下:

  - **IS_POST**	如果请求是post 则, IS_POST 值是true, 否则是 false
  - **IS_GET**    ....
  - **IS_AJAX** 如果请求是 ajax, 则 IS_AJAX 值是true, 否则是 false
  - ....

- 处理表单

  关于**数据接收**的说明:

  之前我们使用的是 $_POST 来接收数据, **在 ThinkPHP 中, 我们可以使用 I 方法(快速方法) 来接收数据**, **I 方法可以接收任何类型的输入 (post,get,request,put等等), 并且系统默认自带防 SQL 注入的方法(使用php内置的函数 htmlspecialchars).**

  **语法:** 

  ​	**I('变量类型.变量名'\[,'默认值'][,'过滤方法'])**

  **变量类型就是类似 get, post 等等**

  **变量名就是指 \$\_GET或者 \$_POST中的具体元素下标.**

  **默认值: 是当使用过滤方法之后, 原先的内容如果变成了空字符串, 则会使用默认值来代替**

  **过滤方法: 是对 ThinkPHP 默认提供的 htmlspecialchars 的补充, 函数名可以是 php内置的,也可以使函数库中的.**

  **额外的说明: 如果想接收整个数组, 则可以写成 I('get.') 即可, 表示接收全部数据**

![1541068361996](.\php\1541068361996.png)

#### 部门列表展示

控制器: DeptController.class.php

方法: showList(不使用list, 因为它是关键词)

模板: showList.html

第一步: 复制模板到指定位置(Dept/showList.html)展示模板, 修改静态资源路径

第二步: 查询数据, 传递数据到模板, 模板中遍历循环输出数据

![1541158831404](.\php\1541158831404.png)

![1541158854468](.\php\1541158854468.png)

上述代码中本来需要使用连联表查询来实现非顶级部门数据的查找上级部门名称的效果, 但是可以通过二次查询的方式查询出所属上级部门名称

**要求修改: *要求使用文件载入的知识点实现部门列表的无限极分类效果 **

![1541487711418](.\php\1541487711418.png)

定义好了应用级别的函数文件后, 在案例中使用该函数获取无限极分类数据.

因为是应用级函数文件的引入, 无需其他操作, 直接使用函数即可

![1541208330803](.\php\1541208330803.png)

页面修改及输出结果

![1541208423855](.\php\1541208423855.png)

#### 部门管理分页补充

![1541236894872](.\php\1541236894872.png)

#### 部门编辑功能

控制器: DeptControoller.class.php

方法: edit(展示模板和处理修改提交)

视图: edit.html

第一步: 控制器编写edit方法实现目模板展示. 模板放置于正确位置(Dept/edit.html)

![1541208811486](.\php\1541208811486.png)

第二步: dept的是showList视图中添加修改链接, 指定正确的访问路径, 带id参数

![1541208906229](.\php\1541208906229.png)

第三步: 修改edit方法, 获取原有数据, 并修改视图模板达到数据的展示

![1541210126203](.\php\1541210126203.png)

![1541210254196](.\php\1541210254196.png)

说明: 需要注意, 如果 if 标签中是进行两个变量的比较, 变量是数组, 并且用得是数组的 .属性形式. 则需要在运算符 == 前后添加空格, 而且在最后一个变量后面要加上空格. [属性] 访问没有这个要求.

第四步: 修改数据提交的保存入库操作

修改表单, 添加隐藏域. 因为系统限制不能进行批量修改, 所以修改的时候必须指定主键. 我们添加一个隐藏域来保存 id. 我们也可以使用 get 中的 id 数据也可以.

![1541210561128](.\php\1541210561128.png)

jq代码提交

![1541210701927](.\php\1541210701927.png)

**数据保存操作: 完善控制器中的 edit 方法**

![1541211681158](.\php\1541211681158.png)

注意: 如果说数据没有作任何修改就提交, 返回影响行数是 0, 不能算是修改失败. 所以我们修改判断条件

![1541211804922](.\php\1541211804922.png)

#### 部门删除功能

控制器: DeptController.class.php 

方法: delete

模板文件: showList

说明: 删除有单个删除也有批量删除. 所以这种情况, 我们给列表页的数据每一行添加复选框

第一步: 列表每行添加复选框

![1541213615379](.\php\1541213615379.png)

第二步: 点击删除按钮, 获取当前页面选中的复选框对应的value值, 带着值跳转到 Dept/del 进行批量删除操作

使用jq完成需要删除的id集合的生成.

![1541214183034](.\php\1541214183034.png)

第三步: 控制器编写 del 方法, 执行删除操作

![1541214463244](.\php\1541214463244.png)



### 职员管理的功能

####　准备工作

1. 创建左侧菜单

   - 修改后台首页左侧导航信息. 将导航管理->职员管理相关

   - 修改 跳转链接地址User/showList  User/add
2. 控制器 UserController.class.php
3. 数据表数据添加 sp_user 

####　职员的添加

控制器: UserController.class.php

方法: add

模板文件: add.html

第一步: 控制器新增 add 方法, 展示添加职员模板

![1541220704069](.\php\1541220704069.png)

第二步: 模板文件的复制到正确位置, 及静态资源路径修改

![1541220556623](.\php\1541220556623.png)

第三步: 修改控制器 add 方法. 获取部门信息, 绑定数据到模板. 视图模板下拉菜单数据的显示

- 无限级菜单的输出 getTree 方法是运用.

![1541220865837](.\php\1541220865837.png)

![1541221132032](.\php\1541221132032.png)

第四步: 提交按钮执行提交操作. 判断是否是 POST 方式, 修改 add 方法.

- a 标签 jquery 编写代码提交 form 表单

![1541221221799](.\php\1541221221799.png)

![1541221315243](.\php\1541221315243.png)

- 表单中时间控制的了解, jq的一个时间插件(jq时间插件必须在jq引入之后引入)

![1541221277517](.\php\1541221277517.png)

![1541221245697](.\php\1541221245697.png)

第五步: 改写 add 方法, 验证提交数据, 使用 数据对象创建 方式 并且执行自动验证.

- 自动验证的编写

![1541222831879](.\php\1541222831879.png)

第六步: 数据入库. 判断是否成功

![1541223249141](.\php\1541223249141.png)

#### 职员列表显示

控制器: UserController.class.php

方法: showLits

模板: showList.html

第一步: 控制器创建 showList 方法, 数据查询及模板的显示

- 数据库查询数据操作赋值模板

![1541225134210](.\php\1541225134210.png)

第二步: 模板展示真实数据

![1541225103389](.\php\1541225103389.png)

![1541225149717](.\php\1541225149717.png)

#### 职员删除和修改

控制器: UserController.class.php

方法: del edit

模板: edit.html

第一步: 控制器创建 修改 和 删除方法

第二步: showList视图中 删除链接的修改, 添加链接地址到控制器的del 方法. 修改编辑方法, 添加链接到控制器的edit方法

![1541227316544](.\php\1541227316544.png)

![1541227339392](.\php\1541227339392.png)

第三步: 删除根据传递的id进行删除; 修改操作: 修改edit方法, 根据 id 先查询指定数据,显示到模板.

![1541229247990](.\php\1541229247990.png)

![1541229223902](.\php\1541229223902.png)

第四步: 删除是del方法的数据库操作; 修改是根据edit的post数据进行数据库修改操作.

![1541227289426](.\php\1541227289426.png)

![1541229937634](.\php\1541229937634.png)

### 公文管理的功能

####　准备工作

##### 准备数据表

表名: sp_doc

```mysql
create table if not exists `sp_doc`(
    `id` int(11) not null auto_increment primary key,
    `title`	varchar(50) not null comment '公文标题',
    `filepath`	varchar(255) default null comment '附件存储路径',
    `filename`	varchar(255) default null comment '附件原名',
    `hasfile`	smallint(1) default '0' comment '是否存在附件',
    `content`	text comment '公文内容',
    `author` 	varchar(40)	not null comment '作者',
    `addtime`	int(11) default null comment '添加时间'
)engine=myisam auto_increment=1 default charset=utf8;
```

##### 基本文件的创建

**控制器创建**

DocController.class.php

![1541304709956](.\php\1541304709956.png)

**创建二级导航**

修改模板文件 Index/index.html 添加公文管理的导航菜单

![1541304777453](.\php\1541304777453.png)



####  添加公文功能

控制器: DocController.class.php

方法: add(二合一, 将模板和保存处理写在一起)

视图: add.html

第一步: 文件的创建, 模板的移动, 静态资源路径的修改. form 表单的修改等等..

![1541305113362](.\php\1541305113362.png)

Action: 由于是提交给当前页面处理, 所以可以不写

Ectype: 声明当前表单中存在多媒体文件, 只要是用了附件上传, 必须需要这个属性

第二步: **先不考虑文件上传**, 实现数据入表保存

![1541305705588](.\php\1541305705588.png)



#### 显示公文列表

控制器: DocController.class.php

方法: showList(二合一, 将模板和保存处理写在一起)

视图: showList.html

要点: 应用级别的函数文件 function.php 中常用方法的使用

**字符串截取方法 msubstr**

![1541307104930](.\php\1541307104930.png)

$suffix : 是否添加省略号

模板中使用, 修饰title的输出

![1541307315460](.\php\1541307315460.png)

#### 完善编辑功能

控制器: DocController.class.php

方法 edit(模板显示和业务组合)

模板: edit.html

第一步: showList模板添加编辑并指指向控制器edit方法

![1541325957086](.\php\1541325957086.png)

第二步: edit.htm l模板文件移动. 静态资源的修改. 

第三步: edit 方法查询数据并绑定显示模板

![1541326504737](.\php\1541326504737.png)

![1541326490873](.\php\1541326490873.png)

说明:

1. 关于文件域的值: 从文件域中输出 value 没有意义, 所以我们可以采用和修改密码一样的原理, 如果用户选择了文件, 则表示修改, 如果没有选择, 这表示不修改附件.
2. 由于 content 字段在之前写入数据表的时候通过了 I 方法进行了转码处理, 所以在展示的时候还需要解码, 还原之前的形式, 在还原之前, 需要使用 htmlspecialchars_decode 进行解码.

第四步: 检查表单提交地址及方式 隐藏域

![1541326735344](.\php\1541326735344.png)

![1541326881911](.\php\1541326881911.png)

表单中添加一个隐藏域 (通过隐藏的表单项来传递一个值) 值可以是传递来的 $data.id 也可以是 \$Think.get.id

第五步: 改写 edit 方法, 实现数据的修改

![1541328765046](.\php\1541328765046.png)

模型中实现数据保存

![1541328734358](.\php\1541328734358.png)

### 实现知识管理

####　准备工作

1. 数据表: sp_knowledge

   ```mysql
   create table if not exists `sp_knowledge`(
       `id`	int(11) not null auto_increment primary key,
       `title`	varchar(50) not null comment '标题',
       `thumb`	varchar(255) default null comment '缩略图',
       `picture`	varchar(255) default null comment '图片',
       `description`	varchar(255) comment '描述',
       `content`	text comment '内容',
       `author`	varchar(40) not null comment '作者',
       `addtime`	int(11) default null comment '添加时间'
   )engine=myisam auto_increment=1 default charset=utf8;
   ```

2. 修改 Index/index.html 下的导航, 给知识管理添加项目并指定路径

![1541330119998](.\php\1541330119998.png)

3. 创建控制器 KnowledgeController.class.php

![1541330315129](.\php\1541330315129.png)

#### 实现添加功能

控制器: knowledgeController.class.php

方法: add (二合一: 展示模板/数据保存)

模板文件: add.html

第一步: 创建 add 方法, 展示模板文件

![1541330656070](.\php\1541330656070.png)

第二步: 模板位置的移动, 资源的路径的修改, 表单的检查/修改

**第三步: 改写 add 方法, 用于处理表单的提交以及数据的保存操作**

![1541331671553](.\php\1541331671553.png)

编写模型 KnowledgeModel.class.php, 执行数据的处理

![1541333949027](.\php\1541333949027.png)

结果展示

![1541334163895](.\php\1541334163895.png)

#### 实现知识列表展示

控制器: KnowledgeController.class.php

方法: showLIst

模板: showList.html 

![1541334759341](.\php\1541334759341.png)

![1541334739537](.\php\1541334739537.png)

**实现图片下载**

1. 视图修改: 如果有图则下载

![1541334940796](.\php\1541334940796.png)

![1541334959115](.\php\1541334959115.png)

2. download 方法的编写

![1541335295491](.\php\1541335295491.png)

#### 修改操作

控制器: KnowledgeController.class.php

方法: edit

模板: edit.html

![1541381847309](.\php\1541381847309.png)

![1541381874667](.\php\1541381874667.png)

![1541381958464](.\php\1541381958464.png)

#### 删除操作

![1541383414825](.\php\1541383414825.png)

![1541383391880](.\php\1541383391880.png)

### 实现邮件管理

邮件: 这里的邮件指的是一般论坛网址的站内消息(私信 private message). 站内信一共可以分为以下几个组成部分: 邮件发送, 邮件收件箱, 邮件发件箱.

#### 准备工作

1. 数据表 sp_email 创建

```mysql
create table if not exists `sp_email`(
	`id` int(11) not null auto_increment primary key,
    `form_id` int(11) not null comment '发送者id',
    `to_id`	int(11) not null comment '接受者id',
    `title`	varchar(50) not null comment '标题',
    `file`	varchar(255) not null comment '文件',
    `hasfile`	smallint(1) default '0' comment '是否有附件',
    `filename`	varchar(255) default null comment '文件原始名',
    `content`	text comment '内容',
    `addtime`	int(11) default null comment '添加时间',
    `isread`	smallint(1) default '0' comment '是否已读'
)engine=myisam auto_increment=1 default charset=utf8;
```

2. 首页导航菜单的创建. 邮件管理相关视图模板文件的移动, 静态资源路径的修改

   ![1541384364367](.\php\1541384364367.png)

3. 控制器 EmailController.class.php

   ![1541384466072](.\php\1541384466072.png)

#### 邮件发送显示及业务

控制器: 

![1541387057475](.\php\1541387057475.png)

模型:

![1541387075017](.\php\1541387075017.png)

视图:

![1541387112746](.\php\1541387112746.png)

测试发送成功, 数据库结果. 

![1541387141988](.\php\1541387141988.png)

#### 邮件发件箱功能

控制器: EmailController.class.php

![1541389441297](.\php\1541389441297.png)

模型: EmailModel.class.php

视图: sendBox.html

![1541389518064](.\php\1541389518064.png)

#### 邮件收件箱功能

控制器: EmailController.class.php

方法: inBox

模板: inBox.html

第一步: 控制器中创建方法 inBox, 作用读取数据展示模板

针对收件箱, 应该是显示发件人(from_id), 需要关联用户表(sp_user)

**主表: sp_email 	t1**

**从表: sp_user	t2**

**关联条件: t1.froom_id = t2.id**

原生 sql 语句: **select t1.*,t2.nickname as name from sp_email as t1 left join sp_user as t2 on t1.from_id = t2.id where t1.to_id = 当前用户的id**

![1541405186779](.\php\1541405186779.png)

第二步: 模板显示内容

![1541405229281](.\php\1541405229281.png)

![1541405273692](.\php\1541405273692.png)

第三步: 使用 layer 库查看邮件内容

Layer 使用步骤:

​	第一步: 引入 javascript 文件

​	第二步: 直接编写代码

![1541406326652](.\php\1541406326652.png)

![1541406292108](.\php\1541406292108.png)

控制器编写 getContent 方法

![1541406876206](.\php\1541406876206.png)

在查询的时候避免用户获取到请内容的方法, 进而后面随意更改id来获取别人的邮件, 则可以添加一个限制条件. 只能查看用户自己的邮件.

##### 设置邮件状态

在查看邮件的时候, 实现邮件状态的修改. 

第一步: 修改 getContent  方法

![1541407444450](.\php\1541407444450.png)

虽然此时可以实现数据库数据的变化, 但是页面未刷新.

第二步: 在layer关闭的时候进行刷新操作. 修改 javascript 方法

![1541407928216](.\php\1541407928216.png)

![1541407952275](.\php\1541407952275.png)

##### 实现邮件的实时提醒功能

此处需要使用到 ajax, 定时器(反复性定时器, 一次性定时器).

**原理: 在页面加载完成之后, 通过定时器不断地发送ajax请求, 来获取当前用户未读信息的数量, 拿到数量在模板中进行展示.**

第一步: 编写页面(Index/index.html)的载入事件.

第二步: 编写js代码, 发送请求

![1541409602036](.\php\1541409602036.png)

![1541409652764](.\php\1541409652764.png)

第三步: 点击链接跳转至收件箱列表

注意: 要求是**在 iframe 中打开页面, target 属性值必须是目标 iframe 的 name 值**

![1541409969109](.\php\1541409969109.png)

![1541410143310](.\php\1541410143310.png)

### 翻墙问题(绕过登录)

>  **翻墙**: 绕过 GFW (国家防火墙), 看国外一些被限制的网站.

这里的翻墙表示绕过后台登录, 直接访问后台. 是不被允许的.

正常情况下, 翻墙不被允许. 目前之所以能够直接输入地址能够看到不该看到的内容, 主要是我们在 OA 系统中还没有做登录的判断功能.

![1541395830107](.\php\1541395830107.png)

**解决方法: **

分析: 既然说缺少登录判断的功能代码, 那么就可已在固定的地方来添加判断的代码.

**方法1: 可以在每个需要的控制器中添加判断代码, 可以添加在每个控制器中的构造方法中.**

**方法2: ** 方法1 虽然是可行的, 但是代码重复性太高. **我们可以把这段固定的判断代码写在基础控制器(父类控制器)中.** 

当前 OA 系统中的控制器所使用的继承关系如下

![1541396058622](.\php\1541396058622.png)

如此, 我们应该将固定判断代码写在父类控制器中, 但是一般情况下, 我们不会修改 ThinkPHP 的源码(Controller.class.php). PHP 不允许多继承, 那么我们如何解决该问题呢?

答: 既然php不允许多继承, 那我们可以使用 **继承链(多级继承)** 方式

在使用多级继承的时候, 我们可以将一个系统中的全部控制器划分成两部分: **公共控制器**(不需要登录就可以访问: 如user控制器中的登录方法), **需要验证的控制器**(其中的内容需要登录之后才能查看).

**多级继承的实现方法**

![1541396501956](.\php\1541396501956.png)

上图显示, **需要验证登录的控制器, 继承了中间控制器(自己创建的CommonController), 在中间控制器中的构造方法中进行用户的权限判断, 好处是可以只写一次登录判断, 公共控制器, 可以直接去继承 ThinkPHP 的父类控制器, 该继承链不需要判断用户是否登录.**

#### 实现 OA 系统的防止翻墙操作

第一步: 创建中间控制器

命名说明: 除了不能使用 Empty 名字之外, 其他无要求限制. 但是一般情况下名字也是存在的一个约定俗称的名字: **Common**, 全名是 **CommonController.class.php**

![1541398594067](.\php\1541398594067.png)

第二步: 修改需要验证的控制器的继承类

**将所有的需要验证登录的控制器修改为继承 CommonController **

![1541398750466](.\php\1541398750466.png)

由于中间控制器和当前需要验证的控制器在同一个命名空间, 所以不需要引入. 且继承父类的中间控制器中已经引入了基础控制器, 所以这里也不需要再引入基础控制器了.

在基础关系处理完毕之后, 按照方法2中的描述, 我们需要在中间控制器(CommonController)中编写方法: **构造方法, 在构造方法进行判断用户是否登录**

在 ThinkPHP 中系统支持 2 个构造方法写法:

​		**__construct(): php 内置的构造方法, 在 ThinkPHP, 如果使用该方法, 则必须先构造父类**

​		**_initialize():   ThinkPHP 提供的构造方法, 不需要构造父类**

![1541400669577](.\php\1541400669577.png)

**案例实现**

![1541401362651](.\php\1541401362651.png)

在实际开发的时候, 一般会造成以下效果

![1541401424786](.\php\1541401424786.png)

之所以会有如此, 由于每次跳转都是当前页面, 也就是 iframe

**解决方法: 让最顶级的页面进行跳转**

可以通过 javascript 代码实现最顶级页面的跳转 **top.location.href** 

![1541402550420](.\php\1541402550420.png)

![1541402598276](.\php\1541402598276.png)

之所以 javascript 代码可以在浏览器中执行, 是因为输出的 javascript 代码其实就是字符串, 字符串在输出到浏览器端会被解析成 javascript 代码, 进而被浏览器执行.

### RBAC 权限分配

RBAC 全称叫做**基于用户/角色**的权限控制. 目前来说一般项目有以下两种权限管理方式: RBAC方式, 传统方式.

####　传统权限分配方式

传统的权限分配方式有一个最大特征: 将权限和用户挂钩.

![1541463685088](.\php\1541463685088.png)

由上述连线, 可以发现, 传统的权限分配方式存在以下几点不足:

​	-	效率不高

​	-	没有一个固定的权限标准

所以基于用户的权限管理方式在大型网站上一般不会使用.

#### RBAC 权限管理方式

RBAC在使用的时候有两种体现方式: 基于 **表结构** 和 基于 **文件结构**	 

两者差异就在于数据的存储位置, 前者是存储在数据表中(3表, 5表), 后者是将数据存储在文件中, 原理都是一样的.

**基于数据表的形式: 优点是在后期数据维护上方便, 有界面来操作数据表. 不易于理解**

**基于文件结构的形式: 优点在于简单容易理解, 但是缺点是不易于维护, 无界面**

RBAC 原理:

![1541464586495](.\php\1541464586495.png)

**用户登录时, 会持久化用户登录信息(如角色id), 根据角色 id 去查询该角色有什么权限. 在中间控制器中获取当前 用户访问的控制器名及方法名, 组成与预定义格式一致的形式, 来判断组成后的形式在不在权限信息中, 如果在则表示有权限访问, 否则无权限访问**.

RBAC 权限方式: 最大特点就是将权限和用户组/角色挂钩, 然后再将用户和用户组进行挂钩.

![1541466760837](.\php\1541466760837.png)

上述图示, 可以发现 RBAC 模式, 存在以下几个优点:

​	-	项目开发的初期, 权限的标准就已经做到统一

​	-	在维护层面看, 该种分配方式也比传统的权限分配方式简单.

所以在大型项目网站中, rbac 模式使用几率比传统模式要高

#### 案例: 针对OA实现RBAC管理权限

**第一步: 定义用户权限信息数据**

当前方式是基于文件的形式, 则数据需要写在文件中(应用级配置文件).

![1541469996713](.\php\1541469996713.png)

**第二步: 在指定位置根据当前用户的 role_id 来获取当前用户应该有的权限**(中间控制器的构造方法)

**第三步:通过常量方式获取当前用户访问的路由的控制器和方法名**

![1541476008149](.\php\1541476008149.png)

**第四步: 判断当前用户权限是否具有权限**

![1541476054134](.\php\1541476054134.png)



# ThinkPHP 实战开发电商项目



## 数据库(db_tp_ds)

### 分类表(ds_category)

```mysql
create table if not exists `ds_category`(
    `id` smallint(5) auto_increment primary key,
    `cname` char(50) not null default '' comment '分类名称',
    `pid` smallint(6) not null default '0' comment '分类的父id',
    `isrec` tinyint(4) not null default '0' comment '是否推荐, 0表示不推荐, 1表示推荐'
)engine=myisam auto_increment=1 DEFAULT charset=utf8;
```



## 业务逻辑实现

### 分类的添加业务及视图完成流程

第一步: 分类控制器实现分类添加视图展示及分类添加业务

![1541505637866](.\php\1541505637866.png)

第二步: 分类模型处理数据并返回数据给控制器

![1541505962770](.\php\1541505962770.png)

第三步: 分类视图显示数据

![1541506174171](.\php\1541506174171.png)

![1541506296606](.\php\1541506296606.png)

### 模板删除

控制器添加删除方法

![1541508597816](.\php\1541508597816.png)

模型处理删除方法

![1541508699405](.\php\1541508699405.png)



##　需掌握知识点

### 实现模板继承

第一步: 视图目录下创建 **Public** 目录, 用于存放公共模板视图

第二步: 复制公共模板于 Public 目录下, 并**对公共模板进行修改**

 -	**对于不变的地方保持原有不变**
 -	**对于变化的设置 block 区域: 设置 name 值, 用于模板继承替换内容**

![1541506813660](.\php\1541506813660.png)

第三步: **继承公共模板, 实现 block 区域替换内容**

![1541506968046](.\php\1541506968046.png)

### 分页类的使用

1. 定义当前每页显示数据条数
2. 计算出一共有多少条数据
3. 调用 show 方法获取分页导航数据
4. 将分页导航数据赋值给模板显示
5. 获取当前的页码
6. 获取具体的数据

![1542012238723](.\php\1542012238723.png)













## 常见问题

### I 函数解析带标签的数据直接内部转换问题

我们在使用 ueditor编辑器等 输入数据的时候, 插入到数据库中的数据一般都是携带标签的. **使用 I 函数接收数据会将带标签进行转义处理**, 为了保证用户输入数据的安全性. 也是为了保护我们服务器的安全. 然而我们在从数据库中取数据的时候, 转义数据取出时, 我们需要对其进行 **转义反处理**. 这里就使用到了一个函数 **htmlspecialchars_decode()** 即可.



## 常用函数

### 获取无限极分类(或某分类的子分类)

```php
/**
 * 递归实现无限极分类的方法
 *  @param list     列表数据
 *  @param pid      父级id
 *  @param level    属性(用于空格)
 *  @param iscache  是否重置原静态的数据
 */
function getTree($list, $pid = 0, $level = 0, $iscache = true){
    static $tree = array();
    //  如果不需要之前的数据, 则此处判断第四个参数. 重置数组数据为空
    if(!$iscache) $tree = array();
    foreach($list as $item){
        if($item['pid'] == $pid){
            $item['level'] = $level;
            $tree[] = $item;
            getTree($list, $item['id'], $level + 1);
        }
    }
    return $tree;
}
```

### 字符串处理

```php

/**  
 *	字符串截取函数
 *	开启mbstring扩展
 */
 function msubstr($str, $start=0, $length, $charset="utf-8", $suffix=true){
    if(mb_strlen($str,$charset)>$length)
    {
        if(function_exists("mb_substr")){
            if($suffix)
                return mb_substr($str, $start, $length, $charset)."...";
            else
                return mb_substr($str, $start, $length, $charset);
        }elseif(function_exists('iconv_substr')) {
            if($suffix)
                return iconv_substr($str,$start,$length,$charset)."...";
            else
                return iconv_substr($str,$start,$length,$charset);
        }
        $re['utf-8'] = "/[x01-x7f]|[xc2-xdf][x80-xbf]|[xe0-xef][x80-xbf]{2}|[xf0-xff][x80-xbf]{3}/";
        $re['gb2312'] = "/[x01-x7f]|[xb0-xf7][xa0-xfe]/";
        $re['gbk'] = "/[x01-x7f]|[x81-xfe][x40-xfe]/";
        $re['big5'] = "/[x01-x7f]|[x81-xfe]([x40-x7e]|xa1-xfe])/";
        preg_match_all($re[$charset], $str, $match);
        $slice = join("",array_slice($match[0], $start, $length));
        if($suffix) return $slice."…";
        return $slice;
    }
    else
    {
        return $str;
    }
}
```

### 根据二维数组中某字段值进行排序

```php

/**
 * 二维数组排序 function
 * @param [array] $arr
 * @param [key] $keys
 * @param string $type 排序方式, 默认升序
 * @return void 
 */
function array_sort($arr,$keys,$type='asc'){ 
    $keysvalue = $new_array = array();
    foreach ($arr as $k=>$v){
        $keysvalue[$k] = $v[$keys];
    }
    if($type == 'asc'){
        asort($keysvalue);
    }else{
        arsort($keysvalue);
    }
    reset($keysvalue);
    foreach ($keysvalue as $k=>$v){
        $new_array[$k] = $arr[$k];
    }
    return $new_array; 
}
```


# JavaScript 基础

## 历史

### web 发展史

**Mosaic** 是互联网历史上第一个获普通使用和能显示图片的网页浏览器, 于1993年问世.

**1994年4月** Netscape Navigator 浏览器问世, 11月更名 "**Netscape Communication Corporation**" , 此后沿用至今, 中译为 **"网景"**. 微软的 IE 及 Mozilla Firefox等, 早期版本皆以 Mosaic 为基础开发的.  

**Mozilla Firefox** 则是 **网景** 通讯家开放源码后所衍生出的版本.



### JavaScript 历史

**1996** 年诞生. 最初目的是改善网页的用户体验

作者: Brendan Eich

初期被命名为 **LiveScript**, 后因市场宣传更名 **JavaScript**

后 Sun 公司被 Oracle 收购, JavaScript 版权归 Oracle 所有.



### 浏览器组成

- **shell** 部分
- **内核** 部分
  - 渲染引擎 (语法规则和渲染)
  - js引擎
  - 其他模块

**js引擎**

2001年 ie6 首次实现对js引擎的优化和分离.

2008年 Google 发布最新浏览器 Chrome, 采用优化后的javascript引擎, 引擎代号V8, 能把js代码直接转化为机械码来执行, 进而以速度快而闻名.

后 Firefox 也推出了具备强大功能的js引擎

Firefox3.5 traceMonkey (对频繁执行的代码做了路径优化)

Firefox4.0 JeagerMonkey

**几大主流浏览器及其内核**

- **IE				trident**
  **Chrome	   		webkit/blink**
   **firefox			Gecko**
   **Opera			presto**
   **Safari			webkit**

------

## JavaScript 分步

- 是**解释性语言** (翻译一行, 执行一行)
- **单线程** 
- **ECMAScript 标准**

**JS执行队列**

轮转时间片: 任务切片, 随机执行时间片.

### JS三大部分

- **ECMAScript**
- **DOM**
- **BOM**

------

## ECMAScript

 **Javascript 引入**

```html
<script type="text/javascript" src="xxx.js"></script>
```

### 基础语法

#### 变量

- 变量声明
  - **声明** / **赋值** 分解
  - 单一 var 

```javascript
var a;	//变量声明
a = 100;	//变量赋值
var b = 100;	//变量声明 + 赋值
//	开发写法: 单一 var 模式
var a,
    b = 10,
    c = '哈喽c',
    d;
```

- 命名规则

  - 变量名必须以 `英文字母`   `_`    `$`  开头
  - 变量名可以包括 字母  _   $   数字 
  - 不可以使用关键字和保留字

- `var`  关键字声明的对象存在变量提升，提升范围不会超过 `script` 标

- **变量声明未赋值，如果该变量与全局已有属性命名冲突，则不会修改全局已有属性对应的值。[变量提升]**

  ```JS
  //	name 在全局（window）已存在值是一个空值 "", name 比较操蛋， 赋予什么值都会转为 字符串
  var name;	//	定义name未赋值
  console.log(name)	//	未赋值的全局已有属性不会被覆盖
  console.log(typeof name)	//	string
  ```

##### 变量作用域

```
1. 首先查看当前作用域
2. 查看当前作用域的上级有没有
3. ...直到全局作用域
```

#### 值类型(数据类型)

**原始值(不可改变的原始值: 栈内存 stack)** 

> **原始类型的变量，存放具体的值**
> 	 遵循规则：
>
> ```
>  	first in -> last out 先进最后出.
>  	栈内存之间的赋值是拷贝.
>  	重新赋值重新房间. 变量和原房间关系切断[不可改变的原始值].
>  	数据的更改, 原来的栈内存值并没有改变, 只是名归为原来的房间的号码, 值不会被清除, 只会累积下来, 直至内存沾满之后从头开始, 覆盖名为房间号的值
> ```

- **number**
- **boolean** （true，false）
- **string**
- **undefined**
  - 一个变量被声明但是未赋值即 undefined 类型的值
  - 一个变量声明了但是被赋值了 undefined
  - 一个对象中, 不存在的属性的值也是 undefined
- **null**

**引用值(栈：指针，堆：内容)**

> **引用类型的变量， 栈内存存储引用地址的指针， 开辟的堆内存中存储内容**
>
> 遵循规则：
>
> ```
> 引用值之间的赋值是复制栈内存中引用地址的指针, 地址指向堆内存中的房间. 
> 
> 引用值之间的赋值是指针的形式，赋值指针
> 
> 一个新的引用值等于开一个新的房间, 栈内存中的存储地址指向该新房间.
> 
> 凡是出现引用值(对象字面量)，都会在堆内存中生成一个新的引用空间。
> ```

- **Array**   []
- **Object**  {}
- **function**
- **Date**
- **正则**

**js 中的垃圾回收机制**

> js 垃圾回收器，会定期发现内存中无法访问的对象[垃圾]，垃圾回收器在合适的时间将其占用地内存释放

#### 语法的基本规则

- 语句后面用分号结束 `;` 

- js语法错误会引发后续代码终止, 但不会影响其它代码块

  ```html
  <script>
  	console.log(b);
  </script>
  <script>
      var a = 5; 
      console.log(a);
  </script>
  
  //Uncaught ReferenceError: b is not defined
  //5
  ```

- 书写格式规范

#### JS运算符（操作符）

##### 算术运算符

- `+` 
  - 数学运算
  - 字符串连接(任何和字符串执行+号运算的结果就是字符串)
- `-`   `*`    `/`   `%`  `**`

> **细节**
>
> js 中数值运算不精确。如5.2-5.1
>
> 除数为0， 被除数是正数得到正无穷 Infinity，负数得到 -Infinity， 被除数是0，得到 NaN
>
> 求余结果正负只跟被除数有关系，与除数无关。如 10/-3   ==> 1    -10/-3 ==> -1

> **其它类型使用算术运算符**
>
> 1. 除加号之外的
>
> 将原始类型转为数字类型，再运算
>
> boolean： true  -- 1  false -- 0
>
> string：内部是正确数字，直接变为数字。非数字则为 NaN（能识别Infinity，不能把字符串内部东西当作表达式, 如果字符串是一个空字符串，转换为0. 字符串转换时会忽略前后空格)
>
> null： 0
>
> undefined: NaN
>
> 对象： 先将对象转为字符串格式 "[object Object]", 再转为数字。 使用算术运算符，结果NaN
>
> 2. 是加号运算符
>
> 一边有字符串，表是字符串拼接。 将另一边的其它类型转为字符串
>
> ```
> 数字， 直接转为数字字符串
> 
> 布尔， 布尔字符串
> ```
>
> 加号一边没有字符串，另一边有对象。 先将对象转为字符串，按照字符串拼接。 

**练习题**

```js
console.log(1 + 2 * 3)	//	7
console.log(1 + 3 % 2)	//	2
console.log("" + 3 % 2) //	"1"
console.log(+"" + 3 % 2)	//	0 + 1 -> 1
console.log(+{} + "")	//	+"[object Object]" + ""	-> NaN + "" -> "NaN"
console.log(100 % 4 /0)	//	0 / 0 -> NaN
console.log(null / null) // 0 / 0 -> NaN
var a;
console.log(a + {} + 124)	//	undefined + "[object Object]" + 123 -> undeinfed[object Object]123
console.log(1 + "" + 2 + 3) // "123"
console.log({} * null)	//	"[object Object]" * 0 -> NaN * 0 -> NaN
console.log(+"" + 100)	//	0 + 100 -> 100

//	温度转换器 （设置变量保存摄氏温度C,转为华氏温度F：F = (9/5)C + 32）
var fFunc = c => (9 / 5) * c + 32;
//	利息计算器 （设置变量，分别保存本金，月数，年利率，计算利息）
var rateFunc = (money, month, rate) => money * (rate / 100 / 12) * month;
```

**优先级**

赋值的顺序: 自右向左

计算的顺序: 自左向右, 优先级不同特殊处理

> **细节**
>
> 自增子减表达式
>
> x++: 将变量x自增1，得到的表达式的值是自增之前的值 x = 0; console.log(x++) 0
>
> ++x: 将变量x自增1，得到的表达式的值是自增之后的值 x = 0; console.log(++x) 1 
>
> **优先级运算细节***
>
> ```
> 从左到右依次查看, 遇到括号算括号里面
> 
> 如果遇到操作数将数据的值取出
> 
> 如果遇到相邻两个运算符，并且左侧运算优先级大于等于右侧运算符，则直接运行左边的运算符
> ```

**练习**

```JS
var a = 1；
console.log(1 + a++ * ++a)

var b = 1;
console.log(b + b++ + ++b + b*3 * ++b)

var c = 1；
consle.log(c * (c++ + ++c) - c++ -++c / ++c * c++)
```

##### 比较运算符

`>=` `==` `===`

> 返回值 boolean
>
> 优先级小于算术运算符
>
> **细节**
>
> 1. 两个字符串比较比较的是字符编码
>
> 2. 其中一个不是字符串并且两个都是原始类型，将他们都转换为数字进行比较
>
>    NaN与任何数字比较，得到结果都是 false, 包括自身
>
>    无穷大比任何数字都大，负无穷大比任何数字都小
>
>    undefined 和 null
>
>    ```
>    undefined -> NaN
>    
>    null -> 0
>    ```
>
> 3. 其中一个是对象，将对象转为原始类型（"[object Object]"）。
>
> 4. 两个对象比较，比较指针地址

```JS
console.log("11" > "2")	//	false
console.log("11" > 2)	//	true
console.log("wft" > 0) //	false
console.log(undefined > 0) 	//	NaN > 0 ==》 false
console.log(null > 0) // 0 > 0 ==》 false
console.log({} > 0) //	"[objet Object]" > 0 ==》 NaN > 0 ==》 false
console.log(null == undefined) // true
console.log(null === undefined) // false
console.log(null >= 0) //	true
console.log(null == 0) //	false
```

##### 逻辑运算符

`&&`  `||`  `!`

- 针对非布尔值

```javascript
/* &&运算符 */	
//	先看运算符前面的表达式转化为布尔值是否为真, 如果为真, 看第二个表达式转化为布尔值的结果. (以此规矩往下走, 遇假就停, 返回该值)
var a = 1 && 2 && 0 && 5;	//	0
//	如果只有两个表达式的话. 表达式1为真, 返回表达式2. 表达式1为假, 返回表达式1. (遇假就停)
var a = 0 && 5	//	0
//	短路语句的运用
data && fn(data);

/* ||运算符 */	
//	如果是真就返回该值.(遇真就停)
var a = 0 || false || 5	//	5
```

- 针对布尔值判断(if)

```javascript
/*	&& 全真才真	*/
var a = 1 && 5 && 2 && '前端' && 0;	//	false
/*	|| 全假才假	*/
var a = 0 || false || '' || 1 	//	true
/*	! 先转布尔值再取反 -> 结果为布尔值	*/
var a = !520	//	false
```

**运用**

```JS
var x = 1;
console.log(x++ >= 1 && x++ >= 2 && x++ >=3 && x++ >=5 || (x = 5)); //	5
console.log(x++ >= 1 && x++ >= 2 && x++ >=3 && ++x >=5 && (x = 520));	//	520
```

##### 三目运算符

`表达式一 ? 表达式二 : 表达式三`

```js
var x = 2;
x = x++ >= 3 ? x++ * ++x - x++ / --x : x++;

```

##### 一元运算符 void | typeof

> void(1+2) 运行表达式, 返回 undefined (void 1+2 NaN)
>
> typeof(1+3) 运行表达式, 返回表达式结果类型

##### 逗号运算符

> 依次运行表达式, 返回后面表达式结果
>
> 1+2, 2+3, 3+4, 4+5
>
> 逗号运算符优先级比赋值运算符还低



#### 数字的存储[拓展]

##### 问题

- JS 中小数运算精确的吗
- JS 中整数运算精确的吗
- JS 中表示的整数是连续吗
- JS 中表示最大的数字是多少
- JS 中能表示的有效位数是多少

```JS
//	小数运算不一定精确
console.log(0.2 + 0.1)	//	0.30000000000000004
console.log(0.5 + 0.5)	//	1
# 当 js 数值很大的时候会出现以下情况
//	整数运算不一定精确
//	表示的整数不一定连续

//	最大数字(连续整数)
Number.MAX_SAFE_INTEGER	//	9007199254740991	
//	有效位数 16 ~ 17

```

##### 原因

> **二进制**
>
> ```
> 现实世界中: 十进制, 逢10进1
> 
> 计算机世界: 二进制, 逢2进1
> 
> ```

**二进制转十进制**
$$
二进制 1011 转十进制数:  1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 结果为 11
$$

$$
二进制 10.11 转十进制数: 1*2^1 + 0*2^0 + 1*2^{-1} + 1*2^{-2} 结果为 2.75
$$

**十进制转二进制**

```JS
11 / 2	商 5 余 1
5  / 2  商 2 余 1
2  / 2  商 1 余 0
1  / 2  商 0 余 1
//	--》  倒序查看即得 1011

# 小数二进制 2.75
//	整数部分相同
2.75
2 / 2 商 1 余 0
1 / 2 商 0 余 1
//	商0为止--》倒序查看 10
0.75 * 2 小数部分 0.5
0.5 * 2  小数部分 0
//	小数部分0为止--》正序查看 11
//	-- 整数+小鼠 10.11

```

**为什么JS小数运算不准确?**

> **因为十进制转二进制可能会进入无限状态**

```js
//	以 0.3 举例 
0.3 * 2  0.6  0
0.6 * 2  1.2  1
0.2 * 2  0.4  0
0.4 * 2  0.8  0
0.8 * 2  1.6  1
0.6 * 2  1.2  1
0.2 * 2  0.4  0
0.4 * 2  0.8  0
//	得出结果是进入了一个无线循环的过程, 省却后面的数据
所以结果是 0.01001100......
//	(0.3).toString(2) => "0.010011001100110011001100110011001100110011001100110011"

```

**计算机中整数和浮点数的存储都以浮点方式**

```js
#	[第一段][第二段][第三段]
//	第一段只有一位表示符号 0表示正  1表示负
//	第二段有 11 位表示整数部分
//	第三段 52 位表示小数部分

# 特殊值存储
0 11111111111 000..	//	Infinity(2*1024)
1 11111111111 000..	//	-Infinity
1 11111111111 023.. //  NaN
0 11111111111 023.. //  NaN
//	正常数字第二段部分最多取到2046

```

**能表示的最大数字**

```js
0 11111111110 111...
//	Number.MAX_VALUE
//	1.7976931348623157e+308
1 11111111110 111...
//	Number.MIN_VALUE
//	5e-324

```

**能表示的最大有效安全整数**

```JS
2**53 -1
//	Number.MAX_SAFE_INTEGER
//	9007199254740991

```

#### 位运算[拓展]

> 将一个整数的二进制格式进行运算
>
> **在 js 中，如果对一个数据进行位运算，它首先会将其转换为整数（小数省略），并且按照 32 为整数制排列**
>
> 举例： 2.7 =》2 =》 0000 0000 0000 0000 0000 0000 0000 0010
>
> (Infinity, -Infiinity, NaN 全部作0处理)

##### 与运算

> 整数1 & 整数2
>
> 两个整数每一位进行比较， 都为一，结果1，否则结果0

```JS
//	8 & 5
0000 0000 0000 0000 0000 0000 0000 1000
0000 0000 0000 0000 0000 0000 0000 0101
0000 0000 0000 0000 0000 0000 0000 0000	//	输出 0

```

##### 或运算

> 整数1 | 整数2
>
> 两个整数每一位进行比较, 都为0, 结果为0, 否则结果为1

```JS
//	8 | 5
0000 0000 0000 0000 0000 0000 0000 1000
0000 0000 0000 0000 0000 0000 0000 0101
0000 0000 0000 0000 0000 0000 0000 1101	//	输出 13

```

##### 否(非)运算

> ~整数
>
> 将整数按位取反(快速运算: - 数 -1)

JS中最快取整方式:  `~~数值`

```JS
~~2.88 // -2 -1 => 3 - 1 => 2

```

##### 异或运算

> 数1 ^ 数2
>
> 将数1和数2按位比较, 不同取1, 相同取0

```js
//	8 ^ 5
0000 0000 0000 0000 0000 0000 0000 1000
0000 0000 0000 0000 0000 0000 0000 0101
0000 0000 0000 0000 0000 0000 0000 1101	//	13
//	交换数值变量值
var a = 1, b = 2;
//	01, 10
a = a ^ b;	// 	a = 11
//	11, 10
b = a ^ b;	//  b = 01	--> 1
//	11, 01
a = a ^ b; //  a = 10	--> 2

```

**应用场景: 开关叠加**

```JS
# 权限控制 read write create
var power = {
    read:  0b001,	//	读
    write: 0b010,	//	写
    create:0b100	//	创建
}
//	用户b保存可读可写权限
var p = power.read | power.write;	//	p = 0b011
//	去掉可读权限
p = p | power.read ^ power.read;	//	p = 0b010
//	判断p是否有可读权限
p & power.read === power.read? console.log('可读') : console.log('不可读')

```

##### 位移运算

> 左位移 <<   
>
> ```
> 数字1 << 数字2
> 
> 	将数字1的二进制(除符号位外) 左移数字2次数
> 
> 	结果: 数字1 * 2 ^ 数字2
> 
> ```
>
> 右位移 >>
>
> ```
> 数字1 >> 数字2
> 
> 	将数字1的二进制(符号除外)右移数字2次数
> 
> ```
>
> 全右位移 >>>

##### 求余和求模

> **%**(js中的求余) 
>
> 求余: 求余的值的符号与被除数相同 公式 **x - n * y** (n 是 x / y 取整(向0取整))
>
> 求模(js中没有求模) 求模的符号与出书相同 公式 **x - n * y** (n 是 x / y 取整(向下取整))
>
> **所以说: 在值为正数时, 求余和求模没有区别, 在值为负数是, 重点是 n 的取值**

```JS
//	7 % 3 或 -7 % -3 时，值为正数。此时求余和求模的值是相同的
7 % 3 = 7 - ~~(7/3) * 3 = 1
//	当值为负数时， 求余的值与被除数相同， 而求模的值与除数相同
7 % -3 = 7 - ~~(7/(-3)) * (-3) =  7 - (-2)*(-3) = 1
//	求模伪代码和结果如下
7 % -3 = 7 - (7/(-3))【向下取整 -2.33 -> -3】 * (-3) = 7 - (-3) * (-3) = -2
```

### 流程控制

#### typora流程图绘制指南

```sequence
小白->大神: Hello 大神, how are you?
note right of 大神: 小白,thinks
大神->小白: I am fine, thinks
note left of 小白: ohmygod
小白-->二代神: and you?
note right of 二代神: 真暖
二代神-->小白: 很好谢谢
```

```FLOW
st=>start: 小白逻辑
ed=>end: 结束
cond=>condition: 有看到卖西瓜的车吗?
op=>operation: 买两个桃子
op2=>operation: 买西瓜
st->cond
cond(yes)->op2->ed
cond(no)->op->ed
```

#### 条件语句

**if语句**

> **一个if语句**
>
> 1. 如果某个条件满足，则直接忽略后面的所有条件
> 2. else if 可以有多个（包括0个）
> 3. else 可以有一个或0个
> 4. else 可以换行编写
> 5. if只能出现一次
> 6. 代码块只有一行，花括号可以省略

```javascript
if (条件) {	//	条件为真, 执行code 
    code...
} else if(条件2) {	//	条件2满足执行   
    code2..   
} else {	//	条件为其它, 执行code3
	code3...
}
```

**练习**

```js
if(!x){
    x = 0; 
}
if(x++ >= 1){
    var x;
    x++;
}else if(++x >=2){
    x++;
}else{
    x--;
}
console.log(x)	//	3
```

**作业练习**

```JS
# 1.提示用户输入一个三位数，不是三位数，提示输入有误。是三位数，判断能否被13整除
# 2.让用户输入一个成绩（0-100），判断该成绩所属范围并输出结果（a:90-100/b:70-89/c:60-69/d:40-59/e:0-39），若输入的不是0-100的数字，输出输入有误
# 3.根据世界卫生组织推荐的计算方法
	# 男性标准体重计算方法（身高cm - 80）× 70%
    # 女性标准体重计算方法（身高cm - 70）× 60%
    # 标准体重正负 10% 为正常体重，低于标准体重 10%为瘦，高于标准体重10%为胖
    # 编写程序让用户输入性别，身高，体重判断健康状况
    	# 体重正常，继续保持
        # 体重偏胖，加强锻炼
        # 体重偏瘦，补充营养
var height = +prompt('输入身高（cm）'),
    weight = +prompt('输入体重（kg）'),
    gender = prompt('输入性别（男|女）');
if(isNaN(height) || isNaN(weight) || (gender !=='男' && gender !=='女')) {
	console.log('输入有误');
}else{
    var standardWeight;
    if(gender === '男') {
        standarWeight = (height - 80) * 0.7;
    }else {
        standarWeight = (height - 70) * 0.6;
    }
    if(weight < standarWeight * 0.9) {
        console.log('体重偏瘦，补充营养')
    }else if (weight > standarWeight * 1.1) {
        console.log('体重偏胖，加强锻炼')
    }else{
        console.log('体重正常，继续保持')
    }
}
# 4.某理财公司推出一种理财服务，服务规则如下
	# 用户理财金额在五十万以下，每年收益按4% 计算
    # 用户理财金额在五十万以上（包括五十万），每年按 4.5%计算
    # 若用户理财金额超过200万，除了理财收益以外，还要额外给予用户收益金额的10%
    # 编写程序，让用户输入理财金额和理财年限，计算到期后的收益
# 5.编写石头剪刀布游戏，用户输入单个数值123，分别代表石头剪刀布(其他数值默认判定用户出错，判定用户输)，跟电脑对比判断胜负
var fist = prompt('请出拳（剪刀/石头/布）');
if(fist === '剪刀' || fist === '石头' || fist === '布') {
    //	1.模拟电脑出拳
    var pcFist,
        rd = Math.random();
    if(rd < 0.3333) {
        pcFist = "剪刀"
    }else if(rd < 0.6666) {
        pcFist = "石头"
    }else {
        pcFist = "布"
    }
    //	2.比较胜负
    console.log('你出拳：' + fist + ' 电脑出拳： ' + pcFist)
    if((fist === '剪刀' && pcFist === '布') || (fist === '石头' && pcFist === "剪刀") || (fist === "布" && pcFist === "石头")) {
        cosnole.log('你赢了！')
    }else if(fist === pcFist) {
        console.log('平局！')
    }else {
    	console.log('你输了！')
    }
}else {
    console.log('输入有误')
}
```



`switch` 执行全真判断所选if语句另外一种形式

```javascript
switch(变量){
    case '条件1':    //	 条件1 === 变量, 执行code1代码
        //code1..
        break;		//    如果符合, 隔断语句往后执行 break 关键字
    case '条件2':
        //code2..
        break;
    case '条件3':
        //code3..
        break;
    default:		//	 其它值的处理
        //code4..
        break;
}
//	极其不负责任, 没有break的情况下. 也执行之后的代码
```

#### 循环语句

`for(){}` 语句

```javascript
for (var a=1; a < 100; a++) {
    console.log(a);
}
//	

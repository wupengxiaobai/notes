# PHP基础

**简介**

**运行在服务器端的 HTML 脚本语言, 用来书写动态生成的网页.**

## 环境搭建

### 静态网站和动态网站

**静态网站:** 

​	内容固定, 实实在在保存在服务器上的文件, 内容相对稳定, 没有数据库支持, 交互性较差.

**动态网站:**

​	交互性强烈, 自动更新, 因时因人而变. 将 html 写死, 请求动态数据.

### 网站基本概念

**服务器 :** 能够提供服务的机器. 取决于机器上所安装的软件(服务软件). 比如 Web服务器 提供Web服务 (网站访问), 需要安装 Web 服务软件, Apache, tomcat, lls等.

**IP :**  Internet Protocol 网络之间互联协议. IP 地址具有唯一性. (每台电脑都有一个唯一的IP地址)

**域名 :**  某一台计算机或计算机组的名称, 用于在数据传输时标识计算机的电子方位(有时候也指地理位置, 地理上的域名, 指代有政自主权的一个地方的区域). 域名是 一个 IP 地址的 "面具"

**DNS : ** 因特网上作为域名和ip地址相互映射的分布式数据库,能够使用户更方便访问互联网. 通过主机名, 最终的得到该主机名对应的 IP 地址的过程叫做 域名解析(主机名解析)

`用户输入域名localhost`  - `DMS(localhost 127.0.0.1)`  -  `服务器电脑`

**端口 : ** 设备与外界通讯交流的出口. 分为虚拟端口和物理端口. 其中虚拟端口指计算机内部或交换机路由器内的端口, 不可见. 比如 计算机中的 80端口, 21端口等

`用户名输入域名 localhost:端口号`  - `DNS (localhost 127.0.0.1)`  - `服务器电脑` - `软件(服务)`

### Web 程序的访问流程

`浏览器发起访问` - `DNS 解析域名` - `服务器电脑` - `服务软件`

![52707661056](.\php\1527076610562.png)

**静态网站的访问**

![53392665702](.\php\1533926657024.png)

**动态网站的访问**

与静态访问流程差不多, 会多出 **服务端解析** **数据库**

![53392706188](.\php\1533927061880.png)

### Apache 安装和配置

> 下载地址: 	https://www.apachelounge.com/download/

**安装配置**

**目录结构说明**

```
- bin  		windows习的一些可执行文件
	+	httpd.exe 服务器进程(运行后才能工作)
- conf		配置文件目录
	+	httpd.conf 主配置文件
	+	extra 子配置文件
- htdocs	Apache默认主机地址(网站对应根目录)
- modules	Apache功能模块
```

![53393897615](.\php\1533938976150.png)

1. 服务器进程: 运行之后 Apache 才能正常工作
2. 用来查看 Apache 具有功能及配置文件是否有错
   - 查看使用模块 `httpd.exe -M` (static 静态加载  shared 动态加载)
   - 验证**配置文件是否有效 `httpd -t`**

**配置默认站点**

1. 让 Apache 确定服务器上访问位置: 网站所在文件夹

   - **Httpd.conf 配置 DocumentRoot**

2. 方便用户使用名字访问对应网站

   - **Httpd.conf 配置 ServerName**
   - 端口可以单独实现 httpd.conf 配置 listen

   ![52707682488](.\php\1527077059773.png)

3. 凡是涉及到 Apache 配置文件的修改, 需要重启 Apache 才能生效

4. 实现 DNS 域名解析: 通常默认站点都是本地DNS hosts文件 **管理员权限**

   修改 C:\Windows\System32\drivers\etc下的 hosts文件, 添加项, Apache就可以正常访问

   ![52695573913](.\php\1526955739134.png)

### PHP 安装和配置

**php目录结构**

![53395349762](.\php\1533953497629.png)

**php.exe** 就是可以**解析 PHP 代码**变成 **HTML 代码**从而让浏览器可以解析

1. 通过 cmd 控制器进入到 php.exe 所在目录
2. 通过 php.exe 运行命令来指定要解析的 php 脚本就即可 : `php.exe -f PHP文件所在路径`

![53395423058](.\php\1533954230582.png)

### 配置 Apache 加载 PHP

1.  Apache 加载 PHP. 目标: 在 **Apache 的主配置中加载对应的  php 提供的模块**

![53395474211](.\php\1533954742110.png)

**验证是否加载模块成功** (D:\httpd\httpd-2.4.33-win64-VC15\Apache24\bin)

![53395504424](.\php\1533955044249.png)

2. **Apache 分配工作给 PHP 模块**: 如果是php代码就交给 PHP 处理(通过判断后缀是否是 .php)

![53395541082](.\php\1533955410821.png)

3. **将 php 配置文件 加载到 Apache 配置文件中**: **共同生效**

   3.1	在 Apache 中指定 PHP 配置文件的所在路径

![53395577541](.\php\1533955775413.png)

​	3.2  php.ini 文件默认是不存在的, 是以 development 和 production 格式存在, 需要格式化, 一般我们复制    `development` 改名为 `php.ini`

![53395597172](.\php\1533955971726.png)

说明 : php 已经加入到 Apache 的配置中, 意味着 php.ini 修改需要重启 Apache 才可以生效

### 安装与配置 MySQL

**安装配置** (非解压版)

1. 获取 MySQL 安装软件
2. 双击安装
3. 选择 custom 自定义安装: 选择安装路径
   1. 软件安装目录 D:/mysql
   2. 数据安装目录 D:/mysql/data
4. 完成安装后, 要作相关配置

**目录结构说明**

![53395761563](.\php\1533957615638.png)

**bin 目录的常用命令**

![53395797229](.\php\1533957972295.png)

**拓展** 软件的设计结构: **C/S** 和 **B/S**

1. C/S: Client客户端和/Server服务端, 用户需要安装客户单产品才能访问服务器, 而且只能访问一种软件 (当前自己)
2. B/S: Browser 浏览器/Server服务端, 用户只要安装浏览器就可以访问所有服务器(支持B/S架构服务)

### **MySQL 访问流程**

Msql 是一款 C/S 结构的软件, 需要通过客户端进行访问服务端(也可以通过一些其它插件扩展来访问)

1. 启用 MySQL 客户端:  mysql.exe 该软件本身可以通过 cmd 控制台进行
2. **通过 cmd 运行** `mysql -uxxx -pxxx`

MySQL 客户端访问服务端需要机械能匹配: 认证连接

连接: IP 和端口确认

`-h 主机地址` -hlocalhost(如果是在本机可省略)

`-P 端口`  -p3306(如果是在本机可省略)

认证: 通过用户名和密码进入服务器

`-u 用户名` -uroot 不可以省略

`-p 密码` -pwoaiwo 不可以省略

注意: 通常连接认证的时候 密码不建议明文. 可以输入 `-u root -p` 回车 之后再输入密码

### PHP 加载MySQL 扩展

php本身不具备操作 MySQL 数据库能力, 需要 **配置mysqli.dll**

1. 加载mysql扩展: php.ini 文件中(去掉 ; 注释)

![52698557208](.\php\1533960073870.png)

2. 增加扩展路径

![53396238710](.\php\1533962387109.png)

**`phpinfo()` 函数可以检测配置扩展函数是否生效**



### 配置虚拟主机

一台服务器很贵, 如果只能部署一个网站, 非常浪费. 所以需要通过其他渠道实现一个主机部署多个网站.

**什么是虚拟主机**

虚拟主机: Virtual machine, 并不存在真实的主机, 但是可以提供真实主机实现功能.

通俗讲, 虚拟主机是将计算机中不同的文件夹进行不同的命名, 然后可以实现让服务器 (Apache) 根据用户的需求不同从不同文件夹 (网站) 中读取不同的内容.

**虚拟主机的分类**

在 Apache 中, 可以将虚拟主机划分成两类:

1. 基于 IP 的虚拟主机: 一台电脑上有多个 ip, 每个 ip 对应一个网站

原理: 电脑默认只有一个 IP, 因为通常支配有一个网卡; 但是电脑 (服务器居多) 可以配置多个网卡, 每个网卡都可以绑定一个 ip 地址.

2. 基于域名的虚拟主机: 一台电脑上只有一个 IP, 但是 IP 下可以制作多个网站, 但是需要给每个网站不同的名字 (虚拟主机名)

### 搭建基于域名的虚拟主机

在 Apache 中, 虚拟主机的搭建有两种方式:

1. **在主配置文件中配置: 需要手动按开启虚拟主机(基于域名) NameVirtualHost *:80**

2. **在专门的虚拟主机配置文件中配置**

   1. 在主配置文件中加载虚拟主机配置文件: 虚拟主机配置文件已经开启了 NameVirtualHost

   ![53396366427](.\php\1533963664275.png)

   2. 在虚拟主机配置文件中配置虚拟主机 (D:\httpd\httpd-2.4.33-win64-VC15\Apache24\conf\extra)

      1. 增加一个队友的站点文件夹位置: DocumentRoot
      2. 增加主机名字: 文件夹的别名 ServerName
      3. 增加域名解析 DNS : hosts (C:\Windows\System32\drivers\etc)

      ![53396614701](.\php\1533966147010.png)

      4. 给设定的站点设定访问权限 Directory
      5. 配置访问列表: 当访问是一个目录的时候 (没有指定要访问的文件) `Options FollowSymLinks`
      6. 当用户访问指定目录下不指定文件的时候, 通常需要系统指定默认文件 `DirectoryIndex` ,  空格分离多个默认

   ![53396686344](.\php\1533966863444.png)

**注意: 如果说网站中整个网站目录允许访问, 但是其中还有其他文件不允许访问, 可以增加多个 Directory 标签, 针对不同文件夹**

3. **一旦启用虚拟主机配置文件, 默认的主机地址 localhost 就不再生效. 如果想要生效, 只有一种解决方法, 为 localhost 增加单独的虚拟主机**

```
<VirtualHost *:80>
	# 这一台虚拟主机的根目录
	DocumentRoot "D:\httpd\httpd-2.4.33-win64-VC15\Apache24\htdocs"
	# 增加主机名
	ServerName localhost
	# 配置访问权限
	<Directory "D:\httpd\httpd-2.4.33-win64-VC15\Apache24\htdocs">
		#	开启 目录结构浏览 和 链接目录访问(开发环境)
		Options FollowSymLinks
		#	不允许目录内	.htaccess  文件覆盖此处配置
		AllowOverride None
		#	允许所有人访问该目录
		Require all granted
	</Directory>
</VirtualHost>
```

---

**在主配置文件下配置相关**

![52707688154](.\php\1527076881544.png)

![52707690271](.\php\1527076902716.png)

**默认加载首页**

![52726041632](.\php\1527260416324.png)

- 找到Apache主机配置文件 

```makefile
# 配置一个虚拟主机 *:80 指的是绑定任意当前机器 IP 的 80 端口
# 如果这里指定特殊的端口， 一定要确保这个端口被 Apache 监听
<VirtualHost *:80>
	#	这一台虚拟主机的根目录
	DocumentRoot "E:/WWW/baixiu-pages"
	<Directory "E:/WWW/baixiu-pages">
		#	开启 目录结构浏览 和 链接目录访问	*******  开发的时候开启 Indexes 关闭删掉该字段即可
		Options Indexes FollowSymLinks	
		#	不允许目录内	.htaccess  文件覆盖此处配置
		AllowOverride None
		#	允许所有人访问该目录
		Require all granted
		# 	指定默认访问文件
		DirectoryIndex index.html index.php
	</Directory>
	#	这一台虚拟主机的域名
	ServerName baixiu-pages.io
	#	这一台虚拟主机的错误日志文件
	ErrorLog "logs/baixiu-pages.io-error.log"
	#	这一台虚拟主机的访问日志文件
	CustomLog "logs/baixiu-pages.io-access.log" common
</VirtualHost>
```



### Apache 和 PHP

> ​	Apache 是根据文件的扩展名找到文件的类型, 然后逐个提问每个模块能否处理这个类型的文件, 如果这些模块都不能处理, 那么Apache 就自己处理, (按照静态文件的方式处理)

![52708072118](.\php\1527080721185.png)

### PHP 温馨报错

![52698695445](.\php\1526986954459.png)

**修改php.ini配置即可, 或者直接在函数之前添加@**

![52698686014](.\php\1526986860141.png)

### 配置扩展程序 (php_mbstring.dll)

- 复制一份php.ini-development 并且改名为php.ini


- 打开 php.ini 找到 extension_dir 添加以下配置

![52698520459](.\php\1526985204594.png)

- 找到使用字符串拓展配置, 解开注释.使用字符串扩展程序

![52698534754](.\php\1526985347540.png)

- 默认Apache加载 php.ini 是去 C:/windows目录找的 ; 可以尝试移动 php.ini 位置来解决
- 也可以通过 Apache 的配置文件修改默认的加载路径 PHPIniDir  


### 在cmd中使用快速使用 php 输出命令

- 打开 cmd 命令找到php所在目录文件
- 运行 php -a

------

## 起步走

> 超文本标记是用普通文本描述富文本的一种方式
>
> **php无外乎就是为了可以在网页中动态输最新的内容的一种技术手段**

### php 标记

在PHP 历史发展中, 可以使用多种标记来区分 (php.ini配置不同标记开启)

![53398065940](.\php\1533980659400.png)

ASP 标记: `<% php 代码%>`

短标记: `<?Php 代码 ?>` , 以上两种基本弃用

脚本标记: `<script language="php">php代码</script>` 

**标准标记 (常用): `<?php php代码?>`**

**只有处于 PHP 标记内部的代码,才是php代码, php标记以外的都原封不动**

**省略结束标记**

如果 PHP 文件只是写php代码, 代码段处于整个文件的末尾, 建议(必须) 删除结束标记, 这样可以避免额外的空行产生的现象



### 输出内容方式

a. `echo ` 支持多个数据

```php
echo 'value','value2';
```

b. `print`  只支持一个数据

```php
print 'value';
```

c. `var_dump()` 一般用于调试, 输出数据以及数据类型

```php
var_dump(array('1','2'))
```

### 与 html 混编

- 普通嵌入

  ```php
  <p><?php echo 'hello'; ?></p>
  ```

- 语句混编 (指令式方式)

  ```php
  <?php if ($age >= 18) { ?>
      <p>成年人</p>
  <?php } else { ?>
      <p>小朋友</p>
  <?php } ?>
  ```

  更加常见的用法

  ```php
  <?php if ($age >= 18): ?>
      <p>成年人</p>
  <?php else: ?>
      <p>小朋友</p>
  <?php endif ?>
  ```

### 注释

单行: `//` 

在脚本开始前; 会对脚本功能进行简单阐述

注释的内容会在PHP解析的过程中忽略

多行: `/**/`

```php
//	筷箸史
/*
 * @功能说明: 注释说明
 * @作者: xxx
 * @版本
*/
```

### 错误处理

错误处理: 指的是系统(或用户), 在对某些代码进行执行的时候, 发现有错误, 就会通过错误处理的方式告知程序员. 完成 `BUG` 的修改

####  错误分类

1. 语法错误: 用户书写的代码不符合 PHP 语法规范(导致代码在编译的过程不通过) **Parse error**
2. 运行错误: 代码编译通过, 但是在执行过程中会出现一些条件不满足错误 **runtime error**
3. 逻辑错误: 在写代码的时候不规范, 出现了一些逻辑性的错误, 以至代码虽正常执行, 但是得不到想要的结果.

```php
$a = 10;
if($a = 1){
    //	执行
}
// 	如此逻辑性错误, 真的想找都找不到
```



#### 错误代号

所有看到的错误代码 , 在 PHP 中都被定义为系统常量, 我们可以直接使用

1. 系统错误: 

   1.  E_ERROR: fatal error, 致命错误. 会导致代码不能继续执行
   2. E_WARNING: warning. 警告错误. 不会影响代码执行, 可能得到意想不到的结果跑
   3. E_NOTICE: notice, 通知错误. 不会影响代码执行, 会影响美观
   4. E_PARSE: 编译错误, 代码不执行

2. 用户错误: 

   用户在使用自定义错误触发的时候, 会使用到的错误代码

   1. E_USER_ERROR
   2. E_USER_WARNING
   3.  E_USER_NOTICE

3. 其它 E_ALL, 代表所有所处(通常在进行错误控制的时候使用较多), 建议在开发过程(开发环境)中使用.

所有以 E 开头的错误常量(代号) 其实都是由一个字节存储, 然后每一种错误占据一个对应的位, 如果想进行一些错误的控制, 可以使用位运算符进行操作.

排除通知级别错误 notice: E_ALL & ~E_NOTICE

只要 警告和通知: E_WARNING | E_NOTICE

#### 错误触发

程序运行时触发: 系统自动根据错误发生后, 对应错误信. 输出送给用户. (代码语法错误和运行时错误)

人为触发: 知道某些逻辑可能会出错, 而使用判断代码来触发响应的错误提示.

**Trigger_error('错误提示内容', 错误代号)** 

![53420877309](.\php\1534208773099.png)

#### 错误显示设置

错误显示设置:哪些错误该显示, 以及该如何显示

在 PHP 中, 其实有两种方式来设置当前脚本的错误处理

1. PHP 的配置文件: 全局配置: php.ini 文件

![53421731307](.\php\1534217313071.png)

2. 在 php 脚本中设置: 在脚本中定义的配置项级别比配置文件高 (**通常在开发中都会在代码中去进行控制和配置**)

`Error_reporting()`: 设置对应的错误显示级别

`Ini_set('配置文件中的配置项', 配置值)`: 

​	Ini_set('error_reporting', E_ALL);

​	Ini_set('display_errors', 1);

#### 错误日志设置

在实际生产环境中, 不会直接让错误赤裸裸的展示

1. 不友好
2. 不安全: 错误会暴露网站很多信息(路径. 文件)

所以在生产环境中, 一般不显示错误(错误也比较少),  但是不可能避免会出现错误(测试的时候不会发现所有的问题), 这个时候不希望看到, 但是又希望可以捕捉到可以让后台程序员去修改: 需要保存到日志文件中, **需要在 php 配置文件 或者代码中 (ini_set) 设置对应的 `error_log` 配置项.**

1. 开启日志功能

![53421945991](.\php\1534219459914.png)

2. 指定日志保存路径

![53421935659](.\php\1534219356595.png)

#### 自定义错误处理

最简单的错误处理:  `trigger_errors()` 该函数不会阻止系统报错

PHP 系统提供了一种用户处理错误的机制: 用户自定义错误处理函数, 将该函数增加到系统错误处理的句柄中. 系统会在碰到错误之后, 使用用户定义的错误函数.

1. 如何将用户自定义函数放到系统中呢? `set_error_handler()`

![53421982121](.\php\1534219821218.png)

**代码实现**:

1. 自定义错误处理函数: 注意参数

![3422052885](.\php\1534221478715.png)

2. 注册自定义函数: 修改错误处理机制.

![53422120647](.\php\1534221514447.png)

当前属于简单自定义模式, 如果要复杂, 可以在某些影响代码功能的错误发生后, 让用户跳转到某个指定界面.

`header('Location: xxx.php');`

---

## 基础语法

编程语言的常见语法

- 变量
- 顺序结构
- 分支结构
- 循环结构
- 函数        作用域? 大小写问题
- 运算符    数学运算和字符串拼接
- 字面量    代码中用某些字符, 能够表达一个具体的值 这些字符之间表示数据的方式叫做字面量

**php 也是一种编程语言**

 	1. 变量
	2. 双引号字符串和单引号字符串的差异
	3. 指令式语法
	4. foreach
	5. 函数作用域问题
	6. 字符串拼接

### 变量

`$`

```php
$foo = 'hello';	// 定义一个 foo 变量, 赋值 hello
echo $foo; 		// 输出一个变量名为 `foo` 的变量
fn($fo); 		// 将一个变量名为 `foo` 的变量作为 `fn` 函数的实参传递
```

**变量传值**

将一个变量赋值给另外一个变量

变量传值一共有两种方式: **值传递** **引用传递**

1. 值传递: 将变量保存的值赋值一份, 然后新的值传给另外一个变量

![53398862194](.\php\1533988621946.png)

2. 引用传递: 将变量保存的值所在的内存地址, 传递给另外一个变量. 两个变量所指向同一个内存(变量是用一个值) `&`

![53398877177](.\php\1533988771774.png)

在内存中, 通常有以下几个分区

栈区: 程序可以操作的内存部分 (不存数据. 运行程序代码少但是快)

代码段: 存储程序内存部分 (不执行)

数据段: 存储普通数据 (全局区和静态区)

### 常量

**基本概念**

与变量一般, 都是用来保存数据的

常量: const/constant, 是一种在程序运行中, 不可以改变的量(数据)

常量一旦定义, 通常数据不可改变(用户级别)

**常量定义形式**

在 PHP 中常量有两种定义方式

1. 使用函数定义常量: **define()**

   `define('PI', 3.14);`

2. 使用 **const 关键字**定义

   `const PI = 3.14;`

**命名规则**

1. 常量不需要使用 `$` 符号, 一旦使用系统会认为是变量
2. 常量的名字组成由字母 数字 下划线 组成, 不能数字开头
3. 常量的名字通常是以大写字母为主(区别变量)
4. 常量命名的规则比变量要松散, 可以使用特殊字符 (只能是 difine() 方式定义的常量才允许)

**注意细节**

1. define函数 和 const 定义的常量是有区别的: 在于访问权限的区别
2. 我们定义常量通常不区分大小写, 参照 define 第三个参数可以修改是否铭感大小写.

**常量形式**

常量与变量一般使用. 但是不可以改变值 (在定义的时候必须赋值)

**特殊常量的访问**

如果我们使用 define() 定义一个特殊字符的常量, 如 `-_-` ,我们可以 通过 `constant('-_-')`

 说明: **常量和变量的使用**

1. 凡是数据会发生变化的, 肯定使用变量
2. 数据不一定会变的, 可以使用常量或者变量 (变量居多)
3. 数据不允许被修改的, 一定用常量

**系统常量**

- **PHP_VERSION**: PHP 版本号
- **PHP_INT_SIZE**: 整形的大小
- **PHP_INT_MAX**: 整形能表示的最大值 (PHP中整形是允许出现负数: 带符号)

![53400954816](.\php\1534009548169.png)

在 PHP 中还有一些特殊的常量, 他们有双下划线开始 + 常量名 + 栓修改划线结束, 这种常量称之为系统魔术常量: 魔术常量的值通常会跟着环境变化, **用户修改不了**

- `__DIR__` 当前被执行的脚本所在电脑的绝对路径
- **`__FILE__`** 当前被执行的脚本所在电脑的绝对路径 (带自身文件的名字)
- `__LINE__` 当前所属的行数
- `__NAMESPACE__` 当前所属的命名空间
- `__CLASS__` 打过去所属的类
- `__METHOD__` 当前所属的方法 

![53401022459](.\php\1534010224590.png)

### 数据类型

数据类型: data type, 在 PHP 中指的是存储数据本身的类型, 而不是变量类型. PHP 是一种弱类型语言, 变量本身没有数据类型

**在 PHP ** 中数据分类三大类八小类

**简单(基本)数据类型: 4个小类**

整型: **int/integer**, 系统分类4个字节村存储, 表示整数类型(有前提)

浮点型: **float/double**, 系统分配8个字节存储, 表示小数或者长度超出的整数

字符串类型: **string** 根据实际长度分配, 表示字符串(引号包裹)

布尔类型: **bool/boolean** 表示布尔类型,  true/false

**复合数据类型**

对象类型: object 对象类型 (面向对象)

数组类型: array, 存储多个数据 (一次性)

**特殊数据类型**

资源数据: resource, 存放资源数据 (php 外部数据, 如数据库,文件)

空类型: NULL 只有一个值是空 (不能运算)

#### 类型转换

类型转换: 在很多条件下, 需要指定数据类型, 需要外部数据(当PHP取得的数据), 转换成目标数据

在PHP中有两种类型转换模式

1. **自动转换**: 系统根据需求自己判定
2. **强制(手动)转换**: 认为根据需要的目标进行转换 (在数据之前写上`()` 指定类型,如 `(int)123abc` 其中转为 NULL 类型需要

在转换过程中, 用得比较多的就是 布尔类型 和 数值类型(算数运算)

![53403413331](.\php\1534034133318.png)

3. **其它类型转数值的说明**
   1. 布尔 ture 为 1, 布尔false 为 0
   2. 字符串转数值有自己的规则
      1. 以字母开头的字符串 永远为0
      2. 以数字开头的字符串取到字符串为止(不会同时包含两个小数点)

#### 数据类型判断

通过一组类型判断函数, 来判断变量, 使用函数 `is_xxx` 方式对数据进行判断, 返回该数据类型(相同结果为 true, 失败为 false); 

Bool 类型不能用 echo 来查看, 可以使用 `var_dump` 结构查看 **var_dump(变量1, 变量2...)**

![53406067907](.\php\1534060679077.png)

还有一组函数可以来 **获取** 以及 **设定数据**(变量) 的类型

**Gettype(变量名)**: 获取类型, 得到的的是该类型对应的字符串

**Settype(变量名, 类型):** 设定数据类型, 与强制转换不同

1. 强制转换(类型), 是对数据值进行复制的内容进行处理 (不会处理实际存储的内容)

![53406176397](.\php\1534061763973.png)

2. `settype()` 会改变原来数据本身

![3406130904](.\php\1534061498731.png)

#### 整数类型

 **整数类型: ** 保存整数数值 (范围限制), 4个字节存储数据, 最大就是32位: 42亿多. 在 PHP 中默认是有符号类型 (区分正负数) 

PHP中提供了四种整型的定义方式(十进制定义, 二进制定义, 八进制定义,十六进制定义)

![53406255046](.\php\1534062550462.png)

十进制: 逢10进1, 能够出现的数字是 0-9

二进制: 逢二进一, 能够出现的数字是 0-1

八进制: 逢八进一, 能够出现的数字是 0-7

十六进制: 逢十六进一, 能够出现的数字是 0-9和a-f, a表示10,依次类推

**进制转换: ** 手动转换

10进制 转 二进制: 

1. 除2 倒取余 

![53406337792](.\php\1534063377920.png)

不管结果如何, 都会补足32位: 前面补0.    00000000 00000000 0000**1010**

2.![53409080273](.\php\1534090802736.png)

二进制 转 十进制

![53409125236](.\php\1534091252361.png)

**php中不需要用户如此复杂进行计算, 提供了很多函数进行转换**

- `Decbin()`: 十进制转二进制
- Decoct(): 十进制转八进制
- Dechex(): 十进制转十六进制
- Bindec(): 二进制转十进制
- Octdec(): 八进制转十进制
- Hexdec(): 十六进制转十进制

![53409186231](.\php\1534091862316.png)



#### 浮点类型

浮点数: 能够保存 小数类型以及超过整型所能存储范围的整数 (不保证精度)

浮点型两种定义方式: 

```php
$f = 1.23;
$f = 1.23e10;	//	科学计数法: e 表示10的几次方
```

简单说明浮点数为什么同样字节存储数据, 但是存储的数据可以更大

00000000 00000000 00000000 00000000 -> 11111111 11111111 11111111 11111111 (整型最大值: 所有位数都是有效数据)

浮点数: 加粗7位算的结果是 10 的指数, 后面三个字节存储表示具体数据

00000000 00000000 00000000 00000000 -> 1**1111111** 11111111 11111111 11111111

**我们尽量不用浮点数作精确判断: 浮点数保存的数据不够精确, 而且在计算机中凡是小数基本上存的都不准确**

![53409288282](.\php\1534092882820.png)



#### 布尔类型

布尔类型: 两个值 true 和 false, 通常**用于判断比较**. 

在进行某些数据判断的时候, 特别要注意类型转换

Empty(): 判断数据的值是否为"空", 不是NULL, 如果为空返回 true, 不为空返回 false.

Isset(): 判断数据存储的变量本身是否存在, 存在返回 ture, 不存在返回 false.

![53409342027](.\php\1534093420272.png)

#### 伪类型

伪类型: 假的类型.实际上在 PHP 中不存在的类型. 

伪类型主要有两种: 在三大类大小类之外

Mixed: 混合的, 可以是多种 PHP 中的数据类型

Number: 数值的, 可以是任意数数值类型(整型和浮点型)

### 运算符

**运算符:** operator, 是一种将数据进行运算的特殊符号, 在 PHP 中一共有十种之多.

#### 赋值运算符

赋值运算符: 符号是 "=", 表示将右边的结果(可以使变量/数据/常量和其它运算出来的结果), 保存 到内存的某个位置, 然后将位置的内存地址赋值给左侧的变量(常量).

#### 算数运算符

算数运算符: 基本算数操作

`+` 执行数据累加

`-` 执行数据取差

`*` 执行数据相乘

`/` 执行数据相除

`%` 执行取余预算, 两个整数相除, 保留余数

在进行除法运算或者取余运算的时候, 0不能作为被除数(无穷)

![53411164155](.\php\1534111641558.png)

#### 比较运算

**比较运算: 比较两个数据的大小, 或者两个内容是否相同, 返回结果都是布尔类型: 满足返回 ture, 不满足返回 false**

`>` 左边大于右边

`>=` 左边大于等于右边

`<` 左边小于右边

`<=` 左边小于等于有欧变

`==` 左边与右边相同 (大小相同)

`!=` 左边与右边不同 (大小不同)

`===` 全等于, 左边右边 (还判断**类型** **地址**)

`!==` 全不等于, 左边右边不尽相同

![53411206583](.\php\1534112065834.png)

#### 逻辑运算符

逻辑运算: 针对不同的结果进行匹配. 满足条件返回 true, 不满足返回 false

`&&` 逻辑与, 左边的条件与右边条件同时成立(两边都为true). 

`||` 逻辑或, 条件中只要有一个满足即可.

`!` 逻辑非, 对也有条件进行取反, 本身为 true, 取反就是 false

![53411252234](.\php\1534112522349.png)

**逻辑与和逻辑或又称之为短路运算. 如果第一个表达式已经满足[逻辑或]不满足[逻辑与]条件了, 就不会运行逻辑运算符后面的运算**., 在书写代码的时候, 尽量将出现概率最高的 (能够直接判断出结果) 的表达式放第一位.

#### 连接运算符

连接运算符: 是php中将多个**字符串拼接**的运算符.

`.` 将两个字符串连接到一起

`.=` 复合运算, 将左边的内容和右边的内容连接起来, 最终赋值给左边的变量 如 `A.=b ----- A=A.b`

#### 错误抑制符

在php中有些错误可以提前预知, 但是有些**错误无法避免**, 但是希望错误不给用户看到, 可以**使用错误抑制符**处理.

`@` 在可预知错误之前添加 @ 符号即可

![53411337659](.\php\1534113456808.png)

错误抑制符通常在生产环境会遇到, 开发的时候不会使用.

#### 三目运算符

三目运算: 有三个表达式参与的运算 (简单的分支结构的缩写)

语法格式: `表达式1 ? 表达式2 : 表达式3`

表示如果表达式1成立, 执行表达式2, 否则执行表达式3.

注意: 如果表达式本身比较复杂, 建议使用 `()` 将表达式包起来 : `表达式1 ? (表达式2? 表达式4: 表达式5) : 表达式3`

#### 自操作运算符

自操作: 自己操作自己的运算符

`++` : 在原来的值上 +1

`--` : 在原来的值上 -1

在php中, 自操作符可以放在变量前或者后的: **前置自操作** 和 **后置自操作**

前置或者后置如果本身只有自操作, 不参与其它运算 (自操作的同时), 那么效果一般无二; 但是如果自操作运算的同时参与其他运算, 会导致效果的变化.  **`++变量` 先自操作后赋值,   `变量++`  先赋值后自操作**.

![53411439011](.\php\1534114390115.png)

衍生符号: 类似自操作

`+=` 左边结果与右边结果相加, 然后赋值给左边

`-=` 左边结果与右边结果相减, 然后赋值给左边

`*=` 乘法操作

`/=` 除法操作

`%=` 模操作

**注意: 右边是一个整体, 如果进行除法或者取余运算, 需要考虑右边表达式的结果是否为 0.**

![53411463198](.\php\1534114631980.png)

#### 计算机码

计算机码: 计算机在实际存储数据的时候采用的编码规则(二进制)

计算机码分为: 原码 反码 补码, 数值本身最左边一位是用来充当符号位: 正数0, 负数1.

原码: 数据本身从十进制转换成二进制的结果.

​	正数: 左边符号为0 (正数的原码, 反码, 补码就是原码本身)

​	负数: 左边符号为1

反码: 针对负数,  符号位不变, 其它位取反

补码: 反码+1.

系统中存在两个 0:  +0 和 -0

+0: 00000000

-0: 10000000   原码

取反 11111111

补码 反码+1 溢出 00000000

![53411672193](.\php\1534116721932.png)

#### 位运算符

位运算: 取出计算机中最小的单位 (位 bit) 进行运算

`&` 按位与, 两个位都为1, 结果为1. 否则为0

`|` 按位或, 两个位有一个为1, 结果为1

![53411865456](.\php\1534118783418.png)

`~` 按位非, 一个位如果为1, 而变成0, 否则反之

![53411930349](.\php\1534119350866.png)

`^` 按位异或, 两个相同则为0, 不同则为1

`<<` **按位左移**, 整个位(32位), 向左移动一位, **右边补0**

`>>` **按位右移**, 整个位向右移动一位, **左边补符号位**, 对应内容(正数补0, 负数补1)

![53412007336](.\php\1534120218144.png)



#### 运算符优先级

运算福优先级: 在多种运算符同时存在的时候, 如何结合运算

![53412054570](.\php\1534120545700.png)

### 流程控制

流程控制: 代码执行的方向.

**控制分类**

顺序结构: 代码从上往下, 顺序执行

分支结构: 给定一个条件, 同时有多中执行代码(块), 根据条件执行某一段代码

循环结构: 在某个条件控制范围内, 指定的代码(块) 可以重复执行

#### 顺序结构

顺序结构: 嘴鸥基本结构, 所有代码默认是从上往下依次

#### 分支结构

在php中, 分支结构主要有两种 `if 分支`  `switch 分支`

if: 如果的意思, 给定一个条件, 同时为该条件设置多种情况, 根据条件判断来实现具体的执行

基本语法:  

1. `if(条件表达式){满足条件所要执行的内容}`
2. `if(条件表达式){满足条件执行}else{不满足条件执行}`
3. `if(条件表达式1){满足条件表达式1执行}elseif(条件2){不满足变道时1条件,满足条件表达式2}elseif(条件n){不满足条件1,2,3...,满足条件n执行}else{不满足所有条件执行}`

![53412160230](.\php\1534121782601.png)

#### 循环结构

循环结构: 代码段在一定的控制下可以多次执行.

在 php 中循环结构有以下几种:

1. **For 循环**: 通过条件(起始和终止)执行

基本语法: 

```php
For(条件表达式1; 条件表达式2; 条件表达式3) {
    //	条件表达式1: 定义初始化条件. 可以有多种赋值语句存在, 以`,`号隔开
    //	条件表达式2: 边界判断, 限定循环次数
    //	条件表达式3: 执行条件变化
    循环体
}
```

执行原理:

```php
a. 执行条件表达式1, 定义初始化条件(执行一次)
b. 执行条件表达式2, 判断条件(N次)
    b.1 满足条件: 执行循环体
    b.2 不满足条件: 循环结束
c. 执行循环体: (N次)
d. 执行条件表达式3: 循环变量变化 (N次)
e. 执行条件表达式2: 判断条件 (N次)
f. 重复执行 c-d-b 步骤, 直到b步骤不满足条件为止.
```

2. While 循环: 通过判断条件终止执行
3. Do-while 循环: 判断条件终止执行

![53412247963](.\php\1534122479635.png)

4. Foreach 循环: 专门针对数组循环

#### 循环控制

循环控制: 在循环内补对循环本身进行控制

中断控制: 重新开始循环, 循环体中还有其他内容, 再执行

Continue 层级; 默认是1(循环可以多层嵌套) 跳过循环执行层级以后继续循环

![53412369783](.\php\1534123697831.png)

因为循环经常性会碰到嵌套 (循环中间包含循环). 如果在循环内部可以明确知道当前循环(或者外不循环)不需要继续执行了, 就可以使用循环控制来实现. 其中内部循环也可以控制到外部的循环, 就是指定层级参数.

`Continue 2` 当前自己循环后面内部不再执行, 同时外不循环如果还有循环体也不再执行, 重新来过

`Break 2` 当前自己的循环体循环结束, 同时外部循环体循环也结束. 

#### 流程控制的替代语法

流程控制替代语法: 分支和循环控制的替代语法.

php本身是嵌入到 html 中的脚本语言, 在html 中书写关于判断或循环的结构语法, 必须符合 PHP 标签规范, 需要 php 和 html 混搭. 使用原始php语法会非常不美观.

需求: 打印一个 99乘法表

![53412490698](.\php\1534124906987.png)

在 php 书写到 html 中的这些 `{}` 非常不美观, 所以php提供了一种替代机制, 让其可以不用书写 {}:

```php
for(;;){	//	===  for(;;):  左大括号使用 : 替代
}			//	=== endfor;	  右大括号使用 end对应的标记 替代
```

`Switch` `For` `While` `Foreach` 等都可以如此操作



###  函数

函数: function, 是一种语法结构, 将实现某一个功能的代码块封装到一个结构中, 从而实现代码复用.

#### 定义语法

函数有几个对应关键点: function 关键字 函数名 参数(形参和实参) 函数体 和 返回值

基本语法如下: 

```php
Function 函数名([参数]) {
    //	函数体
    //	返回值: return 结果
}
```

定义函数的目的: 是为了实现代码的复用, 一个功能一个函数(简单明了)

函数的使用: 通过访问 `函数的名字()`, 如果有参数, 在调用函数的时候需要传递响应的参数: 函数是一种结构, 不会自己执行, 需要调用才会执行.

![53414201765](.\php\1534142017657.png)

函数执行的内存分析:

1. 读取代码进入到代码段(编译: 将代码编译字节码存储到内存)
2. 根据代码逐行执行

**编译和执行是分开的 (先编译后执行)**

#### 函数命名规范

命名规范: 由字母 数字 下划线组成, 不能以数字开头

函数作为一种常用的结构, 一般遵循以下规则: 函数通常名字代表着函数功能, 有些功能比较复杂, 可能一个单词不足以表示, 需要多个组合.

1. **驼峰法**: 出去左边第一个单词, 后面所有单词首字母大写: showParentInfo()
2. **下划线法**: 单词之间通过下划线连接, 单词都是小写: show_parent_info()

函数名字: 在一个脚本周期中, 不允许出现同名函数(通常在一个系统开发中都不会使用同名函数).

#### 函数的参数

**函数的参数分为两种: 形参和实参**

**形参** : 形式参数, 不具有实际意义的参数

**实参**: 实际参数, 具有实际数据意义的参数

形参可以理解为是实参的载体, 实参在调用的时候通常是需要传入到函数内部参与计算(运算), 那么需要在函数内部找到实际数据所在的位置才能找到数据本身:需要实际调用函数的时候, 将数据以实参的形式传递给形参, 给形参赋值, 从而使得函数内部可以用到外部数据.  

![53414299774](.\php\1534142997743.png)

**注意: **

1. 在 php 中**允许实参多余形参**(个数), 函数内部不使用而已.
2. 在 php 中理论上形参没有限制 (实际开发不会太多).
3. **在 php中 不允许实参不能少于形参(个数).**

#### **形参默认值**

默认值: default value, 指的是形参的默认值, 在函数定义的时候就给形参进行一个初始赋值: 如果实际传入的参数(实参) 没有提供, 那么形参就会使用定义时的值来进入函数内部参与运算.

通常默认值就是用在一些, 一定会有某个参数参与, 但是可能通常是某个我们知道的值.

![53414369515](.\php\1534143695158.png)

注意事项:

1. 默认值的定义是放在最后边的(多个). 不能左边形参有默认值, 但是右边没有.
2. 函数外部定义拜年了名字与函数定义的形参名字冲突(同名) 是没有冲突的, 同样的多个函数使用相同的形参名字也不冲突, **作用域不同**.

#### 函数引用传递

​	实参在调用的时候会将值赋值给形参, 那么实际上使用的方式就是一种简单的值传递, 将实参(如果是变量或者常量或者其它表达式) 的结果 (值) 取出来赋值给形参. 形参与外部实际传入的参数本身没有任何关联关系, 只是结果一样.

​	有的时候, 我们希望在**函数内部拿到的外部数据能够在函数内部改变**, 从而影响外部数据的需求. 要实现这个需求, 我们必须明确告知函数(定义时), 函数才会在执行时候去主动获取外部数据的内存地址, 这就是 **引用传值**

基本定义语法:

```php
Function 函数名(形参1, &形参2){
    //	函数体
}
```

在调用的时候, 必须给引用传传值的参数位置, 传入实际参数, 而且参数本身必须是变量. (变量才有指向数据的内存地址).

![53414454067](.\php\1534144540671.png)

**引用传值注意: 引用传值对应的实参必须传入变量.**

![53414466557](.\php\1534144665572.png)

#### 函数体

函数体: 函数内部 `{}` 里的所以代码 都称之为函数体. 在函数体中基本上所有的代码都可以实现.

1. 定义变量
2. 定义常量
3. 流程控制 (分支, 循环)
4. 可以调用函数

#### 函数返回值

返回值: return, 指的是将函数实现的结果, 通过 return 关键字, 返回给函数外部(函数调用处): 在php中所有的函数都有返回值. (如果没有明确 return 使用, 系统 **默认返回 NULL**)

![53414507558](.\php\1534145075586.png)

**返回值作用: 将计算结果返回給调用处**

![53414869291](.\php\1534148692918.png)

注意: 函数的返回值可以是任意数据类型

**Return 关键字**

1. return 在函数内部存在的价值: 返回当前函数执行结果(当前函数运行结束)

![53414881681](.\php\1534148816819.png)

2. return 还可以在文件中直接使用(不在函数里面): 代表文件将结果 return 后面跟的内容, 转交给包含当前文件的位置. (通常在系统配置文件中能使用较多), 在文件中也代表着终止后面的代码: return 之后的代码不会执行了.

![53414914410](.\php\1534149144109.png)

#### 作用域

**作用域**: 变量能够被访问的区域

1. 变量在普通代码中定义
2. 变量也可以在函数内部定义

在 PHP 中作用域严格来说分两种: 但是 PHP 内部还定义了一些在严格意义之外的一种, 所以总共三种

1. 全局变量: 就是用户普通定义的变量 (函数外部定义)

所属全局空间: **在php中只允许在全局空间中使用: 理论上函数内部不可访问**

![53415040784](.\php\1534150407848.png)

脚本周期: 知道脚本允许结束(最后一行代码执行完毕)

2. 局部变量: 就是在函数内部定义的变量

所属当前函数空间: 在php中只允许当前函数自己内部使用

![53415051833](.\php\1534150518333.png)

函数周期: 函数执行结束 (函数是在栈区中开辟独立空间运行)

3. 超全局变量: 系统定义的变量(预定义变量: `$_SERVER` `$_POST` 等)

所属超全局空间: 没有访问限制(函数内外都可以访问). 超全局变量会将全局变量自动纳入到 `$GLOBALS` 里面, 而 `$GLOBALS` 没有作用域限制, 所以能够帮助局部去访问全局变量: 但是必须使用数组方式 `$GLOBALS['XXX']`

![53415085242](.\php\1534150852422.png)

如果想函数内部使用外部变量: 除了$GLOBALS之外, 通过参数传值(如果要统一战线, 还可以使用引用传值)

在 PHP 中其实还有一种方式能够**实现局部访问全局, 同时全局也可以访问局部**: **global** 关键字

1. 如果使用 global 定义的变量名在外部存在 (全局变量), 那么系统在函数内部定义的变量直接指向外部全局变量所指向的内存空间 (同一个变量, 不同名字)
2. 如果使用 global 定义的变量名在外部不存在 (全局), 系统会自动在全局空间 (外部) 定义了一个与局部变量同名的全局的变量.

本质的形式: 在函数内部和外部对一个同名变量 (全局和局部使用同一块内存地址保存数据, 实现共同拥有.

基本语法: 

```php
Global 变量名;	//	global 关键字声明的变量不可以直接赋值  
变量名 = 值;	//	对该变量进行赋值
```

![53415437827](.\php\1534154378273.png)

虽然以上方式可以实现局部与全局的互访, 但是我慢慢通常不会怎么使用也没有必要. 如果会存在特殊使用, 也会使用参数的形式来访问. (还可以使用常量:  dinfine 定义的常量, 没有空间限制)

#### 可变函数

棵百年函数: 当前有一个变量所保存的值, 正好是一个函数的名字, 那么就可以使用 `变量()` 进行变量的访问. 

基本模式: 

```php
function display(){
    echo __LINE__, __FUNCTION__;
}
//	定义变量
$func = 'display';
//	可变函数
$func();
```

可变函数在系统使用的过程中还是比较多的, 尤其是使用很多系统函数的时候, 需要用户在外部定义一个自定义函数, 需要传入到系统函数内部使用.

![53415678094](.\php\1534156780943.png)

#### 匿名函数

基本概念: 没有名字的函数

基本语法:

```php
变量名 = Function(){
    //	函数体
}

//	调用匿名函数
变量名();
```

保匿名函数, 本质得到的是一个对象

![53416454928](.\php\1534164549289.png)

闭包: closure, 来源于以下两者的结合: 要执行的代码块 (由于自变量被包含在代块中, 这些自由变量以及他们引用的对象没有被释放) 和 为自变量提供绑定的计算机环境(作用域)

简单理解: 函数内部已有一些局部变量(要执行的代码块) 在函数执行之后没有被释放. 是因为函数内部还有对应的函数在引用 (函数内部的函数: 匿名函数)

![53416540096](.\php\1534165400961.png)

证明: 函数的局部变量在函数使用完之后没有被释放?

1. 使用内部匿名函数
2. 匿名函数使用局部变量: use
3. 内部的匿名函数在外部使用

![53416595458](.\php\1534165954582.png)

#### forech

```php
$arr = [1,2,3,4];	//php 5.4 +
//	索引数组
foreach($arr as $value){
    echo $value;
};
//	关联型数组
$arr2 = ['key1' => 'val1', 'key2' => 'val2', 'key3' => 'val3'];
foreach ($arr2 as $key => $value) {
    echo $key, $value;
};
```

### 字符串

#### 字符串定义语法

1. 单引号字符串
2. 双引号字符串

引号方式: 比较适合定义比较短( 只有一行 ) 或者没有结构要求的字符串

![53422178625](.\php\1534221786250.png)

如果有结构要求, 或者内容超过一行, 可以使用以下结构定义:"

3. nowdoc 字符串: 没有单引号的单引号字符串

```php
$str = <<< '边界符'
	字符串内容
边界符;
```

4. heredoc 字符串: 没有双引号的双引号字符串

```php
$str = <<< 边界符
	字符串内容
边界符;
```

![53422240387](.\php\1534222403874.png)

结构化定义字符串变量的规则:

1. 结构化自定义字符串对应的边界符有条件
   1. 上边界符后面不能跟任何内容
   2. 下边界符必须顶格 (最左边)
   3. 下边界符同样后面只能跟分号
2. 结构化定义字符串的内部(边界符之间) 的所有内容都是字符串本身

![53422421862](.\php\1534224218624.png)

#### 字符串转义

转义的含义: 在计算机通用协议中, 有一些特定的方式定义的字母, 系统会特定处理: 通常这种方式都是使用 反斜杠+字母 (单词) 的特效 \r\n: 回车换行

PHP 中识别转义符号的时候也是使用同样的模式: 反斜杠 + 字母

在php中常用的转移符号

`\'` 在单引号字符串中显示单引号

`\"` 在双引号字符串中显示双引号

`\r` 代表回车(理论上是回到当前行的首位置)

`\n` 代表新一行

`\t` 类似 tab 键, 输出4个空额

`\$` 在PHP 中使用 $符号作为变量符号, 需要特定识别

单引号和双引号的区别: 

1. 其中单引号中能识别 \', 而双引号中就不能识别 \"

![53422288970](.\php\1534222889707.png)

2. 双引号可以解析变量, 单引号不可以.

![53422307063](.\php\1534223070636.png)

**双引号中变量是别的规则**:

1. 变量本身系统能与后面的内容区别 (保证变量的独立性, 不让系统难以区分)
2. 使用变量专业标识符 (区分), 给拜年了加上一组 `{}` 

![53422324325](.\php\1534223243253.png)

#### 字符串长度

基本函数 `strlen()` 

![53423040542](.\php\1534230405422.png)

多字节字符串长度问题: 包含中文的长度

**多字节字符串扩展模块: mbstring 扩展(mb:Multi Bytes)**

首先需要加载(开启) php mbstring 扩展

![53423069312](.\php\1534230693122.png)

可以使用 mb 扩展带来的很多函数 如 `mb_strlen()`

![53423081436](.\php\1534230814361.png)

Mbstring 扩展针对的是一些子字符的统计: strlen 只是针对标准交换码 (ASCII) , mbstring 会针对不同的字符集.

![53423106205](.\php\1534231062059.png)



#### 字符串相关函数

1. 转换函数:  `implode()`  `explode()`  `str_split`

   implode(连接方式, 数组): 将数组中的元素, 按照某个规则连接成字符串

   explode(分隔字符, 目标字符串): 将字符串按照某种格式进行分隔, 变成一个数组

   ```php
   中国|北京|天安门  --->  ['中国', '北京', '天安门']
   ```

   str_split(字符串, 字符串长度): 按照指定长度拆分字符串的到数组

2. 截取函数: `trim()`  `ltrim()`  `rtrim()`

   Trim(字符串 [,指定字符]): 默认是用来去除两边空格(中间不行), 也可以指定要去除的内容, 是按照指定的内容, 循环去除两边有的内容, 直到碰到一个不是目标字符为止.

   Ltrim(): 去除左边的

   Rtrim(): 去除右边的

3. 截取函数: `substr()`  `strstr()` 

   substr(字符串, 起始位置(默认从0开始) [,长度]): 指定位置开始截取字符串.

   strstr(字符串, 匹配字符): 从匹配字符位置开始截取到最后(可以用来取文件后缀名).

   ![53423220253](.\php\1534232202531.png)

4. 大小转换函数 `strtolower()`  `strtoupper()`  `ucfirst()`

   strtolower() 全部小写

   strtoupper() 全部大写

   ucfirst() 首字母大写

5. 查找函数: `strpos()`  `strrpos()` 

   strpos(字符串, '子字符'): 查找字符串,某子字符首次出现的位置, 没有返回false

   strrpos(): 查找子字符在目标字符串中最后出现的位置

   ![53423444482](.\php\1534234444828.png)

6. 替换函数: `str_replace()`

   **str_replece(匹配目标, 替换内容, 字符串):** 将目标字符串中部分字符进行替换

   ![53423456509](.\php\1534234565092.png)

7. 格式化函数: `printf()`  `sprintf()`

   printf/sprintf(输出字符串有占位符, 顺序占位内容): 格式化输出数据.

   ![53423490698](.\php\1534234906984.png)

   ![53423484671](.\php\1534234846716.png)

8. 其它: `str_repeat()`  `str_shuffle()` 

   str_repeat(字符串, 重复次数): 重复某个子字符

    str_shuffle(字符串): 随机打乱顺序

    ![53423520413](.\php\1534235204136.png)





### 数组

数组: array, 数据的组合, 指将一组数据(多个数据), 存储到指定的额容器中, 用变量指向该容器, 可以通过变量一次性得到容器中的全部数据.

#### 定义语法

在PHP中, 系统提供了多种定义数组的方式:

1. 使用 array 关键字: **最常用**.

   `$变量 = array(元素1, 元素2, 元素3 ....);`

2. 使用 `[]` 包裹数据:

   `$变量 = [元素1, 元素2...];`

   ![53423585982](.\php\1534235859822.png)

3.  隐形定义数组: 给变量增加一个 `[]`, 系统会自动变成数组, 

   ```php
   $变量[] = 值1; //  如果不提供下标, 自动生成(数字, 从0 开始)

   $变量[下标] = 值; // 中括号里面内容称之为下标 key, 下标可以使字母(单词) 护着数字, 与变量命名规则相似,
   ```

   ![53423599939](.\php\1534235999390.png)

#### 数组特点

1. 可以整数下标或者字符串下标

   1. 下标都为整数: 索引数组
   2. 下标都为字符串: 关联数组

2. 不同下标可以混合存在: 混合数组

3. 数组元素的顺序以放入顺序为准, 跟下标无关

4. 数字下标的自增长特效: 从0开始自动增长, 如果中间手动出现较大的, 后面的自增元素从最大值+1开始.

5. 特殊值下标的自动转换

   1. 布尔值: true 和 false
   2. 空: NULL

   ![53423635208](.\php\1534236352083.png)

6. PHP 中数组元素没有类型限制.

7. php 中数组元素没有长度限制

补充: **php 中的数组是很大的数据, 存储的位置是 堆区, 为当前数组分配一块连续的内存.**

#### 多维数组

多维数组: 数组里面的元素又是数组.

​	二维数组: 数组中所有的元素都是一维数组  . `[[],[],[],[]]`.		![53423682150](.\php\1534236821505.png)

​	多维数组:

​	在二维数组元素中可以继续是数组, 在PHP 中没有纬度限制(php 本质没有二维数组), 当然我们不建议使用超过三维以上的数组, 会增加访问的复杂度, 降低访问效率.

​	异性数组(不规则数组)

​	异性数组: 数组中的元素不规则, 有普通基本变量也有数组. 实际开发中, 并不常用, 尽量让数组元素规则化(便于进行访问)

#### 遍历数组

```php
$array = array(
	0 => array('name' => 'Tim', 'age' => 18),
    1 => array('name' => 'Jone', 'age') => 19)
);
//	访问一维元素 $array[一维下标]
$array[0]; 
//	访问二维元素 $array[一维下标][二维下标];
$array[0]['name'];
```

​	数组遍历: 普通数组数据的访问都是通过数组元素的下标来实现访问, 如果说数组中所有的数据都需要依次输出, 就需要我们使用简化规则实现自动获取下标和输出数组元素.

##### Foreach 遍历

**基本语法** 

```php
foreach($数组变量 as $值) {
    //	通过 $下标访问元素的下标, 通过$值访问元素的值
}
```

![53423802559](.\php\1534238025596.png)

![53423825275](.\php\1534238252757.png)

​	在进行数据存储定义的时候, 通常二维数组不会两个维度 key 下标都为数字, 一般是一维为数字, 二维为字符串(数据库表字段), 所以在进行遍历的时候, 通常是只需要针对一维进行遍历, 取得二维数组元素, 使用 array['字符串']获取数组指定的值.

**Foreach 遍历原理**

foreach 变量基本值是数组的内部有一个指针, 默认是指向元素的第一个元素, foreach 就是利用指针去获取数据, 同时移动指针.

1. foeach 会重置指针: 让指针指向第一个元素
2. 进入foreach循环: 通过指针取得当前第一个元素, 然后将下表取出放到对应的下标变量 `$k` 中(如果存在), 将值取出来放到对应的值变量 `$v`中 (指针下移)
3. 进入到循环内部 (循环体), 开始执行
4. 重复 2 和 3, 直到在 2 的时候遇到指针取不到内容. (指针指向数组最后) 

##### For 循环

for循环: 基于已知条件 (起始和结束), 然后有条件地变化, 因此, for循环遍历数组有对应条件

1. 获取数组长度: count(数组) 的到数组的长度.
2. 要求数组元素的下标是有规律的数字.

![53423913574](.\php\1534239135749.png)

##### While 配合 each 和list 遍历数组

While 是在外部定义边界条件, 实现和 for 遍历原理一般.

Each 函数的使用: each 能够从一个数组中获取当前数组指针所指向的元素的下标和值, 拿到之后将数组指针下移, 同时将拿到的元素下标和值与一个四个元素的数组返回.

```php
0下标 -> 取得元素下标值
1下标 -> 取得元素的值
key下标 -> 取得元素的下标值
value下标 -> 取得元素的值
```

![53423952137](.\php\1534239521377.png)

如果 each 取不到(超出指针移动范围), 则返回 false

![53423962715](.\php\1534239627152.png)

List 函数使用: list 是一种结构, 算不上一种函数 (没有返回值), list 提供一堆变量,去从一个数组中取得元素值, 然后依次存放到对应的变量中(批量为变量赋值: 值来源于数组), list 必须从索引数组中去获取数据, 而且索引必须是从0开始.

List 和 each 配合特别好: each 一定有两个元素就是0和1下标元素

![53424015223](.\php\1534240152234.png)

#### 数组的相关函数

##### 排序函数

​	**对数组元素进行排序, 都是按照 ASCII 码进行.**

`sort()` : 顺序排序(下标重排). 对数组进行排序, 从最低到最高重新安排

![53431677946](.\php\1534316779462.png)

`rsort()` : 逆序排序

`asort()` : 顺序排序(下标保留)

![53431694804](.\php\1534316948043.png)

`arsort()` : 逆序排序

`ksort()` : 顺序排序, 按照键名(下标)

`krsort()`: 逆序排序

![53431706959](.\php\1534317069591.png)

`shuffle()` : 随机打乱, 索引也会改变.

![53431713472](.\php\1534317134728.png)

![53431714837](.\php\1534317148378.png)

##### 数组指针函数

`reset()` 重置指针, 将数组指针回到首位

`end()` 重置指针, 将数组指针指到最后

`next()` 指针下移, 取得下一个元素的值

`prev()` 指针上移, 取得上一个元素的值

![53432092636](.\php\1534320926363.png)

`current()` 获取当前指针对应的元素值

`key() ` 获取当前指针对应的下标值

![53432078503](.\php\1534320785034.png)

​	注意事项:       **其中 `next`  和 `prev` 会移动指正, 有可能导致数组移动到最前或者最后(离开数组), 导致数组不能使用, 通过 `next` 和 `prev` 不能回到正确的指针位置. 只能通过 `end` 和 `reset` 回到最初或者最后.**

##### 其它函数

`count()` 统计数组中元素的数量

`array_push()` 往数组加入一位元素(数组后面)

`array_pop()` 往数组中取出一位(数组后面)

`array_shift()` 从数组中取出一位(数组前面)

`array_unshift()` 从数组中加入一个元素(数组前面)

php模拟数据结构 :

栈: 压栈, 先进后出

![53432174333](.\php\1534321743331.png)

队列: 排队, 先进先出

![53432181196](.\php\1534321811969.png)

`array_reverse()` 反转数组

`in_array('元素', 数组)` 判断一个元素在数组中是否存在

`array_keys()` 获取数组的所有 下标值, 返回一个索引数组 

`array_values()` 获取数组的所有 键值, 返回一个所有数组

![53432200275](.\php\1534322002755.png)

#### 数组排序算法

##### 冒泡排序

​	冒泡排序, 是一种计算机科学领域较简单的排序算法. 它重复地走访过要排序的数略, 一次比较两个元素, 如果他们的顺序错误就把他们交换过来.走访数列的工作是重复地进行直到没有需要交换, 也就是说该数组已经票需完成.

冒泡排序的算法思路:

1. 比较相邻元素, 如果第一个比第二个大, 就交换他们的位置.
2. 对每一对相邻的元素同样工作, 从开始第一对到结尾的最后一对. 在这一点, 最后的元素应该会是最大的数.
3. 针对所有的元素重复以上步骤, 除了最后一个.
4. 持续每次对越来越少的元素重复上面的步骤, 知道没有任何一对数字需要比较.

![53437644112](.\php\1534376441122.png)

##### 选择排序

选择排序是一种简单直观的排序算法. 他的工作原理是每一次从待排序的数据元素中选出最小(或最低)的一个元素, 存放在序列的起始位置, 知道全部待排序的的数据元素排完. 选择排序是不稳定的排序方法(比如序列[5, 5, 3] 第一次就将第一个 [5] 与 [3] 交换, 导致第一个 5 挪动到第二个5后面).

**选择排序算法思路**

1. 假设第一个元素为最下元素, 记下下标.
2. 寻找右侧剩余元素, 如果有更小的, 重新记下最新的下标.
3. 如果有新的最小的, 交换两个元素. 
4. 往右重复执行以上步骤, 直到元素本身是最后一个.

![53437942546](.\php\1534379425466.png)

##### 插入排序

插入排序的基本操作是将一个数据插入到已经排好的有序数组中, 从而得到新的, 个数加一的有序数据, 算法适用于少量数据的排序, 是稳定的排序方法. 插入算法把要排序的数组分为两部分: 第一部分包含了这个数组的所有元素, 但将最后一个元素除外(让数组多一个空间才有插入的位置), 而第二部分就只包含这一元素(即待插入元素). 在第一部分排序完成后, 再将这个最后元素插入到已经排好顺序的第一部分中.

插入排序的基本思想是: 每步将一个待排序的记录, 按其关键码值的大小插入前面已经排序的文档适当位子上, 直到全部插入完为止.

插入排序的算法思路:

1. 设置监视哨 r[0], 将带插入记录的值赋值给 r[0];
2. 设置开始查找为止 j;
3. 在数组中进行搜索, 搜索中将 j 个记录后, 直至 r[0].key 大于等于 r[j].key 为止;
4. 将 r[0] 插入到 x[j+1] 的位置上

步骤:

1. 认定第一个元素已经排好序
2. 取出第二个元素, 作为待插入数据
3. 与已经排好序的数组最右侧元素开始进行比较
4. 如果后面的小于前面的: 说明前面已经排好序的那个数组元素, 不在对的位置(向后移一个), 然后让新的元素填充进去(继续向前比)
5. 重复以上步骤, 直到当前元素插入到正确位置

重复以上步骤, 直到所有的数组元素都插入到正确位置.

![53438346951](.\php\1534383469514.png)优化:

![53439221608](.\php\1534392216086.png)

##### 快速排序

快速排序是对冒泡排序的一种改进. 通过一趟排序将要排序的数据分割成独立的两部分, 其中一部分的所有数据都比另外一部分的数据都要小,  然后再按此方法对这两部分数据分别进行快速排序, 整个排序过程都可以递归进行, 以此达到整个数据变成有序序列

设要排序的数组是 A[0].....A[N-1], 首先任意选取一个数据 (通常选取数组的第一个数)作为关键数据, 然后将所有比他小的数据放到它前面, 所有比它大的数据放到它后面, 这个过程称为一趟快速排序. 值的注意的是. 快速排序不是一种稳定的排序算法, 也就是说, 多个相同的值的对应位置也许会在算法结束时产生变动

快速排序的算法是:

1. 从数组中选出一个元素 (通常第一个), 作为参照对象.
2. 定义两个数组, 将目标数组中剩余逇元素与参照元素挨个进行比较: 小的放到一个数组, 大的放到另外一个数组.
3. 第二步执行完毕后, 前后的数组顺序不确定, 但是确定了自己位置
4. 将得到的小数组按照第一到第三步重复操作(子问题).
5. 回溯最小数组(一个元素)

![53441747770](.\php\1534417477706.png)

##### 归并排序

归并排序 时间里在归并操作上的一种有效的排序算法, 该算法是采用分治法的一个非常典型的应用. 将已有序的子序列合并,得到完全有序的序列, 即先使每个自序有序, 再使子序列段间有序. 若将两个有序表合成一个有序表,称为二路归并.
**二路归并**

![53443390780](.\php\1534433907802.png)

归并排序的算法是:

1. 将数组拆分成两个数组
2. 重复步骤1将数组拆分成最小单位
3. 申请空间, 使其大小为两个已经排序序列之和, 该空间用来存放合并后的序列.
4. 设定两个指针, 最初位置分别为两个已经排序序列的起始位置
5. 比较两个指针所指向的元素, 选择相对小的元素放到合并口你见, 并移动指针到下一位置
6. 重复3的步骤 直到某一指针超出序列尾.
7. 将另一序列剩下的所有元素直接赋值到合并序列尾

![53442200112](.\php\1534422001125.png)

##### 查找算法

查找是在大量的信息中寻找一个特定的信息元素, 在计算机应用中, 查找是常用的基本运算.查找算法是指实现查找过程对应的代码结.就是中大型数组中去快速定位想要的元素.

**顺序查找算法**

顺序查找也称为线性查找, 从数据结构线性表的一端开始, 顺序扫描, 依次将扫描到的结点关键字给定值 k 相比较, 若相等表示查找成功, 若扫描结束仍未找到关键字等于 k的结点, 表示从号召失败.

![53449804623](.\php\1534498046236.png)

**二分查找算法**

二分查找要求线性表中的结点按关键值升序或降序排列, 用给定的值 k 先与中间结点的关键字比较, 中间结点把线形分为两个子表, 若相等则查找成功; 若不相等, 再根据 K 与该中间结点关键字的比较结果确定下一步查找哪个子表, 这样递归进行, 直到查找到或者查找结果发现表中没有这样的结点.

折半算法思路: 

1. 计算数组长度
2. 确定左右两边的指针位置
3. 找到中间位置
4. 匹配
5. 然后根据大小重定边界

![53449927689](.\php\1534499276890.png)

---

## 语法特性

### 变量

#### 变量作用域

关于变量作用域这一点, PHP **默认函数内不能直接访问函数外的成员**

在 JavaScirpt 中， 我们可以在函数作用域中使用父级作用域中的成员

```js
// 在js中
var top = 'top vaariable';

function foo(){
    var sub = 'sub variable';
    console.log(top); // -> 正常打印top值
};
foo();
```

```php
//	在php中
$top = 'top vaariable';
function foo(){
    $sub = 'sub variable';
    echo $sub, $top; //	无法拿到$top
};
foo();
```

**如果需要访问全局变量, 可以通过 `global ` 关键字声明**

```php
$top = 'top variable';
function foo(){
    global $top;	//  声明当前作用域中需要获取全局作用域中的 `$top`
    $sub = 'sub variable';
    echo $sub, $top;//	可以拿到$top
}
foo();
```

#### 超全局变量

> http://www.w3school.com.cn/php/php_superglobals.asp

PHP 中的许多预定义变量都是**超全局的**, 这就意味着她们在一个脚本的全部作用域中都可用.在函数或方法中无需执行 global $variable; 就可以正常地访问他们.

- $GLOBALS -- 引用全局作用域中可用的全部变量
- $_SERVER -- 获取服务端相关信息
- $_REQUEST -- 获取POST 提交参数
- $_POST -- 获取 POST 提交参数
- $_GET -- 获取 GET 提交参数
- $_FILES -- 获取上传文件
- $_ENV -- 操作环境变量
- $_COOKIE -- 操作 Cookie
- $_SESSION -- 操作 Session

#### 常量的定义与使用

`define()` 函数定义

```php
//	php中你可以日通过 define 函数定义一个常量
//	常量的特点就是: 定以后不能被修改, 也是临时存放数据的容器
//  什么时候使用常量: 一般程序的配置信息(不会在运行过程中修改), 都会使用常量中定义
//	what why how where when ????

//	变量或函数都是采用snake_case (小写字母加下划线) 命名规则
//  常量 是 SNAKE_CASE (大写, 下划线)	命名规则
//	第一个参数是 常量名称
//	第二个参数是 常量的值
//	第三个参数是 常量名称是否忽略大小写,默认false ,建议忽略第三个参数.
define('SYSTEM_NAME', '阿里百秀');
echo SYSTEM_NAME;
```

#### 静态变量

静态变量: static, 是在函数内部定义的变量, 使用 static 关键字修饰, 用来实现跨函数共享数据的变量: 函数运行结束所有局部变量都会清空, 如果重新运行一下函数, 所有局部变量又会重新初始化. 但是静态变量是会被赋值于上次的值.

基本语法:

```php
Function 函数名(){
    //	定义静态变量
    static $变量名 = 值;	//	静态变量一般定义的时候就会被赋值
}
```

静态变量的作用是为了跨函数共享数据 (同一个函数被多次调用)

![53415523286](.\php\1534155557705.png)

### 编程思想

编程思想: 如何利用数学模式, 来解决对应需求问题, 然后里用代码实现对应的数据模型(逻辑).

算法: 使用代码实现对应的数学模型, 从而解决对应的业务问题.

#### 递推算法

​	递推算法是一种简单的算法, 即通过已知条件, 理由特定关系的出中间推论, 直至得到结果的算法. 递推算法分为顺推和逆推两种.

顺推: 通过最简单的条件(已知), 逐步推演结果.

逆推: 通过结果找到规律, 然后推到已知条件.

```php
斐波那契数列:1 1 2 3 5 8 13 21
    //	请取得 对应指定位置 N 所对应的值是多少.
    //	找规律:
    	//	1. 第一个数是1
    	//	2. 第二个数也是1
    	//	3. 从第三位开始 值是前两位的和(规律)
    //	解决思路:
    	//	1. 数字位置为 1 和 2 , 结果都是1
    	//	2. 第三个开始想办法得到前两位的结果, 就可以得到
    //	解决办法: 想办法要求的位置之前的所有值都列出来, 要求的数就可以同前两个的和计算出来. 使用数组存储所有结果即可.
```

![53432286835](.\php\1534322868351.png)

使用函数得到期望值.

![53432355217](.\php\1534323552171.png)

#### 递归算法

​	递归算法是把问题转化为规模缩小了的同类问题的子问题. 然后递归调用函数(或过程) 来表示问题的解.

1. 找到最优子问题 (不能再小)
2. 函数自己调用自己

递归思想中: 有两个非常重要的点:

1. 递归点: 发现当前的问题可以有解决当前问题的函数, 去解决规模比当前小一点的问题来解决
2. 递归出口: 当问题解决的时候, 已经达到(必须有) 最优子问题, 不能再次调用函数

```php
F(N) = F(N-2) + F(N-1)
F(N-1) = F(N-3) + F(N-2)
    ....
F(2) = F(1) = 1
```

![53432382677](.\php\1534323826779.png)

如果一个函数递归调用自己而没有出口: 就是死循环

递归的本质是函数调用函数: 一个函数需要开辟一块内存, 递归会出现同时调用 N 个函数(自己): 递归的**本质**就是利用 **空间换时间**



### 文件包含(加载)

 载入一个文件中的代码过长, 自然会想到拆分到多个文件中. 分块管理维护下更强烈

**PHP 中引入其他 php 文件的四种方式**

- require
- require_once
- include
- include_once

对比:

|                                      | require | require_once | include | include_once |
| ------------------------------------ | :-----: | :----------: | :-----: | :----------: |
| 被载入文件如果不存在是否影响继续运行 |  影响   |     影响     | 不影响  |    不影响    |
| 多次调用是否会重复执行被载入的文件   |   会    |     不会     |   会    |     不会     |

使用层面:

- include 一般用于载入公共文件, 这个文件的存在与否不会影响后面的程序运行. 如网页头部/底部等复用文件.
- require 用于载入不可缺失的文件. 如方法模块文件.
- 根据不同的需求是否采用 (once) 方式载入文件


**意义**

1. 要么使用被包含文件中的内容, 实现代码的共享(重用): 向上包含(索要).

向上包含: 在当前脚本要用到某个代码之前包含包含别的文件.

1. 要么自己的代码可以给别的文件使用, 实现代码的共享(重用): 向下包含(给予). 

向下包含: 在自己有某个东西的时候, 需要别的脚本来显示 (自己代码写完之后包含其他文件)

**作用**

分工协作, 每个脚本做自己的事情, 使用协作方式, 多个脚本合作完成一件事情.

写法: `include '文件地址'` 或 `include('文件地址')`

![53412597864](.\php\1534125978644.png)

以上形式是先包含文件, 在使用文件中的内容 (向上包含).

向下包含: 先准备内容, 然后包含另外的文件, 在使用文件中使用当前的内容.

![53412635069](.\php\1534126350695.png)

#### 文件加载原理

php 代码的执行流程

1. 读取代码文件 (PHP 程序)
2. 编译: 将 PHP 代码转换成字节码 (生成 opcode)
3. zendengine引擎 来解析 opcode, 按照字节码去进行逻辑运算
4. 转换成对应的 html 代码

**文件加载原理:** 

1. 在文件加载 (include 或者 require) 的时候, 系统会把被包含的文件内容嵌入到当前文件中
2. 家在位置: 在哪里加载, 对应文件中的代码就在哪里嵌入(include位置)
3. 在 php 中被包含的文件是单独进行编译的

PHP 文件在编译的过程中如果出现了语法错误, 那么就会失败(不再执行). 如果被包含文件有错误的话, 系统会在include 该文件的位置报错

#### include 和 require 区别

include 和 include_once 区别:

inlcude 系统会碰到一次执行一次,  如果对同一个文件进行多次加载, 系统会执行多次.

include_once 系统碰到多次也只会执行一次.

require 和 include的 区别在于: require 要求较高, 如果包含出错代码, 那么之后的代码就不再执行(require后面的代码)

![53413884287](.\php\1534138842877.png)

#### 文件加载路径

文件在加载的时候需要指定文件路径才能保证 PHP 正确的找到对应的文件.

文件的路径包含两大类: 

1. 绝对路径

   a. 从磁盘的根目录开始(本地绝对路径) `Windows: C;/路径/php文件` `Linux /路径/php文件`

   b. 从网站更目录开始 (网络绝对路径) `/` 相对于网站主机名字对应的路径 

2. 相对路径: 从当前文件所在目录开始的路径

   `./` 表示当前文件夹

   `../` 上一层目录(当前文件夹的上一层wenjainjia)

绝对路径和相对路径的加载区别

1. 觉对路径相对效率偏低, 但是相对安全 (路径不会出问题)
2. 相对路径相对效率偏高些, 但是容易出错.(相对路径会发生改变)

#### 文件嵌套包含

文件嵌套包含: 一个文件包含另外一个文件, 同时被包含的文件又包含另外一个文件.

![53414004416](.\php\1534140044166.png)

**嵌套包含的时候很容易出现相对路径出错的问题**, 相对路径会因为文件的包含而改变 (./和 ../), windows 下面每一个文件都有 ./ 或者 ../

![53414088319](.\php\1534140883198.png)

比如 张三 左边是 李四, 李四左边是王五.

张三把李四喊到自己的位置: 李四与王五之间差两个位置, 如果李四还按照左边找王五. 那样的话, 王五就丢了.

------

## 常用的 API

> API   ( Application Programming Interface ) 应用程序编程接口.
>
> 接口都是提供某种特定能力的事物, 特点是有输入和输出, 我们在写代码时使用的接口称之为 API.

### 字符串处理

```php
//	strlen() 获取字符串长度, 宽字符(中文字符串)的长度为3
strlen('字符串')

//	explode() 切割字符串.	js 中的 split() 方法
explode('分割符', '字符串')
    
//	strpos()  查找字符或指定文本, 匹配返回第一个匹配字符位置, 不匹配返回false. 对应 js 中的 indexOf() 方法
strpos('查询内容', '匹配字符') 
    
//	substr() 截取字符串.	js中的substring
substr('hello world', 6)
    
//	strtolower() strtoupper() 大小写转换.	js中的toLowerCase() toUpperCase()
strtolower('ASDfghjkl')    
    
//  trim() 去除首尾空白字符 ltrim() rtrim()
trim(' Hellow word ')
    
//	str_replace()  字符串替换.	js中的 eplace()
str_replace("world", "girl", "Hello world!")  // 替换字符串中的 world 为 girl
  
//	str_repeat()	重复让字符串出现多次. 	ES6 `repeat()`
str_repeat(' hello')
    
/*
	PHP 中专门为 宽字符 集提供了一套API, 不在PHP内置的方法中, 在扩展程序中
	mb_string.dll 
    内置的可以直接使用, 模块中的成员必须配置成员,载入模块之后才可以使用
*/
//	mb_strlen()	获取宽字符串的长度
```

### 数组处理

```php  
//	获取关联数组中的全部键/值
array_keys($array)
array_values($array)
    
//	判断关联数组中是否有某个成员
array_key_exists($key, $array)
    //	判断关联数组中是否有某个成员的其他方式
    $array['key'] // 如此判断,会报一个类型错误, Notice: Undefined index,生产环境可以更改php.ini文件,不现实该错误
    isset($array['key']) // 使用isset() 判断关联数组中是否有某一个键值, isset() 能帮我们把 Notice 错误吞掉
    empty($array['key']) // 使用empty() 判断关联数组中没有某一个键值
    //empty($input) === !isset($input) || $input == false
    
//	数组去重.				ES6中 new Set()
array_unique($array)

//	将一个或多个元素追加到数组中
array_push('newValue')
$array[] = 'newValue'
  
//	删除数组中最后一个元素.	js 中 pop
array_pop($array)
    
//	数组长度
count($array)
    
//	检测数组中是否存在某一项	js中 [].includes(), 字符串中也有该方法 str.includes()
in_array('val', $array)
    
//	检测某项在数组中的下标. 	 js中 indexOf()
array_search('val', $array)
    
//	移除数组中的某一项
unset($data['key']);

//	合并多个数组
array_merge(array $array1[, array $...]);

//	打乱数组
bool shuffle( array &$array);

//	从数组中取出一个或多个随机的单元，并返回随机条目的一个或多个键。
mixed array_rand( array $array[, int $num = 1] );
//将一维数组以,分隔组合成一个字符串，参数一可以为""//将一维数组以,分隔组合成一个字符串，参数一可以为""
implode(',', $arr);
```

### 输出函数

`print()` 类似于 echo 输出提供的内容, 本质是一种结构(不是函数), 返回1, 可以不需要使用括号.

`print_r()` 类似于 var_dump, 但是比 var_dump 简单, 不会输出数据的类型, 只会输出值(数组打印使用较多)

![53420553776](.\php\1534205537768.png)

### 时间函数

- 时间戳 `time()` 获取当前对应的时间戳.

```php
echo time()	
```

- `data()` 按照指定格式对应的时间戳(1970年格林威治时间开始计算的秒数).没有指定时间戳, 默认当前实际戳

```php
// 1. 通过代码设置时区 √推荐
date_default_timezone_set('PRC');
// 2. 通过配置文件设置 php.ini
// date.timezone = PRC

//	date() 格式化一个时间戳
// 第一个参数 是一个时间格式. date()函数内部使用单引号
// 第二个参数 是一个时间戳.默认值当前时间时间戳
// 默认事件戳给出的事件是格林威治的时间, 即零时区的时间
// 时间格式的字符串中每个字母都有自己的意义, 比如 Y表示年, i表示分 ,s表示秒... 如果冲突可以使用\进行转义 
echo date('Y/m/d H:i:s', time());
```

- 将已有格式的时间字符串转为时间戳 `strtotime()`

```php
$str = '2018-5-19 16:57:58';
//	时间格式的字符串转为时间戳
$time = strtotime($str);
// 时间格式的字符串中每个字母都有自己的意义,比如 Y表示年, i表示分 ,s表示秒... 如果冲突可以使用\进行转义 
echo date('Y年m月d日 <b\r> H:i:s',$time);
```

- `microtime()` 返回当前时间戳和微秒数

![53420643844](.\php\1534206438447.png)

### 数学函数

- `max()` 指定参数中最大的值
- `min()` 指定两个中较小的值
- `rand()` 得到一个随机数, 指定区间的随机整数
- `mt_rand()` 与 rand 一样, 底层结构不一样, 效率更高
- `ceil()` 向上取整
- `floor()` 向下取整
- `pow()` 求指定数字的指定指数次结果 pow(2, 8) ---  2的8次方 
- `abs()` 绝对值
- `sqrt()` 求平方根

### 函数的函数

- `function_exists()` 判断指定的函数名字是否在内存中存在(帮助用户不去使用一个不存在的函数, 让代码更安全).
- `func_get_arg()` 在自定义函数中获取指定数值位的参数
- `func_get_args()` 在自定义参数中获取所有参数
- `func_num_args` 获取参数数量

![53420737130](.\php\1534207371308.png)




## 核心 API

### 表单传值

**概念**

表单传值即浏览器通过表单元素将用户的选择或者插入的数据提交给后台服务器语言.

**为什么使用表单传值**

动态网站 (web2.0) 的特点就是后台根据用户的需求定制数据, 所谓的 "需求" 就是用通过当前的选择或输入的数据信息, 表单就是这些数据的承载着.

主要作用还是用于**收集指定用户信息**

> 信息交互: 收集数据  显示数据

#### 表单传值方式

- GET 传值
  1. form 表单: `<form method = "GET">表单元素</form>`
  2. a 标签: `<a href="www.itcast.cn/index.php?data=php"></a>`
  3. loction 对象的 href 属性: `<script>location.href="www.itcast.cn/index.php?data=PHP"</script>`
  4. location 对象的 assign() 方法: `location.assign("www.itcast.cn/index.php?data=php")</script>`
- POST 传值
  1. post 表单方式的基本设定 `<form method = "POST">表单元素</form>`

**get 和 post 区别**

`method` 可以用于设置表单提交的方式, 目前我们所认识的就是最常见两种表单提交方式: `GET` 和 `POST` .

从实现提交的原理上看,两者有很大的不同

- GET
  - 表单数据是通过URL 中的 ? 参数传递到服务端的..
  - 可以再地址栏中看到提交的内容.
  - 提交简单的数据(数值/字符串).
  - 数据长度有限制, 因为 URL 地址长度有限制 (2000个字符, 事实上, get和post本身没有数据长度限制, 但是浏览器厂家做了一些限制).
- POST 
  - 表单数据是通过请求头传递到服务端的, 我们在 URL 地址上看不到.
  - 可以提交任意类型数据, 包括文件.
  - URL 地址栏不显示提交数据, 浏览器不存储, 相对GET方式较为安全.

在什么情况下选择哪种方式, 这个需要结合业务场景和这两种方式各自的特点来决定, 没有绝对的答案, 只能个给出一些原则:

- 绝对不可以使用 GET 方式发送密码或者其他敏感信息.
- **应该想清楚这次请求目的是去拿东西, 还是去送东西.**

#### 表单基本使用

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>用户登录</title>
</head>
<body>
	<form action="11-foo.php" method="get" autocomponent='off' >
		<table>
			<tr>
				<td>用户名</td>
				<td><input type="text" name="username"></td>
			</tr>			
			<tr>
				<td>密码</td>
				<td><input type="password" name="password"></td>
			</tr>
			<tr>
				<td></td>
				<td><input type="submit" value="登录" name="submit"></td>
			</tr>
		</table>
	</form>
</body> 
</html>
```

HTML 中有一个专门用于提交数据的标签 `<form />`, 通过这个标签可以很容易的收集用户输入.

表单的 type 不同, 浏览器会赋予某些验证, 需要关闭 给form加上 `novalidate` 

闭客户端的自动完成功能( 记录历史 ) 表单域后添加 `autocomplete = "off"` 属性， 默认是开启

> form 标签的两个必要属性
>
> - action :  		表单提交地址
> - method:         表单以什么方式提交

#### 接收数据的三种方式

按照目前情况, 用户第一次请求得到这个表单页面, 填写完成表单内容, 提交表单. 会自动发送给服务端, 服务端如何获取用户提交过来的内容.

PHP 中有三个超全局变量专门用来获取表单提交内容:

- $_GET:  			用来获取以 GET 方式提交的内容, 更标准的说法是接收URL地址问号后参数的数据
- $_POST:                 用来获取以 POST 方式提交的内容, 跟标准的说法是接收请求体中的数据
- $_REQUEST:          用来获取 GET 或  POST 方式提交的内容

不管是 `$_GET` `$_POST` `$_REQUEST`, 三个都是 PHP 超全局(没有范围限制) 与定义数组, 表单元素的 "name" 属性值作为数组的下标, 而 value 属性对应的值就是数组的元素值.

`$_REQUEST` 和 `$_POST` `$_GET`  的联系, 如果GET 和 POST 中有同名数组元素(下标), POST 会覆盖 GET (PHP中数组元素下标具有唯一性).

![53499206947](.\php\1534992069475.png)

借助 `$_POST` 或者 `$_REQUEST`  就可以获取到表单提交的内容.

```php
<?php 
//	获取表单提交的用户名和密码
echo '用户名:'.$_REQUEST['username'];
echo '密码:'.$REQUEST['password'];
echo '昵称:'.$REQUEST['nickname'];
?>
```

#### 提交地址

`action` 提交地址指的是表单填写完成过后提交, 发送请求的请求地址是什么.

从便于维护的角度考虑, 一般我们最常见的都是提交给当前文件, 然后在当前文件中判断是否表单的提交请求

```php
<?php 
// //	将表单的处理逻辑放在 HTML 之前, 为了更加灵活地去控制 HTML 的输出
// var_dump($_POST);
// 因为对于表单的处理逻辑不是每一次都需要执行,所以一般我们会判断请求的方式, 从而决定是否执行对数据的处理
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
	//	请求的方式是POST, 表示是点击的按钮产生的请求
	var_dump($_POST);
}
?>
```

另外, 建议使用 `$_SERVER['PHP_SELF']` 动态获取当前页面访问路径, 这就不会因为文件重命名或者网站目录结构调整而修改代码.

```php
<!-- 这样写死 action 地址, 当文件重命名就需要修改代码 -->
<form action="/foo/login.php">
    <!-- .... -->
</form>
    
<!-- 通过 `$_SERVER['PHP_SELF']` 获取路径, 可以轻松避免以上问题 -->
<form action="<?php echo $_SERVER['PHP_SELF']; ?>">
    <!-- .... -->
</form>    
```

> 鲁棒性: 指的是我们的程序应对变化的能力

#### 常见表单元素处理

表单元素中的文本框文本域一类的元素, 都是直接将元素的 `name` 属性作为键值, 用户填写信息作为值, 发送到服务端.但是表单元素中还有一些比较特殊的表单元素需要特别考虑 :

- **单选框的数据处理**

Radio button: 可以出现多个选择项, 但是只能选中一个.

1. 表单中使用 name 属性, 使用同名即可:只能选一个
2. 后台接受数据也不需要额外的处理
3. 数据库存储的话, 只需要一个字段存储普通数据即可(数字或字符串).

```html
<!-- 当表单中使用了radio, 一定要为相同的name设置不同的 value , 让服务端可以辨别 -->
<label for=""><input type="radio" name='gender' value="1" checked>男</label>
<label for=""><input type="radio" name='gender' value="2">女</label>
```

![53499398980](.\php\1534993989803.png)

- **复选框数据处理**

复选框: 通常是将一类内容以同样(同名) 的形式传递给后台, 数据库存储通常是一个字段存储. 复选框特点: 选中才会提交.

1. 在浏览器端, checkbox 的 name 属性的值不论什么都会被浏览器毫无保留地提交
2. 在 php 中 \$_POST,\$_GET 都会对同名 name 进行覆盖.

解决方案: 在浏览器端, 浏览器不识别 `[]` (浏览器不认为有特殊性), 但 php 认为 `[]` 有特殊性: 系统自动认为该符号是数组的形式, 所以 php 就会自动地将同名的但是带有 `[]` 的元素组合到一起形成一个数组.

```html
<!-- 没有设置 value 的 checkbox 选中提交的是 on -->
<input type="checkbox" name="agree">
<!-- 设置了 value 的 checkbox 选中提交的是 value 值 -->
<input type="checkbox" name="agree" value="true">
```

如果需要同时提交多个选中项, 可以在 `name` 属性值后面跟上 `[]` , 在 PHP 中会提交一个数组,保存选中项.

```html
<!-- 复选框的多选, 在name值后添加[], 以数组方式提交多个选项 -->
<label for=""><input type="checkbox" name="hobbies[]" id="" value="football">足球</label>
<label for=""><input type="checkbox" name="hobbies[]" id="" value="basketball">篮球</label>
<label for=""><input type="checkbox" name="hobbies[]" id="" value="earch">地球</label>
```

php 接收复选框数据的形式: 

![53499323650](.\php\1534993236506.png)

后台接收到数据之后, 是一个数组(数组不能存储到数据库)

此时 php 就需要价格数组转换成指定格式的字符串: 使用 **分隔符分隔每一个元素并且形成字符串**.

反之, 在取出sql数据的时候, 我们也需要将含有指定分隔符的字符串转换成数组格式.

```php
implode('分隔符', 数组);		 //	数组 -> 字符串
//	判断取出来的数据是否是一个数组: 是否有某个分隔符存在, 是的话使用 explode 进行字符串数组化
explode('分隔符', 字符串);	//	字符串 -> 数组
//	查看数组中是否存在某个元素
in_array();
```

![53499489240](.\php\1534994892403.png)

- 其它同名表单项的数据处理

除开 radio button 单选框 和 checked 复选框, 很少会出现同名的表单项. 如果非要使用同名的来进行管理, 那么可以采用 checkbox 方式进行操作.

1. 表单中同名增加`[]`
2. php接收时数组处理
3. php 转换成有格式的字符串
4. 数据库字符串存储

**复选框细节问题**

如果复选框没有选中, 浏览器就不会提交. 因此在 php 接收使用复选框(单选框) 数据的时候会报错. 因为根本没有对应的 key 值数据传入, 因此应该先判断是否存在该数据.

```php
//	使用 isset() 判断数据是否存在
$cd = isset($_REQUEST['hobbies'])? $_REQUEST['hobbies'] : array();
```

![53499606031](.\php\1534996060313.png)

- 选择框

```html
<!-- 选择框, 默认提交 value 值, 没有value的情况下,会提交文本内容  -->
<select name="status">
    <option value="激活">激活</option>
    <option value="未激活">未激活</option>
    <option value="待激活">待激活</option>
</select>
```

### 文件上传

**原理**

文件上传: 用户从用户本地电脑通过传输方式 (web 表单) 保存到服务器所在电脑的**指定目录下**.

**基本步骤**

1. 增加文件上传的表单: 浏览器请求一个服务器的 HTML 脚本 (包括文件上传表单).
2. 用户从本地选择一个文件 (点击上传框按钮).
3. 用户点击上传: 文件会通过物联网传输到 **服务器** 上.
4. 服务器操作系统会将文件保存到临时目录: 是以临时文件格式保存 (windows 下 tmp)
5. 服务器脚本开始工作: 判断文件有效.
6. 服务器脚本将有效文件从临时目录移动到指定的目录下 (完成).

![53499689751](.\php\1534996897512.png)

- **表单写法**

  1. method 属性: 表单提交必须为 POST 方式
  2. enctype 属性: form 表单属性, 主要规定表单数据 (文件上传必须使用 multipart/form-data ).

   ![53499784887](.\php\1534997848878.png)

- **$_FILES 变量详解**

在 php 中, 有一个预定义变量 `$_FILES` 是专门用于接收文件上传的超全局变量.

`$_FLIES` 同样也是一个关联数组, 键为表单文件域 (文件上传: file) 的 `name` , 内容如下

```php
array(1) {
  ["upload_image"]=>
  array(5) {
    ["name"]=>			//	文件在用户(浏览器端) 电脑上实际的名字, (实际我们用来保存文件后缀)
    string(7) "lya.jpg"			 
    ["type"]=>			//	MIME (多功能互联网邮件扩展) 类型, 用来在计算机客户端识别的文件夹 (确定软件)
    string(10) "image/jpeg"
    ["tmp_name"]=>		//	文件上传到 服务端后操作系统保存的临时路径 (实际用来给php后期使用)
    string(27) "C:\Windows\Temp\php2D6E.tmp"
    ["error"]=>			// 	文件上传的代号, 用来告知 (php) 文件接收过程中出现了什么问题 (通过反馈的问题, php据问题进行文件判断)
    int(0)
    ["size"]=>			//	上传文件的大小 (实际用来给php后期使用,确定是否要保留该文件.)
    int(158561)
  }
}
```

error 代号值反馈问题.

![53500601896](.\php\1535006295247.png)

读取一个文件上传的基本信息.

![53499852068](.\php\1534998520686.png)

- **临时移动到指定目标**

文件上传以后会保存到 $_FILES 中, 那么访问文件信息的形式就是 \$_FILES['表单 name 属性值']\['元素信息']

1. 判断是否为上传的文件: `is_upload_file()`
2. 移动文件: `move_upload_file()`

文件上传执行基本步骤:

```php
//	1. 取得文件信息
$upload_image = $_FILES['upload_image'];
//	2. 判断是否是上传文件: 临时文件
if(is_uploaded_file($upload_image['tmp_name'])){
    //	是上传文件
    if(move_uploaded_file($upload_image['tmp_name'], 'uploads/'.time().$upload_image['name'])){
        //	上传成功
        echo '文件保存成功';
    }else{
    	echo '文件保存失败';
    }
}else{
	//  不是上传文件
    echo '文件上传失败!';
}
```

- **多文件上传**

当商品需要上传多个图片进行展示的时候: 需要使用多文件上传(针对一个内容但不同文件说明: 同名表单)

![53500810647](.\php\1535008137897.png)

当商品需要多个纬度图片说明的时候: 需要多文件上传(针对不同内容所以表单名字不一样: 批量解决问题)

![53500825935](.\php\1535008259355.png)

**多文件上传的 $_FILES 变量的数据结构形式**

批量上传: 同名表单, 将表单名字形成一个数组, 而且同时文件对应的五个要素: `name` `tmp_name` `size` `type` `error` 都形成响应数量的数组, 每个文件上传的数组元素的下标都是一样的,如 `name[0]` 和 `type[0]` 是属于同一个文件.

![53500902277](.\php\1535009022779.png)

批量上传: 不同名表单: 每一个文件都会形成属于自己独立的信息数组, 没有合并.

![53500920329](.\php\1535009203297.png)

**多文件上传文件信息的遍历读取和处理**

1. 不同名多文件上传处理方式: 按照表单名字从\$_FILES  中取出来就可以直接使用 (明确知道表单中有多少个文件上传); 如果不确定表单中有多少个文件上传. 不适合挨个去取(效率不高). 可以通过遍历 \$_FILES 数组, 挨个取出来实现文件上传.

   ```php
   foreach($_FILES as $file){
       //	$file 就是一个完整的上传文件信息: 找到临时路径,指定存放路径
       if(is_uploaded_file($file['tmp_name'])){
           //	存储
           if(move_uploaded_file($file['tmp_name]), 'uploads/'.time().$file['name'])){
           	echo '上传成功';
           }else{
           	echo '上传失败';
           }
       }
   }
   ```

   ![53501086677](.\php\1535010866770.png)

2. 同名多文件上传处理: 想办法得到一个文件对应的5个元素数组(拼凑). 从$_FILES 中把对应的 name/tmp_name/... 取出来, 然后存放到不同的数组中.处理完毕, 再挨个遍历上传.

   ```php
   //	需要遍 $_FILES['userfile']['任意一个要素':name|tmp_name|..]
   //	判断元素存在而且是数组: name 有 代表是文件, name元素有多个(数组) 代表是同名批量上传
   if(isset($_FILES['upload_image']['name']) && is_array($_FILES['upload_image']['name'])){
       //	遍历构造数组元素
       $images = array();
       foreach($_FILES['upload_image']['name'] as $k => $file){
           $images[] = array(
           	'name' => $file,
               'tmp_name' => $_FILES['upload_image']['tmp_name'][$k],
               'type' => $_FILES['upload_image']['type'][$k],
               'error' => $_FILES['upload_image']['error'][$k],
               'size' => $_FILES['upload_image']['size'][$k]
           );
       }
       var_dump($images);
   } 
   ```

   ![53501199597](.\php\1535011995976.png)

   后续上传步骤如上一般无二.

#### 文件上传(封装)

文件上传后续问题

实现上传功能, 代码的重复利用: 封装文件上传函数

条件: 条件判断

1. 需要上传的文件信息, 对应的五个元素的数组.
2. 文件类型是否合适? 外部指定 MIME 类型
3. 文件存储目标位置? 外部指定
4. 文件格式限制(文件后缀名)? 外部指定
5. 文件大小限制? 外部指定

结果: 实现文件上传

1.  成功: 结果能够以后看看到(存储到数据): 需要将文件的路径和文件名字返回
2. 失败: 返回 false, 同时指定错误原因 (引用参数)

步骤:

1. 封装出一个文件上传函数

   ![53501789506](.\php\1535017895060.png)

2. 判断文件是否有效

   ![53501791292](.\php\1535017912927.png)

3. 判断文件存储路径是否有效

   ![53501793364](.\php\1535017933649.png)

4. 判断文件上传过程是否出错

   ![53501795488](.\php\1535017954886.png)

5. 文件类型的处理

   ![53501797144](.\php\1535017971447.png)

6. 文件格式的处理(后缀)

   ![53501800082](.\php\1535018000823.png)

7. 文件大小的处理

   ![53501801647](.\php\1535018016474.png)

```php
 /*
 * 实现文件上传(单)
 * @param1 array $file, 需要上传的文件信息: 一维5个元素的数组 (name\tmp_name\error\size\type)
 * @param2 array $allow_type, 允许上传的 mime 类型
 * @param3 string $path, 存储的路径
 * @param4 string &$error, 如果出现错误的原因
 * @param5 array $allow_forrmat = array(), 允许上传的文件格式
 * @param6 int $max_size =2000000 允许上传的最大值
 **/

function upload_single($file, $allow_type, $path, &$error, $allow_format = array(), $max_size = 2000000)
{
    // 判断文件是有效
    if (!is_array($file) || !isset($file['error'])) {
        $error = '不是一个有效的文件.';
        return false;
    }
    //  判断文件存储路径是否有效
    if (!is_dir($path)) {
        $error = '文件存储路径不存在!';
    }
    //  判断上传文件过程是否出错
    switch ($file['error']) {
        case 1:
        case 2:
            $error = '文件超出服务器允许大小';
            return false;
        case 3:
            $error = '文件上传过程中出现了问题, 只上传了一部分.';
            return false;
        case 4:
            $error = '用户没有选择文件';
            return false;
        case 6:
        case 7:
            $error = '文件保存失败!';
            return false;
    }
    //  判断文件类型是否允许: 通过 MIME 匹配即可.
    if (!in_array($file['type'], $allow_type)) {
        $error = '当前文件类型不允许上传!';
        return false;
    }
    //  文件各式处理: 后缀名的问题
    $ext = ltrim(strrchr($file['name'], '.'), '.');  //  不带.的后缀
    if (!empty($allow_format) && !in_array($ext, $allow_format)) {
        //  不允许上传
        $error = '当前文件的格式不允许';
        return false;
    }
    //  判断当前文件大小是否满足当前需求
    if ($file['size'] > $max_size) {
        //  文件过大
        $error = '当前文件上传超出限定大小, 最大允许为 ' . $max_size . ' 字节';
        return false;
    }
    //  文件重命名: 类型_年月日_随机字符串.$ext;
    $fullname = strstr($file['type'], '/', true) . date('Ymd_his_') . rand(0, 10000);
    //  随机字符串
    for ($i = 0; $i < 4; $i++) {
        $fullname .= chr(mt_rand(65, 90));
    }
    $fullname .= '.' . $ext;
    //  移动文件到指定目录:
    if (!is_uploaded_file($file['tmp_name'])) {
        $error = '错误, 不是上传文件';
        return false;
    }
    if (move_uploaded_file($file['tmp_name'], $path . '/' . $fullname)) {
        //  成功: 返回文件名字, 路径.
        return $fullname;
    } else {
        $error = '文件上传失败!';
        return false;
    }
}
```

使用

```php
$file = $_FILES['upload_image'];
$allow_type = array('image/jpg', 'image/jpeg', 'image/gif', 'image/pjped', 'image/png');
$allow_format = array('jpg', 'gif', 'jpeg', 'png');
$path = 'uploads';
$max_size = 8000000;

if ($upload_name = upload_single($file, $allow_type, $path, $error, $allow_format, $max_size)) {
    echo $upload_name;
} else {
    echo $error;
}
```

**案例演示(使用文件上传封装函数)**

```php
<?php

//  用户头像修改脚本
header('content-type:application/x-www-form-urlencoded;charset=utf-8');
header('Access-Control-Allow-Origin: *');
header("Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept");
header('Access-Control-Allow-Methods: GET, POST, PUT,DELETE');

include_once 'upload_func.php';	//	文件上传函数
include_once 'sql_init.php';

$file = $_FILES['file'];
$id = $_POST['userId'];

$allow_type = array('image/jpg', 'image/jpeg', 'image/gif', 'image/pjped', 'image/png');
$allow_format = array('jpg', 'gif', 'jpeg', 'png');
$path = 'upload/web/user/avatar';
$max_size = 2000000;

if ($upload_name = upload_single($file, $allow_type, $path, $error, $allow_format, $max_size)) {
    $avatar_link = "http://websites.io/upload/web/user/avatar/{$upload_name}";
    //  持久保存数据
    $sql = "update user_desc set avatar = '{$avatar_link}' where id={$id}";
    if (sql_error($con, $sql)) {
        //  成功保存数据到数据库 返回头像地址给前端
        echo json_encode(array('err_code' => 0, 'msg' => 'ok', 'avatar' => $avatar_link));
    } else {
        echo json_encode(array('err_code' => 1, 'msg' => '数据保存失败'));
    }
} else {
    echo $error;
}
```

![53685096956](.\php\1536850969561.png)

```javascript
//	上传头像前端逻辑
upload_a(e) {
    //  上传头像逻辑
    var self = this;
    let file = e.target.files[0];
    let param = new FormData(); // 创建form对象
    param.append("file", file, file.name); // 通过append向form对象添加数据
    param.append("userId", self.user_info["id"]);
    //   param.append("chunk", "0"); // 添加form表单中其他数据
    //   console.log(param.get('file')) // FormData私有类对象，访问不到，可以通过get判断值是否传进去
    this.$axios
        .post("http://websites.io/change_user_avatar.php", param, {
        headers: { "Content-Type": "multipart/form-data" }
    })
        .then(res => {
        if (res.status == 200) {
            // console.log(res.data);
            this.$router.go(0);
        }
    })
        .catch(err => {
        console.log(err);
    });
}
```



**小案例演示(未使用文件上传封装函数)**

```php+HTML
<?php 
function upload(){
	global $message;
	if(!isset($_FILES['f1'])){
		// 客户端提交的表单内容中没有文件域
		$message = '别逗了!';
		return;
	}
	// var_dump($_FILES);
	$avatar = $_FILES['f1'];
	/*array(5) { 
		["name"]=> string(16) "量身制作.jpg" 
		["type"]=> string(10) "image/jpeg" 
		["tmp_name"]=> string(27) "C:\Windows\Temp\phpCFCB.tmp" 
		["error"]=> int(0) ["size"]=> int(91236) 
	}*/
	// UPLOAD_ERR_OK 是被语义化的 0
	if ($avatar['error'] !== UPLOAD_ERR_OK) {
		$message = '上传失败!';
		return;
	}
	//	接收到文件
	//	将临时目录移动到网站范围下

	$source = $avatar['tmp_name'];	//	源文件在哪里
	//	-> 'C:\Windows\Temp\phpCFCB.tmp'
	$target = './upload/' . $avatar['name'];	//	目标放哪里
	//	-> './upload/量身制作.jpg'
	//	移动的目标路径中的文件夹一定要是已经存在的目录
	$moved = move_uploaded_file($source, $target);	
	
	if(!$moved){
		$message = '上传失败';
		return;
	}

	//	移动成功(上传是整个过程ok)
	$message = '上传成功';
}

if($_SERVER['REQUEST_METHOD'] === 'POST'){
	//	接收文件, 使用一个 叫做 $_FILES 超全局成员
	upload();
}

?>
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
	<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post" enctype="multipart/form-data">
		<input type="file" name="f1" id="">
		<button>上传</button>
		<?php if (isset($message)): ?>
			<p style="color:hotpink"><?php echo $message ?></p>
		<?php endif ?>
	</form>
</body>
</html>
```



### 富文本编辑器 (Markdown)

1. 传统的富文本编辑器 ( HTML )

- TinyMCE
- CKEDITOR
- **UEditor 百度富文本编辑器** : 基本使用请查看 mysql 扩展的 增删查改案例 中如何使用该编辑器.

2. Markdown 编辑器

- SimpleMDE

  > https://simplemde.com/
  >
  > https://github.com/sparksuite/simplemde-markdown-editor

### 案例

#### 基于文件的注册和登录

- 注册

```php
<?php 
/* 接收用户提交的表单数据, 保存到文件. */	

function postBack(){
	//	表单处理三部曲
	//	1 接收并且校验表单数据.
	//	2 持久化 (将数据持久保存到磁盘).
	//  3 响应 (服务端的反馈).

	//	接受用户提交的数据， 保存文件.
	//  任何在客户端提交的信息, 都不能相信
	//	a.校验参数的完整性

	//	php全局作用域问题, 此处需要申明 $tempmessage 作为全局的变量
	global $tempmessage;
	if(empty($_POST['username'])){
		//要么没有提交用户名 或 是用户名为空字符串.
		$tempmessage = '请输入用户名';
		return;
	}
	if(empty($_POST['password'])){
		$tempmessage = '请输入密码';
		return;
	}
	if(empty($_POST['confirm'])){
		$tempmessage = '请输入确认密码';
		return;
	}
	if($_POST['password'] !== $_POST['confirm']){
		$tempmessage = '请确认输入的两次密码相同';
		return;
	}
	if(!(isset($_POST['agree']) && $_POST['agree'] === 'true')){
		$tempmessage = '必需要同意协议';
		return;
	}
	//	所有校验都成功
	$tempmessage = '恭喜, 注册成功';
	$username = $_POST['username'];
	$password = $_POST['password'];
	//	b.将用户名和密码保存到 txt文件中
	file_put_contents('users.txt', $username. '|' . $password . "\n", FILE_APPEND);
}

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
	postBack();
}

?>
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>注册页面</title>
</head>
<body>
	<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post">
		<table>
			<thead>
				<tr>
					<td colspan="2" style="text-align:center;">用户注册</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><label for="username">用户名</label></td>
					<td><input type="text" name="username" id="username" value="<?php echo isset($_POST['username']) ? $_POST['username'] : ''; ?>"></td>
				</tr>
				<tr>
					<td><label for="password">密码</label></td>
					<td><input type="password" name="password" id="password"></td>
				</tr>
				<tr>
					<td><label for="confirm">确认密码</label></td>
					<td><input type="password" name="confirm" id="confirm"></td>
				</tr>
				<tr>
					<td colspan="2">
						<label><input type="checkbox" value="true" name="agree">同意协议</label>
					</td>	
				</tr>
				<?php if (isset($tempmessage)): ?>
				<tr>
					<td colspan="2"><?php echo $tempmessage ?></td>
				</tr>
				<?php endif ?>
				<tr>
					<td colspan="2">
						<input type="submit" value="注册">
					</td>
				</tr>
			</tbody>
		</table>
	</form>
</body>
</html>
```

### *音乐列表案例

#### JSON 表述

> ​	JSON 是一种通过普通字符串描述数据的手段, 用于表示有结构的数据. 与 JavaScript 中的字面量类似.
>
> 差异:
>
> - JSON 中 属性名称必须用双引号包裹
> - JSON 中 字符串必须用双引号包裹
> - JSON 中 不允许使用注释
>
> `json_decode()`    把JSON格式的字符串转换成对象的过程叫反序列化    `JSON.parse()` 
>
> `json_encode()`     把JSON格式换成JSON字符串的过程叫序列化      `JSON.stringify()` 

#### 功能实现

##### 列表数据展示

- 文件读取 `file_get_contents()`
- JSON 反序列化
  - json_decode()
  - 希望以关联数组方式而非对象方式操作,则需要给予第二个参数 true
- 数组遍历 foreach
- PHP 与 HTML 混编
- 删除按钮 get 传递参数 

##### 新增数据 (表单类)

- 表单使用 (form action method enctype, input name label multiple)
- 服务端表单检验并提示错误消息
  - empty 判断一个成员是否定义或者值为 false
- 上传文件
  - 文件数量
  - 文件种类
  - 需要考虑文件重名问题
- 单文件域或多文件上传
  - name 一定以 [] 结尾, 服务端会接收一个数组
- JSON 序列化
- 文件写入

**写代码前一定要先搞定思路 !**

------

## Mysql 扩展

### 准备工作

#### 简介

> 目标
>
> - 什么是数据库
> - 通过工具操作数据库
> - 通过代码操作数据库

数据库是数据的仓库, 按照特定的结构去阻止和管理数据, 有了它我们就可以更加方便地操作 (增删查改).

#### 安装与配置（5.7版本）压缩版

> https://dev.mysql.com/downloads/mysql/

**安装目录过程**

1.解压目录添加 `my.ini`

```php
[mysqld]
# mysql 安装目录
basedire = D:/mysql
# 数据文件所在目录
datadir = D:/mysql/data
```

2.配置环境变量，将解压目录下的bin文件夹的路径配置到系统变量中的path下

3.以管理员身份运行 CMD 执行以下命令, 安装一个 MySQL 服务

```php
# 定位到安装目录下的 bin 文件夹
cd <MySQL安装目录>/bin
# 初始化数据所需文件以及获取一个临时访问密码            
mysqld --initialize --user=mysql --console
# 安装服务 mysqld --install 服务名
mysqld --install MySQL
# 启动服务 
net start MySQL
```

**删除服务** 管理员权限运行 => 输入`sc delete 服务名 `

4.登入 MySQL 服务器, 重置密码

```php
# 先通过用户名密码进入 MySQL 操作环境
mysql -u root -p
Enter password: # 输入临时密码
# 设置数据库访问密码 
mysql> set password for root@localhost = password('woaiwo');
```

### 基础操作

#### 数据库管理工具

##### 命令行工具

一般如果是只是简单操作数据库, 推荐使用MySQL 内置的命令行工具完成

通过命令行运行 解压目录下 `bin` 目录下的 `mysql` 文件 

```php
# 定制到 bin 目录
cd <解压目录>/bin
# 运行 mysql -u 指定数据库用户名 -p 指定密码
mysql -u root -p
# 输入密码 woaiwo
```

```sql
/*查看数据库*/	
show databases;
/*创建数据库 creata database 库名*/	
create database demo;
/*使用 demo 数据库*/	
use demo;
/*查表*/	
show tables;
/*创建表 create table*/	
create table users (id int, name char(5), age int, gender int);
/*查看表结构 desc 表名*/
desc users
/*删除表 drop table 表名*/
drop table users;
/*删除数据库 drop database 数据库名*/
drop database demo;
```

##### 可视化工具

**Navicat Premium**

#### 基本概念

 库/表/字段

#### 基本查询语句

**新增**

```mysql
/*新增数据*/
insert into `users` values (null, '小白', 18, 0);
insert into `users` (name, age, gender) values ('小怪', '18', 1);
```

**删除**

```mysql
/*删除 一定要配合数据筛选*/
delete from `users` where `id` = 1;
delete from `users` where `id` in(1,2,3,4);
```

**修改**

```mysql
/*修改*/
update `users` set `name` = '萌小白' where  `id` in (2,3,4,5); 
update `users` set `name` = '懵', `age` = 18 where `id`= 2;
```

**查询**

```mysql
/*基础查询*/ 
SELECT `id`, `title` FROM `users`;
/*使用通配符会产生全表扫描, 建议指定列名*/  
select * from users;
/*select 语句可以选择 列 或者一个具体的 值*/
select 1 from users;
```

**筛选条件**

- 子语句, 意思是不能单独执行, 必须配合删除/修改/查询语句

```mysql
delete from `users` where `id` = 6;
delete from `users` where `id` = 6 and `gender` = 0;
delete from `users` where `id` = 6 or `gender` = 0;
delete from `users` where `id` > 6;
delete from `users` where `id` in (4,5);
```

#### 常见查询函数

- 总条数 -- count 分页功能, 查询总页数
- 最大值/最小值 -- max/min
- 平均值 -- avg

```mysql
select count(id) from `users`;
/*一般我们这样查询数据表的总数据个数*/
select count(1) as count from `users`;
/*最大值*/
select max(id) from `users`;
/*最小值*/
select min(id) from `users`;
/*平均值*/
select avg(id) from `users`;
```

 **多表联合查询 √**

![52749569673](.\php\1527495696737.png)

####   分页查询数据

**子语句**

 `limit <skip>, <length>`

`skip = (page - 1) * length`

```mysql
/*limit 子语句/*
/*一个参数: 限制取几条*/
select * from `users` limit 2;
/*两个参数: 越过几条,取几条*/
select * from `users` limit 0, 2;
/*page 页码, size 数量, skip 越过的条数*/
skip = (page - 1) * size
```

### PHP 操作数据库

PHP 针对 MySQL 数据库操作提供的扩展: 允许 php 当做 MySQL 的一个客户端连接服务器进行操作.

![52698760986](.\php\1526987609862.png)

#### 连库数据库基本操作

**接数据库服务器**

`$connection = mysqli_connect('127.0.0.1', 'root', 'woaiwo', 'demo')`

```php
//	建立连接 
//	参数1: 主机地址, 默认是自动连接端口3306
$connection = mysqli_connect('localhost:3306','root','woaiwo');
//	$connection = mysqli_connect('localhost:3306','root','woaiwo', 'my_studyphp');
```

连接资源(不可以省略. mysqli扩展), 任何地方都可以使用该资源进行数据库操作. 

`mysqli_connect` 可以指定第四个参数: 即是使用数据库

**设置连接编码**

保持客户端与服务端的沟通流畅.

1. 如何设置连接编码

```php
mysqli_set_charset($connection, 'utf8');
mysqli_query($connection, 'set names utf8');
```

![53502365967](.\php\1535023659670.png)

2. 怎么确定要使用何种编码?

根据客户端当前执行脚本的工具使用什么字符集, 就设定成什么字符集  (vscode等编辑器 我使用utf8).

**选择数据库**

```php
mysqli_query($connection,'use my_studyphp');
mysqli_select_db($connection, 'my_studyphp');
```

**执行查询语句**

`$query = mysqli_query($connection, 'select * from users');`

```php
//	校验查询语句是否成功执行
$query = mysqli_query($connection, 'SQL查询语句');
var_dump($query); 
```

**校检查询语句**

`$res_select = mysqli_fetch_assoc($query);`

```php
//	校验查询语句是否成功执行
$res_select = mysqli_fetch_assoc($query);
var_dump($res_select);	
```

**校检增删改查询语句**

`$res_rows= mysqli_affected_rows($connection);`

```php
//	校验增删改语句是否成功执行
$res_rows= mysqli_affected_rows($connection);
var_dump($res_rows);
```

**关闭连接**

主动释放连接: MySQL 服务器的链接资源是有限的, 不用了需要释放 (脚本执行结束系统也会自动关闭)

`mysqli_close($connection);`

```php
//	校验释放数据是否成功执行
$res = mysqli_close($connection);	
var_dump($res);
```

#### 数据库基本操作

```mysql
create table n_news(
    id int primary key auto_increment,
    title varchar(50) not null comment '新闻标题',
    isTop tinyint not null comment '是否置顶',
    content text comment '内容',
    publiser varchar(20) not null comment '发布人',
    pub_time int not null comment '发布时间'
)charset utf8;
```

![53503773719](.\php\1535037737195.png)

制作一个专门负责数据库初始化的脚本: 之后要操作数据库包含改脚本即可.

![53503832136](.\php\1535038321361.png)

##### **增/删/改 操作**

1. mysqli_query('insert....') :通过 inset 指向指定表插入对应的数据

   ![53503882656](.\php\1535038826561.png)


2. mysqli_query('update....') :通过 update 指向指定表修改对应的数据

   ![53503920682](.\php\1535039206820.png)

3. mysqli_query('delete...') :通过 delete 指向指定表删除对应的数据

   ![53503942728](.\php\1535039427283.png)

判断执行结果: 

1. 执行成功, 结果为 ture, 只代表 SQL 指令执行成功
2. 执行失败, 结果为 false, 只代表 SQL 指令执行失败或操作对象不存在.

##### **查询 操作**

1. 执行查询语句

   ```php
   //	1. mysqli_query('select..');
   $ret = mysqli_query($connection, "select * from n_news");
   //	2. 其它类似查询语句, 比如: show语句, desc 语句
   //	以上两种情况的总结: 凡是执行操作希望拿到数据库返回的数据进行展示的(结果返回: 数据结果)
   //	执行结果的处理: 成功为结果集, 失败为 false, 成功返回结果: SQL 没有错误, 但是如果查询结果本身为空也返回 true 结果集是一种资源: 转换成 bool 永远为 true); 失败为false, sql语句出错.
   ```

   ![53507640167](.\php\1535076401672.png)

2. 获取结果集行数

   ```php
   echo mysqli_num_rows($ret);
   ```

   ![53507654030](.\php\1535076540307.png)

3. 解析结果集

   将一种结果集资源 (PHP不能直接使用), 转换成一种 php 能够解析的数据格式: **通过从结果集中 (结果集指针: 类似数组指针), 按照结果集所在位置去除对应的一条记录 (一行). 返回一个数组. 同时指针下移. 直到指针移出结果集.**

   ```php
   //	获取关联数组: 表的表单名字作为数组下标, 元素值作为数组元素值.
   mysqli_fetch_assoc();

   //	获取索引数组: 只获取数据的值, 数组的下标从 0 开始自动开始
   mysqli_fetch_row();

   //	获取关联或者索引数组, 默认同时存在.(取两次, 一组关联, 一组索引).
   //	可以指定第二个参数来决定获取方式: MYSQLI_ASSOC 只获取关联数组 / MYSQLI_NUM 只获取索引数组
   mysqli_fetch_array();
   ```

   1. `mysqli_fetch_assoc();`

   ![53507700998](.\php\1535077009984.png)

   2. `mysqli_fetch_row();`

   ![53507718251](.\php\1535077182514.png)

   3. `mysqli_fetch_array();`

   ![53507735205](.\php\1535077352050.png)

   ![53507752518](.\php\1535077525184.png)

通常结果集的操作: 一般是获取所有 (全部记录). 遍历循环操作使得指针的下移直至溢出结果集

#### Mysqli扩展其它相关函数

**有关字段信息**

1. `mysqli_num_fields()`

   ```php
   //	获取结果集中所有的字段数量
   mysqli_num_fields($ret);
   ```

   ![53507812836](.\php\1535078128366.png)

2. `mysql扩展 中是 mysql_field_name(); ` 但是在 mysqli扩展中我没找到.

   ```php
   //	获取一个指定结果集中指定位置的字段名字
   //  1. 遍历汇集表的字段名字组成一个字段数组
   $infos = mysqli_fetch_assoc($ret);
   $ret2 = array();
   foreach ($infos as $key => $value) {
       $ret2[] = $key;
   }
   var_dump($ret2);
   //	2. 再根据给定下标取值
   echo $ret[1];
   ```

   ![53508061452](.\php\1535080614520.png)

**有关出错信息**

1. mysqli_error()
2. mysqli_errno()

```php
mysqli_error($connection);
mysqli_errno($connection);
```

![53508320144](.\php\1535083201448.png)

**其它函数**

1. mysqli_insert_id(): 获取上次插入语句(有 auto_increment) 的自增长 ID

![53508375549](.\php\1535083755498.png)

####案例: 新闻增删改查

##### 添加新闻表单

1. 用户获取到一个可以添加新闻表单的HTML文件
   1. 页面的制作, 表单选项的处理.

   2. 关于**富文本编辑器**

      ```
      # 	这里使用了 百度的 ueditor 富文本编辑器.
      具体使用方法: 
      	1.	下载 作为 静态资源保存到 更目录的 public 下
      	2. 	修改 ueditor 配置
      	3.  main.js 中引入 ueditor 相关
      ```

      **下载及配置**

      ![53530623941](.\php\1535306239418.png)

      ![53530632506](.\php\1535306325065.png)

      ![53530640437](.\php\1535306404374.png)

      **vue中使用**

      ![53530648606](.\php\1535306486069.png)

      ![53530676592](.\php\1535306765926.png)

2. 用户提交数据到后台指定的 php 脚本(POST)

3. 后台脚本处理数据, 插入到数据库
   1. 接收数据

      ![53533950650](./PHP\1535339506501.png)

   2. 验证数据合法性验证(标题不为空,内容不能为空)

      ![53533954463](./PHP\1535339544634.png)

      ![53533977837](./PHP\1535339778370.png)

   3. 插入数据

4. 提示用户操作结果, 并调整到列表页(详情页)


##### 显示新闻列表

讲述库中所有的新闻信息或取出来, 然后讨要 html 提供的现实目标把数据全部按照指定位置和格式输出显示

1. 从数据库中获取所有的新闻数据: php脚本

   ![53534061502](./PHP\1535340615029.png)

   从结果集中取出所有数据: 一次一条, 一条一个数组, 然后将所有记录放到一个数组中: 形成一个典型的二维数组

   ![53534260226](./PHP\1535342602260.png)

2. 有一个已经制定好的 html 模板能够显示数据: 前端

   ![53535577949](./PHP\1535355779493.png)

3. 前端请求php脚本回调, 渲染指定的 模板 页面

   ![53535581117](./PHP\1535355811173.png)

##### **删除新闻**

 通过用户选中某一个新闻点击删除实现从数据库移除此新闻

1. 显示全部新闻

2. 给用户提供对应的按钮

3. 实现点针对指定新闻

   ![53536237282](./PHP\1535362372827.png)

4. 专门的 php 脚本负责响应用户的点击: 点那条删那条(验证/sql操作/返回结果)

   ![53536239888](./PHP\1535362398885.png)

##### **新闻修改**

​	修改新闻指通过该某个取到想修改的新闻, 然后点击之后能够修改对应的新闻信息, 最后点击保存实现修改更新到数据库

1. 需要看到想要编辑的新闻: 在列表查询的时候已经完成

2. 可以点击实现查看对应的新闻详情: 根据传入的 id

   ![53543028652](./PHP\1535430286522.png)

   ![53543032632](./PHP\1535430326322.png)

3. 需要一个 php 脚本处理这件事情, 并且前端渲染页面

   ![53543039638](./PHP\1535430396380.png)

   ![53543044900](./PHP\1535430449004.png)

4. 需要一个 页面 来展示当前要编辑的数据

   ![53543023758](./PHP\1535430237584.png)

5. 需要一个 php 脚本能够接受修改后的数据并保存到数据库

   ![53543048369](./PHP\1535430483695.png)


##### 模糊查找显示数据

1. 前端传入查找字段, 给后端

   ![53543294167](./PHP\1535432941674.png)

   ![53543296466](./PHP\1535433090746.png)

2. php 端需要脚本支持 数据库 按条件(标题)进行模糊查找功能

   ![53543298399](./PHP\1535432983992.png)

3. 返回查找数据给前端, 前端进行数据替换

   ![53543302836](./PHP\1535433028364.png)

   ![53543306886](./PHP\1535433068868.png)






**用户数据列表请求示意图**

![52701925205](.\php\1527019252055.png)

------

## HTTP 协议

**概念**

HTTP 协议, 即**超文本传输协议**(Hypertext transfer protocol). 是一种详细规定了 **浏览器** 和万维网 **服务器** 之间互相通信的规则, 通过因特网传送万维网文档的数据传送协议.

HTTP 协议是用于从 www 服务器传输超文本到本地浏览器的传送协议. 它可以使浏览器更加高效, 使网络传输减少.不仅保证计算机正确地传输超文本文档, 还确定传输文本文档中的哪一部分, 以及哪部分内容首先显示(如文先于图形)等.

**特点**

1. 客户/服务器模式: 客户端(浏览器)/服务端
2. 简单快速: 客户向服务器请求服务时, 只需传送请求方法和路径.
3. 灵活: HTTP 允许传输任意类型的数据对象(MIME 类型).
4. 无连接: 限制每次连接只处理一个请求. 服务端处理完客户端请求, 并收到客户的应答后, 即刻断开连接. 采用这种方式可以节省传输时间.
5. 无状态: HTTP 协议是无状态协议. 无状态是指协议对于事务处理没有记忆能力.

###约定内容

- 请求/响应报文
- 请求方法 -- get / post / etc
- 响应状态 -- 200 / 404 / 302 /..
- 预设的请求 / 响应头

### 约定形式

- 客户端通过随机端口与服务端某个固定端口(一般是80) **建立连接**,三次握手(确认连接正常)

- 客户端通过这个连接 **发送请求** 到服务端 (这里的请求是名词.包)

- 服务端监听端口得到的客户端发送来的请求

- 服务端通过连接响应给客户端状态和内容(响应报文)

  > 希望自己没打开一个页面都可能脑补此画面.

### HTTP协议 分类

**HTTP 请求协议/HTTP 响应协议**

#### HTTP 请求协议

- **请求行**

1. 形式: `请求方式 资源路径 协议版本号 (GET/index.php HTTP/1.1)`

最早的时候 HTTTP 协议有过 1.0, 请求行独占一行(第一行)

- **请求头**

  请求头就是各项协议内容: 具体的协议内容不会每次都使用全部

1. Host: 请求的主机地址(必须)
2. Accept: 当前请求能够接收服务器返回类型(MIME类型)
3. Accept_Language: 接收的语言
4. User-Agent: 可火狐浏览器说实在点的一些信息

请求头不固定数量, 每一个请求协议也是独占一行, 最后会有一行空行(用来区分请求头和请求体)

- **请求体**

  请求数据: POST 请求会有请求头. GET 请求所有的数据都是跟在 URL 之后, 会在请求行中的资源路径上体现.

  基本格式: 资源名字=资源值&资源名字=资源值

 **请求报文信息**

![53544309810](./PHP\1535443098107.png)

![52708418875](.\php\1527084188752.png)

#### HTTP 响应协议

- **响应行**

  形式: `协议版本号 状态码 状态消息  (HTTP/1.1 200 OK)`

  1. 200 ok 成功
  2. 403 Forbidden 没有权限访问
  3. 404 Not Found 未找到页面
  4. 500 Server Internal Error 服务器内部错误

- **响应头**

  1. 时间
  2. 服务器
  3. 内容长度: 具体字节数(响应体)
  4. 内容类型: Content-Type 响应体数据格式

  列举了几个常见的响应头, 并不是全部: 响应头一个占一行, 最后一行空行(区分响应头和响应体)

  ![53544405934](./PHP\1535444059345.png)

- **响应体**

  Response

**响应体信息**

![52708427895](.\php\1527084278952.png)

![52708444151](.\php\1527084441515.png)

#### 常见状态码

- 1XX: 服务器正在处理过程中

  ![53544440752](./PHP\1535444407529.png)

- 2XX: 服务器正确处理

  ![53544445240](./PHP\1535444452402.png)


- 3XX: 请求客户端已转移或者需要更新(重定向)

  ![53544427600](./PHP\1535444276006.png)

- 4XX 客户端错误

  ![53544434836](./PHP\1535444348369.png)

- 5XX 服务器出错

  ![53544437100](./PHP\1535444371006.png)

### 常见HTTP响应设置

PHP 中正对 HTTP 协议(响应) 进行了底层设计, 可以通过函数 header 来实现修改 HTTP 响应(响应头)

注意事项: 

1. Header 可以设计 HTTP 响应, 因为 HTTP 协议特点是: 响应行, 响应头(空行结尾), 响应体. 认为通过 header 设计响应头 的时候, 不应该有任何内容输出, 所以一旦产生内容输出(哪怕一个空格), 系统都会认为响应头已经结束而响应体开始了, 所有如果先输出内容后设置响应头 (header 使用), 理论上设置无效.
2. 在 PHP5 之后, 增加程序缓存内容: 允许服务器脚本在输出内容的时候, 不直接返回浏览器而是在服务器端使用程序缓存保留(php.ini中使用 output_buffering), 有了该内容之后, 在程序缓存内会自动调整响应头和响应体(允许响应头在已经输出的内容之后再设置), 但是此时会报错(警告)
3. 总之: header 设置前我们不会一般不会输出任何内容.

- 设置响应头文件类型(MIME类型)

  - `header('Content-Type: text/css; charset=UTF-8');`

    常见的 HTTP MIME type:  `text/css ` `applcation/javascript` .

- 重定向

  - `header('Location:https://www.baidu.com');` 立即跳转(响应体不用解析)
  - `header('Refresh:3;url=https://www.baidu.com');` 定时跳转(响应体会解析)

- 激活浏览器下载文件

  ```php
  //	让文件下载
  header('Content-Type: application/occtet-stream');
  //	设置默认下载文件名
  header('Content-Disposition:attachment;filename=xxx.ext');
  ```

### 请求响应流程

```php
//	客户端
1. 用户在浏览器中输入 URL 地址
2. 浏览器解析用户输入的 URL 地址 => 域名 + 端口
3. 浏览器会先检查本地缓存有没有这个域名 => IP
4. (无缓存)浏览器再发起一个 DNS 系统调用 => IP *
5. 浏览器会通过一个本地的随机端口建立一个与服务端指定端口之间的"连接通道" (三次握手:确定连接是正确的)
6. 浏览器会将客户端的一些信息打上一个 "包"  
7. 将这个 "包(Request Headers)" 通过"连接通道"发送到服务端
8. 打开服务端返回过来的 "包(Response Headers)", 找到 Content-Type 
9. 根据 Content-Type 决定如何处理响应内容
10.如果是 HTML 则渲染到界面上, 遇到连接,继续由上至下规则请求
//	服务端
    //	Web Server(Apache)
    1. 打开客户端提交过来的"包", 拿到"包"里面的请求路径
    2. 根据请求的路径对应文件的扩展名找到文件的 MIME Type
    3. 判断文件类型是否为静态文件
    4. 如果是静态文件, 则直接读取这个文件的内容
    5. 如果不是静态文件, 交给 "外包公司". 
    6. 服务端会把要发给客户端的数据打上一个 "包"
    7. 将这个"包(Response Headers)" 再通过之前的连接通道发回给客户端
	// DocumentRoot
    // PHP(外包公司)
    1. 读取 php 文件中的代码
    2. 执行代码
    3. 将执行结果返回给 Web Server
// DNS 服务器
DNS 系统调用: 
a.先检查操作系统缓存有没有这个域名 
b.再找系统的 hosts 文件中有没有这个域 
c.如果都没有找到,会对 DNS 服务器发起一个系统调用.
找到对应域名的IP,并且返回这个 IP 给浏览器
```

![请求响应流程](.\php\1527076697640.png)

### PHP模拟HTTP协议

**原理**

PHP 可以通过模拟 HTTP 协议发起 HTTP 请求

**CURL** 是一个非常强大的开源库, 支持多种协议, 包括 HTTP, FTP, ETP, TELNET 等, 我们使用它来发送 HTTP 请求. 它给我们带来的好处是可以通过灵活的选项设置不同的 HTTP 协议参数, 并且支持 HTTPS. CURL 可以根据 URL 前缀是 'HTTP' 还是 'HTTPS' 自动选择是否加密发送内容.

前提: HTTP 协议的客户端/服务端模式, HTTP 协议不局限于一定要浏览器访问.

#### Curl 扩展库使用

1. 开启 curl 扩展(php.ini)

   ![53544625667](./PHP\1535446256679.png)

2. 有的时候 PHP 版本会出现即使开启了扩展也无法使用扩展的可能, 因为 CURL 找不到对应的 dll 文件, 需要将相关的 dll 文件放到 C:windows 下面

   ![53544612493](./php\1535447935833.png)

3. 重启 Apache 应用

步骤:

1. 建立连接 `curl_init()` 激活一个 CURL 连接功能
2. 设置请求选项: `curl_setOpt()` 设定选项
   1. CURLOPT_URL: 连接对象
   2. CURLOPT_RETURNTRANSER: 将服务器执行的结果(响应) 以文件流的形式返回给请求界面(php脚本)
   3. CURLOPT_POST: 是否采用POST方式发起请求(默认GET)
   4. CURLOPT_POSTFIELDS: 用来传递 POST 提交的数据, 分为两种形式: 
      1. 字符串形式 name=acb&pasw=123
      2. 数组形式 array('name'=>'abc', ....)
   5. CURLOPT_HEADER: 是否得到响应的 header 信息(响应行和响应头),默认不获取.
3. 执行请求: `curl_exec()` 执行选项(与服务器发起请求), 得到服务器返回内容
4. 关闭连接:  `curl_close()` 关闭资源

![53545655966](./php\1535456559662.png)

**原服务器输出**

![53545664912](./php\1535456649129.png)

**curl扩展获取服务器的输出及相关信息**

![53545663407](./php\1535456634075.png)



## 文件编程

### 初步认识

**文件编程的重要性**

文件编程利用 php 代码针对文件 (文件夹) 进行增删查改操作.

在实际开发项目中, 会有很多内容 (文件上传/配置文件等) 具有不确定性, 不能再一开始就手动的创建, 需要根据实际需求和数据本身来进行管理, 这两个时候就可以使用 php 文件并来实现代码批量控制和其它操作

**文件操作分类**

- 目录操作：文件夹， 用来存放文件的特殊文件
- 文件操作：用来存放内容

### 目录操作

- **创建目录结构**

`mkdir(路径名字)` 创建成功返回 true, 失败返回 false

![53545739243](./php\1535457392432.png)

有些操作目的就是为了得到一个想要的结果, 如果结果本身就存在, 那么可以忽略得到过程的错误: 使用 `@` 抑制错误

![53545754438](./php\1535457544388.png)

- **删除目录结构**

`rmdir(指令文件夹路径)` : 移除文件夹

![53545769215](./php\1535457692159.png)

- **读取目录**

读取方式: 将文件夹(路径) 按照资源方式打开

1. `opendir()` 打开资源, 返回一个路径资源, 包含指定目录下的所有文件(文件夹)

   ![53545793057](./php\1535457930571.png)

2. `readdir()` 从资源中读取指针所在位置的文件名字, 然后指针下移, 直到指针移出资源.

   ![53546013605](./php\1535460136053.png)

   读取文件夹下的所有资源: 循环遍历输出

   ![53546048017](./php\1535460480172.png)

- **关闭目录**

   `closedir($res)`

- **其它目录操作**

  - dirname(路径): 得到的是路径的上一层所在路径

    ![53546084830](./php\1535460848306.png)

  - realPath(路径): 得到真实路径(目录路径), 不存在返回false

    ![53546120707](./php\1535461207076.png)

  - is_dir(路径): 判断指定路径是否是一个目录

    ![53546134585](./php\1535461345851.png)

  - **scandir(): 封装版的 opendir/readdir/closedir**, 获取一个指定路径下的所有文件信息, 以数组方式返回

    ![53546173540](./php\1535461735409.png)

#### 递归遍历目录

递归遍历目录: 指定一个目录的情况下, 将其下所有文件及目录及其目录内部的所有内容都输出出来.

递归算法: 将大问题切成相似的小问题(最小单位), 然后可以调用解决大问题的方法来解决小问题.

递归函数: 函数如果自己内部调用自己, 该函数称之为递归函数.

1. 设计一个能够遍历一层文件的函数

   ![53546307697](./php\1535463076974.png)

2. 找到递归点: 遍历得到的文件是目录, 应该调用当前函数(调用自己) 

   1. 需要构造路径(遍历得到的结果只是文件的名字)
   2. 需要注意排除 `.` 和 `..`

3. 找到递归出口: 遍历完这个文件夹之后, 发现没有任何子文件夹, (函数不再调用自己return): 自带出口(是文件夹才进行递归)

4. 如何显示层级关系: 函数第一次运行遍历的结果是最外层, 内部函数调用一次说明进入一个子目录, 子目录再调用一次函数说明是孙子目... 如果能够在第一次调用的时候给个标记, 在进入的时候, 通过编辑变化来识别层级关系, 就可以达到目的: 标记还能代表层级关系(缩进)

   1. 在参数中添加一个标记: 默认值0
   2. 递归调用函数的时候也需要传递该参数: 但是是属于当前层级的子,  所以 +1 操作
   3. 根据层级来实现缩进: `str_repeat()` 重复输出某个字符串.

```php
/* 
    创建函数: 能够访问制定路径下的所有文件, 且判断出是目录还是文件
    @param1 string $dir, 指定路径
    @param2 int $leval, 层级关系, 默认0
 */

$dir = 'upload';
function my_traverse_dir($dir, $leval = 0)
{
    //  保证文件安全: 如果不是路径, 结束.
    if (!is_dir($dir)) dir($dir . '<br>');

    //  读取全部路径信息, 遍历输出
    $files = scandir($dir);
    foreach ($files as $file) {
        //  排除 . 和 ..
        if ($file == '.' || $file == '..') continue;

        //  构造路径
        $file_dir = $dir . '/' . $file;

        //  输出带层级关系的路径
        echo str_repeat('&nbsp;&nbsp;', $leval*2) . $file_dir . '<br>';

        //  判断如果是 文件夹, 递归执行
        if (is_dir($file_dir)) {
            my_traverse_dir($file_dir, $leval + 1);
        }
    }
}

my_traverse_dir($dir);
```

![53551438511](./php\1535514385118.png)



### 文件操作

#### **PHP5常见文件操作函数**

- `file_get_contents(文件路径)`: 获取指定文件的所有内容, **如果不确定是否存在, 最好作安全操作 `@`**
- `file_put_contents(文件路径, 内容)`: 将指定内容写入到指定文件内: 如果当前路径下不存在指定的文件, 函数会自动创建(如果路径不存在, 不会创建路径)

![53552528838](./php\1535525288382.png)

#### **PHP4 常见文件操作函数**

php4 中是将文件操作用资源形式处理:不论是读还是写操作, 都依赖资源指针, 文件内容中指针所在位置.

- `fopen(文件路径, 模式)`: 打开一个文件资源, 限定打开模式 

  ![53552573772](./php\1535525737729.png)

- `fread(资源, 长度)`: 从打开的资源中读取指定长度内容(字节)

- `fwrite(资源, 内容)`: 向打开的资源中写入指定内容

- `fclose(资源)`: 关闭资源

![53552608265](./php\1535526082653.png)

`w+` 和 `a+`  模式的区别:

源文件都是值有 **hello world**  字符串text文件

![53552725847](./php\1535527258473.png)

#### **其它文件操作函数**

1. `is_file()`: 判断文件是否正确 (不识别路径)
2. `filesize()`: 获取文件大小
3. `file_exists()`: 判断文件是否存在(识别路径)
4. `unlink()`: 取消文件名字与磁盘地址的链接(删除文件)
5. `filemtime()`: 获取文件最后一次修改的时间
6. `fseek()`: 设定 fopen 打开的文件的指针位置
7. `fgetc()`: 一次获取一个字符
8. `fgets()`: 一次获取一个字符串(默认是一行)
9. `file():` 读取整个文件, 类似 `file_get_contents`, 区别是按行读取, 返回一个数组


测试文件内容

![53552856770](./php\1535528567706.png)

测试结果

![53552852432](./php\1535528524321.png)
|                             函数                             |               描述               |
| :----------------------------------------------------------: | :------------------------------: |
| [basename()](http://www.runoob.com/php/func-filesystem-basename.html) |     返回路径中的文件名部分。     |
| [dirname()](http://www.runoob.com/php/func-filesystem-dirname.html) |    返回路径中的目录名称部分。    |
| [file()](http://www.runoob.com/php/func-filesystem-file.html) |      把文件读入一个数组中。      |
| [file_exists()](http://www.runoob.com/php/func-filesystem-file-exists.html) |     检查文件或目录是否存在。     |
| [is_dir()](http://www.runoob.com/php/func-filesystem-is-dir.html) |     判断文件是否是一个目录。     |
| [mkdir()](http://www.runoob.com/php/func-filesystem-mkdir.html) |            创建目录。            |
| [move_uploaded_file()](http://www.runoob.com/php/func-filesystem-move-uploaded-file.html) |    把上传的文件移动到新位置。    |
| [move_uploaded_file()](http://www.runoob.com/php/func-filesystem-move-uploaded-file.html) |    把上传的文件移动到新位置。    |
| [readfile()](http://www.runoob.com/php/func-filesystem-readfile.html) | 读取一个文件，并写入到输出缓冲。 |
| [rename()](http://www.runoob.com/php/func-filesystem-rename.html) |        重命名文件或目录。        |
| [unlink()](http://www.runoob.com/php/func-filesystem-unlink.html) |            删除文件。            |


#### 文件下载

​	**文件下载:  从服务器将文件通过 HTTP 协议传输到浏览器, 浏览器不解析保存成相应的文件.**

提供下载方式可以使用 HTML 中的 a标签: `<a href="互联网绝对文件路径">点击下载</a>`

1. a 标签能够让浏览器自动下载的内容有限: 浏览器是发现如果解析不了才会启用下载
2. a 标签下载的文件存储路径会需要通过 href 属性写出来, 这样会暴露服务器存储数据的位置(不安全)

**PHP 下载**: 读取文件内容, 以文件流的形式传递给浏览器, 在响应头中告知浏览器不要解析, 激活下载框实现下载. 具体步骤如下: 

1. 指定浏览器解析字符集
2. 设定响应头
   1. 设定文件返回类型: image/jpg \|| application/octem_stream
   2. 设定返回文件计算方式: Accept-ranges: bytes
   3. 设定下载提示: Content-disposition: attachment:filename='文件名字'
   4. 设定下载大小: Accept-length: 文件大小(字节)
3. 读取文件
4. 输出文件

**实例代码**

```php
<?php 
//  php文件下载

//  1. 设定解析字符集
header('Content-type:text/html;charset=utf-8');
$file = 'download.text';	//	文件路径
//  2. 设定下载响应头
header('Content-type:application/octem-stream'); // 以文件流形式传输数据给浏览器
header('Accept-ranges:bytes');  //以字节方式计算
header('Content-disposition:attachement;filename=' . $file);    //  附件下载指定命名
header('Accept-length:' . filesize($file));
//	3. 文件读取和输出(php4文件流操作)
$f = fopen($file, 'r') or die();
while ($row = fread($f, 1024)) {
    echo $row;
}
fclose($f);
```

方案1: 如果文件较小, 可以直接使用 php5的文件操作

![53552970324](./php\1535529703240.png)

方案2:  适合大文件下载

![53553016713](./php\1535530167137.png)



------



## 会话技术

​	web 会话可简单理解为: 用户打开一个浏览器, 访问某个 web 站点, 在这个站点点击多个超链接, 访问服务器多个 web 资源, 然后关闭浏览器, 整个过程称之为一个会话.

​	HTTP 协议的特点是无状态/无连接, 当一个浏览器连接多次请求同一个 web 服务器时, 服务器是无法区分多个操作是否来自同一个浏览器(用户). 会话技术就是通过 http 协议想办法让服务器能够识别来自同一个浏览器的多次请求, 从而方便浏览器(用户) 在访问同一个网站的多次操作中, 能够持续进而不需要进行而外的额身份验证.

### **会话技术分类**/区别

**cookie 技术**

Cookie 是在 HTTP 协议下, 服务器或脚本可以维护客户工作站上信息的一种方式. **Cookie 是由  Web 服务器保存在用户浏览器(客户端) 上的小文本文件(HTTP 协议响应头)**, 它可以包含有关用户的信息. 无论何时用户连接到服务器(HTTP 请求携带数据), Web 站点都可以访问 Cookie 信息.

**session 技术**

Session 直接翻译成中文比较困难, 一般都翻译成时域. 在计算机专业术语中, Session是指一个终端用户与交互系统进行通信的时间间隔, 通常指从注册进入系统到注销退出系统之间所经过的时间. 以及如果需要的话, 可能还有一定的操作空间. **Session 技术是将数据保存到服务端**, 无论何时用户连接到服务器. Web 站点都可以访问 Sesion信息: SESSION 技术的实现是依赖 COOKIE 技术的.

**两种会话技术的区别**

1. 安全方面:

   a. Session 存储在服务端, 安全性高

   b. Cookie 存储在(浏览器)客户端, 安全性低

2. 数据大小方面:

   a. Cookie 的数量和大小都有限制 (20 个 每个/4k)

   b. Session 数据存储不限

3. 可用数据类型

   a. Cookie 只能存储简单数据, 数值/字符串

   b. Session 可以存储复杂数据(自动序列化)

4. 保存位置方面

   a. Cookie 保存在浏览器上

   b. Session 保存在服务器上

### Cookie基本使用

HTTP 很重要的一个特点就是 **无状态** ,如果单纯的希望通过我们的服务端程序去记住每一个访问者是不可能的, 所以必须借助一些必要手段让服务端记住来宾身份, 通过 **Cookie** 可以实现.

**cookie实现原理**

cookie 技术: 服务器将数据通过 HTTP 响应存储到浏览器上, 浏览器可以在以后携带对应的 Cookie 数据访问服务器.

1. 第一次请求时, php 通过 setcookie 函数将数据通过 http 协议响应头传输给浏览器
2. 浏览器在第一次响应的时候将 Cookie 数据保存到浏览器
3. 浏览器后续请求同一个网站的时候, 会自动检测是否存在 Cookie 数据, 如果存在将在请求头中将数据携带到服务器
4. PHP 执行的时候会自动判断浏览器请求中是否携带 Cookie, 如果携带, 自动保存到 $_COOKIE 中
5. 利用 $_COOKIE 访问 Cookie 数据.

![53553286605](./php\1535532866053.png)

![cookie](.\php\1527026482382.png)

Cookie 就像是银行卡(凭证), 由银行(Server) 发给 我们(Browser).

**设置cookie信息**

`setcookie('name', value)`

![53553319740](./php\1535533197403.png)

**获取 cookie 信息**

`$_COOKIE` 关联数组的方式访问客户端提交过来的 Cookie  

![53553333524](./php\1535533335245.png)

COOKIE存储的信息是可以跨脚本访问的, 因为信息是存于客户端(浏览器)上. 

### Cookie高级使用

`setcookie(name, value, expire, path, domain);`

```php
//  setcookie 专门设置 cookie 的函数
//	只传两个参数, 是设置 Cookie
setcookie('key', 'value');
//  只传一个函数, 是删除 Cookie, 实际上是设置了 cookie 的过期时间是 一个过去时间.
setcookie('key');
//	传递第三个参数, 是设置过期时间,单位(秒) 不传递就是 会话级别(Session) 的 Cookie, 关闭浏览器就自动删除  
setcookie('key', 'value', time() + 1 * 24 * 60 * 60); 
```

#### COOKIE 生命周期

COOKIE 生命周期: COOKIE 在浏览器生存时间 (浏览器在下次访问浏览器的时候是否携带对应的 COOKIE)

1. 默认(不设定) 时的生命周期: 默认关闭浏览器(会话结束)

2. 设定为一个常规日期戳的周期: 通过setcookie第三个参数, 可以设定生命周期时间戳, 从格林威治时间开始

3. 设定为 "0" 的周期: 在第三个参数设定生命周期的时候, 用 0 代替时间戳, 就是会话结束cookie实效

   ![53553522499](./php\1535535224996.png)

4. 删除一个 cookie 的做法: 服务器没有权限去操作浏览器的内容(不可能删除), 

   1. 设定内容为空 
   2. 可以通过该设置 cookie 生命周期让浏览器自动判断 COOKIE 是否有效. 设置成一个过期时间即可达到目的.

   ![53553554773](./php\1535535547732.png)

#### COOKIE作用范围(path)

作用范围: 不同的文件夹层级中, 设定的 COOKIE 默认是在不同的文件夹下有访问限制. 上层文件夹中设定的 COOKIE 可以在下层(子文件夹) 中访问, 而子文件夹设定的 COOKIE 不能在上层中访问

1. 默认(不设定) 的范围

   ![53553611608](./php\1535536116082.png)

2. **设置cookie的作用路径范围**

   设定为 `/` 的含义: 告知浏览器当前的 COOKIE 的作用范围是网站根目录

   设定为 `/users`  的含义: 告知浏览器当前的 COOKIE 数据只能在 ` users` 目录下的路径才能访问

   ```php
   setcookie('key', 'val', 0, '/');
   setcookie('key', 'val', time() + 1*24*60*60, '/users');
   ```
   ![53553634190](./php\1535536870914.png)

#### COOKIE跨子域(domain)

跨子域: 在同一级别域名下, myitcast.com (一级域名), 可以有多个子域名 (www.myitcast.com 和 mb.myitcast.com), 他们之间是搭建在不同的服务器上 (本地模拟不同文件夹), 但是可以通过 COOKIE 设置实现对应的 COOKIE 共享访问. 但是默认是不允许跨域名访问的.

1. **设置 cookie 有效域名**: 不同的域名(包含主机) 之间不能共享 COOOKIE

   可以通过 setcookie 的第五个参数来控制 `setcookie(key, vlaue, time, path, domain)`

   ![53553794576](./php\1535537945768.png)

   设定cookie有效域名的 cookie 后, 在其它非本级域名也不能进行访问

2. **不设定时默认有效域名**

   ![53553764370](./php\1535537643707.png)

3. **跨子域的设定方法**: 就是在设定域名访问的时候, 设定上级域名即可(myitcast.com, 这个时候只要一级域名是 myitcast.com就可进行访问)

   ![53553820617](./php\1535538206175.png)

   `myitcast.com` 所有的 myitcast.com 的子域 都能访问到

   - `www.myitcast.com`   √
   - `gz.myitcast.com`   √
   - `www.myitcast1.com`          ×

   `www.myitcast.com` 所有的 www.myitcast.com 的子域 都能访问到

   - `aaa.www.myitcast.com`  √
   - `aaa.www.myitcast1.com`  ×

#### COOKIE 数组数据

COOKIE 本身只支持简单数据(数字, 字符串), 能够保留的数据本身有限, 也不成体系. 如果需要使用 cookie 来保留一组数据的话, 想办法凑成数组. (cookie 不支持数组)

1. 设定形式: `setcookie('c1[k1]', 值)`

   ![53554052363](./php\1535540523637.png)

2. 读取形式: `$_COOKIE['c1']['k1']`

   ![53554060411](./php\1535540604113.png)

#### httponly

**一旦 cookie 的 httponly 为真, 那么只能在服务端获取, JS无法获取**



### Session基本使用

**session 原理**

1. php碰到 session_start() 时开启 session 会话, 自动检测 sessionID
   1. 如果 Cookie 存在, 使用现成
   2. 如果 Cookie 不存在, 创建一个 sessionID, 并沟通过响应头以 Cookie 形式保存到浏览器上
2. 初始化超全局变量 $_SESSION 为一个空数组
3. PHP 通过 sessionID 去指定位置 (session 文件保存位置), 匹配对应的文件
   1. 不存在该文件: 创建一个 sessionID 命名文件
   2. 存在该文件: 读取文件内容(反序列化), 将数据存储到 $_SESSION 中
4. 脚本执行结束, 将 $_SESSION 中保存的所有数据 序列化 存储到 sessionID 对应文件中

![53554233313](./php\1535542333131.png)

![52705603377](.\php\1527056033777.png)

基于 Cookie 基础之上的手段: **Session**

![session](.\php\1527055929239.png)

启用 SESSION 任何时候都需要开启 session (脚本使用到 $_SESSION 就开启一次), 通过 `session_start()` 启用.

![53554283434](./php\1535542834343.png)

#### **设置 SESSION信息**

如果想存储数据到 session 中, 只要不断给 $_SESSION 数组添加元素即可.

![53554308183](./php\1535543081832.png)

#### **读取 SESSION 信息**

$_SESSION 就是一个数组, 存储了什么数据, 什么方式存储的, 就可以通过什么方式访问数据

```php
$_SESSION['user'];
```

会话技术的本质是为了实现跨脚本共享数据: 字啊一个脚本中定义数据, 在另外一个和脚本中访问数据

![53554348671](./php\1535543486713.png)

#### **删除 SESSION 信息**

删除 session 就是将 session 数据清理掉($_SESSION拿不到)

1. 删除一个 SESSION 信息

   `unset($_SESSION[元素下标]);`

   ```php
   unset($_SESSION['hobbies']);
   ```

   ![53554409681](./php\1535544096817.png)

2. 删除全部 SESSION 信息

   删除全部数据就是让 $_SESSION 变成一个空数组

   ```php
   $_SESSION = [];
   ```

   ![53554417220](./php\1535544172205.png)

#### SESSION 相关配置

##### 基础配置

1. session.name: 保存 Cookie 中 sessionID 对应名字

   ![53554434242](./php\1535544342421.png)

2. session.auto_start: 是否自动开启 session (无需手动 session_start()), 默认是关闭的

   ![53554444096](./php\1535544440965.png)

3. session.save_handler: session 数据的保存方式, 默认是文件形式

   ![53554453766](./php\1535544537667.png)

4. session.save_path: session 文件默认存储的位置.

   ![53554458241](./php\1535544653154.png)

使用系统的操作文件存储不安全. 需要指定对应存储路径.

![53554478946](./php\1535544789462.png)

##### 常用配置

1. session.cookie_lifetime: PHPsessionID 在客户端的 Cookie 生命周期(默认会话关闭)

   ![53554507103](./php\1535545071033.png)

2. session.cookie_path: sessionID 在浏览器存储之后允许服务器访问的路径(默认全局)

   ![53554509831](./php\1535545098314.png)

3. session.cookie_domain: Cookie 允许访问的子域

   ![53554515211](./php\1535545152117.png)

##### **配置的两种形式**

1. php.ini 中配置: 全局配置, 修改配置项. 如上配置都是全局设定

2. 脚本中配置: php 可以通过 `ini_set` 函数在运行中设定某些配置项(只会对当前运行脚本有效), 这种配置就是项目级配置(局部).

   ```php
   @ini_set('session.save_path', 'E:/studyphp/sessions');
   ```

#### 销毁 SESSION

Session 删除是指删除 session 数据, $_SESSION 中看不到; 销毁 sesion 是指删除 session 对应的 session 文件.

系统提供了一个函数: `session_destroy()`, 会自动根据 session_start 得到的 sessionID 去找到指定的 session 文件, 并把它删除.

```php
session_destroy();
```

#### SESSION 垃圾回收机制

​	session 会话技术后, session 文件并不会自动清除, 如果每天有大量的 session 文件产生但是又都是失效的, 会增加服务器的压力和影响 session 效率.

垃圾回收, 是指 session 机制提供了一种解决垃圾 session 文件的方式:  给 session 文件**指定周期**, 通过 session 文件**最后更改时间**与**生命周期**进行结合判断, 如果已经过期则删除对应的 session 文件, 如果没有过期则保留. 这样就可以及时清理无效的僵尸文件, 从而提升空间利用率和 session 工作效率.

1. 任何一次 session 开启 (session_start), session 都会尝试读取 session 文件.
2. 读取 session 文件后, 有可能触发垃圾回收机制(在 session 系统中也有一个函数: 自己有一定几率调用).
3. 垃圾回收机制会自动读取所有 session 文件的最后编辑时间, 然后加上生命周期 (配置文件) 与当前时间进行比较(所有 session 文件). (过期删除, 有效保留)

##### 垃圾回收参数设置

1. `session.gc_maxlifetime = 1440`: 规定的 session 文件最大生命周期是 1440秒, 24分钟.

   ![53554683594](./php\1535546835948.png)

2. `session.gc_probability = 1`: 垃圾回收概率因子 (分子)

   ![53554680697](./php\1535546806971.png)

3. `session.gc_divisor = 1000`: 垃圾回收概率分母

   ![53554678862](./php\1535546788621.png)

默认的触发概率是 1/1000

#### 禁用COOKIE后如何使用SESSION

**禁用 COOKIE 不能使用 SESSION 原因**

Session 技术需要利用到 Cookie 技术来保存 sessionID, 从而使得 PHP 能够跨脚本得到相同的 sessionID, 从而访问 session 文件.

![53554751540](./php\1535547515409.png)

解决思路:最终让 session_start 在开启之前拿到原来的 sessionID(另外一个脚本)

**实现无 COOKIE 使用 SESSION**

在 php 中, 想要解决没有 COOKIE 也实现 SESSION 技术的方式两种:

1. 可以使用 php 提供的 session 函数: `session_id` 和 `session_name` 来获得和设置 sessionID, 或者 name 从而解决 session_start 产生新的 sessionID 情况(手动操作)

   ```php
   session_start();

   //	1. 获取 sessionID 和 名字
   $id = session_id();
   $name = session_name();	//	php.ini 中的 session.name

   //	设置内容
   $_SESSION['name'] = 'mark';

   //	2. 想办法将数据传递给另外一个脚本: 表单传值(url或form表单)
   echo "<a href='xxx.php?{$name}={$id}'>click</a>"
   ```

   3. 在想要得到 session 的脚本中,先接收数据

   ```php
   //	接收数据 
   $name = session_name();
   $id = $_GET[$name]; 
   //	4. 阻止 session_start 产生新的id, 告诉它已经存在的 session_id($id)
   session_id($id);
   //	访问
   var_dump($_SESSION);
   ```

2. 可以利用 session 集中已经提供的解决方案自动操作(配置)

   1. 默认 session 配置只允许使用 COOKIE 保存 sessionID: cokie_only
   2. 默认关闭了其他能够传送数据的方式, 只保留了 COOKIE

   解决方法: 

   1. 修改 php 配置文件, 开启其它方式传输 sessionID, 关闭只允许使用 COOKIE 保存数据功能

      ![53554925938](./php\1535549259386.png)

      ![53554922120](./php\1535549221209.png)

   2. 一旦配置开启了, PHP 会自动将 sessionID 和 session 名字在其它位置绑定数据, 同时还会在 session_start 的时候考虑**其他方式**传递的数据, 而不是只有 COOKIE

      ![53554953331](./php\1535549533315.png)

      ​

### 使用 COOKIE  /  SESSION 案例

#### 记住登录名案例

![52705681262](.\php\1527056812624.png)

#### 猜数字游戏

```php
<?php
session_start();
if(empty($_SESSION['num'])){
	$num = rand(0, 100);
	$_SESSION['num'] = $num;
	$_SESSION['count'] = 0;
}else{
	$count = empty($_SESSION['count']) ? 0 : $_SESSION['count'];
	if($count < 10){
		if ((int)$_GET['num'] - $_SESSION['num'] == 0) {
			$message = '猜对了!点击再来一次哒!';
			unset($_SESSION['num']);
			unset($_SESSION['count']);
		} elseif((int)$_GET['num'] - $_SESSION['num'] > 0) {
			$message = '数字大了！';
		} else {
			$message = '数字小了！';
		}
		$_SESSION['count'] = $count + 1;
	}else{
		$message = '再没有机会了呢!从头再来loooooooooooooooooooow ';
		unset($_SESSION['num']);
		unset($_SESSION['count']);
	}
}  
?>
```



---



## GD 图像处理

### GD图像处理基本技术

API: 外部提供的应用接口: 已经准备好了一套处理某些功能的机制, 用户只要按照指定的数据要求, 调用指定的函数或者方法(类) 就可以实现某个功能.

**概念**

Graphic Device, 图像处理扩展(外部提供的 API), 能够允许 php 在脚本中使用对应的函数来实现某些图像制作功能

**引入**

GD库是外部提供的 API, 已经被集成到 PHP 扩展库中(不需要下载), 但是徐亚偶在 PHP 的配置文件中开启对应的扩展, 之后重启 Apache 服务器.

![53555308151](./php\1535553081518.png)

**画图的基本流程**: 画图本质是在内存开辟一块很大的内存区域用于图片制作

1. 准备画布
2. 开始作画
3. 保存内容
4. 销毁画布

#### 创建画布资源

1. `imagecreate(宽, 高)`: 创建一个空白画布(白).
2. `imagecreatetruecolor(宽, 高)`: 创建一个真彩画布(黑).
3. `imagecreatefromjpeg(图片文件路径)`: 打开一个 jpeg 格式的图片资源
4. `imagecreatefromgif(图片文件路径)`: 打开 gif 格式图片资源(PHP 中无法实现动态)
5. `imagecreatepng(图片文件路径)`: 打开 png 格式图片资源

![53556125023](./php\1535561343093.png)

如果从已知文件创建图片资源, 那么一定要匹配对应的打开方式, 否则会出错, 推荐使用安全容错操作 `@`.

#### 操作画布资源

说明: 所有的画布资源操作都是需要指定画布资源的, 而且都是第一个参数.

1. 分配颜色: `imageColorAllocate(画布资源, R, G, B)`, 根据 RGB 三色组合指定画布资源分配一组颜色, 会返回一个颜色句柄(一组整数). 每个颜色范围都是从 0 到 255.

   ![53556182507](./php\1535561825077.png)

   在真彩图片资源中, 所有分配的颜色都不会自动给图片资源上色, 是用来后续操作图片资源的时候, 指定着色的; 但是如果当前使用的 `imagecreate()` 创建的图片资源, 即空白画布资源, 那么第一个分配的颜色, 会自动被着色为图片背景色.

   注意: 凡是给图片上早呢更加内容, 基本都需要分配颜色 (每一个操作图片的函数之前, 都需要先调用分配颜色的函数得到一个颜色)

2. 填充区域: `imagefill(画布资源, 起始x坐标, 起始y坐标, 颜色句柄)`: 指定位置开始填充颜色.

   ![53556230319](./php\1535562303198.png)

   imagefill 的填充逻辑: 从 指定点开始, 自动匹配相邻点, 如果颜色一致, 自动渲染, 扩展到全图

3. 画直线: `imageline(图片资源, 起始点x, 起始点y, 终点x, 终点y, 颜色)`: 制作一条直线

   ![53556251263](./php\1535562512638.png)

4. 画矩形: `imagerectangle(图像资源, 左上角x, 左上角y, 右下角x, 右下角y, 颜色)`: 制作一个矩形

   ![53556267738](./php\1535562677381.png)

5. 画圆弧: `imagearc(图像资源, 轴点x, 轴点y, 宽度, 高度, 弧度起点, 弧度终点, 颜色)`: 制作弧度图像

   ![53556300932](./php\1535563009325.png)

6. 在画布上写字: `imagestring()`, `imagettftext()`

   1. `imagestring(图片资源, 文字大小, 起始x, 起始y, 内容, 颜色)`: 用来书写 ASCII 对应的字符(英文)

      ![53556380771](./php\1535563807712.png)

   2. `imagettftext(图片资源, 文字大小, 旋转角度, 起始x, 起始y, 颜色, 字体, 内容)`: 可以书写任意文字(中文): 需要指定字体路径(ttf文件, 默认是 C:/Windows/Fonts)

      ![53556522532](./php\1535565225320.png)

#### 输出画布资源

1. 输出为图片文件: 以图片文件形式保存到本地文件夹

   ![53556533949](./php\1535565339492.png)

2. 输出为网页图片: 将图片展示给 HTML(用户): 服务器需要告知浏览器当前内容是图片, 通过修改响应头

   ![53556545288](./php\1535565452883.png)

   细节1: 如果图片输出或者保存出错, 浏览器看到的永远是告诉你图片错误, 但是绝对不会告知错误出在哪里. 这时候我们可以先关闭 header 设置查看错误, 确定位置后再开启 header 设置

   细节2: 如果图片输出后没有成功， 但是关闭 header 设置也看不到错误： 最大的可能是图片输出之前出书了别的额外的内容 (喜欢输出 pre), 应该查看网页原码, 看看图片输出之前是否有任何输出, 尤其是空格空行.

image+图片格式:

1. `imagejpeg()`: 保存成 jpeg 格式图片
2. `imagepng()`: 保存成 png 格式图片
3. `imagegif()`: 保存成 gif 格式图片

如果图片只是提供了图片资源, 不指定保存的文件位置, 那么系统认为是输出给浏览器, 如果指定了位置, 那么系统认为保存到本地(第二个参数).

#### 销毁画布资源

从内存中将画布资源清理掉, 释放内存. `imagedestroy(图像资源)` 

![53556577763](./php\1535565777636.png)

#### 基础技术整合

![53556591156](./php\1535565911567.png)

#### 获取图片信息

1. 获取画布尺寸: `imagesx()`, `imagesy()`: 获取画布宽, 高
2. 获取图片尺寸: `getimagesize()`

![53560287088](./php\1535602870881.png)

### GD图片处理应用案例

#### 验证码的实现

​	验证码 (CAPTCHA) 是 "Completely Automated Public Turing test to tell Computers and Humans Apart" (全自动区分计算机和人类的图灵测试) 的缩写, 是一种区分用户是计算机还是人的公共全自动程序. 可以防止: 恶意破解密码, 刷票, 论坛灌水, 有效防止某个黑客对某一特定注册用户用特定程序暴力破解方式进行不断的登录尝试, 实际上用验证码是实现在很多网站通行的方式, 我们利用比较建议的方式实现了这个功能. 这个问题可以**由计算机生成并评判**, 但是必须**只有人类才能解答**. 由于计算机无法解答 CAPTCHA 的问题, 所以回答出问题的用户就可以被认为是人类.

图片验证码: 计算机将拿到的验证码存放到图片中, 让用户看到, 然后识别, 然后提交给服务器, 服务器再更具用户提交和服务器之前生成的进行比较.

1. 实现验证码图片的展示

   1. 生成图片资源: 背景色设定
   2. 写入文字
   3. 输出图片给浏览器
   4. 关闭资源

   ![53561130949](./php\1535611309490.png)

2. 实现验证码文字的随机变化

   1. 制作目标字符创集
   2. 随机从字符串中取出对应的汉字: 汉字在 utf8 一个字节占用3个字节, 英占一个字节: 确定字符数
   3. 随机取值

   ![53561254046](./php\1535612540469.png)

3. 实现验证码文字颜色的随机变化

   1. 每次产生不同的文字颜色

   ![53561276852](./php\1535612768529.png)

4. 实现验证码背景或干扰噪点: 增加一些额外不影响用户判断的元素(点, 线)

   1. 增相点, 线干扰`imagestring()` `imageline()`
   2. 随机改变文字大小, 位置, 角度的变化

   ![53561400537](./php\1535614005374.png)

5. 实现点击刷新验证码功能:实现验证码在浏览器显示的功能

   1. 创建一个表单文件, 里面有一个 img 标签能够显示图片(宽200, 高50)
   2. 实现点击更换验证码: 让 img 标签重新请求 php脚本产生一张新的图片.需要给img标签早呢更加一个点击事件: img的src是否重新发起请求取决于浏览器, 浏览器是否重新发起请求取决于src是否改变.
   3. 如何让 img 标签的 src 每次点击都不一样: 地址添加一个随机不同的参数

   ![53561459489](./php\1535614594891.png)

```php
<?php 

//  制作验证码图片
$img = imagecreatetruecolor(200, 50);
//  背景色
$bg_color = imagecolorallocate($img, 220, 220, 220);
imagefill($img, 0, 0, $bg_color);

//  获取随机文字
$str = '懵宝小白是宇宙太阳系地球中国浙江温州最帅最可爱最厉害的前端工程师不服来战无所畏惧';
$len = strlen($str) / 3;
//  随机取字: 随机汉字数(第几个)
$char1 = substr($str, mt_rand(0, $len - 1) * 3, 3);
$char2 = substr($str, mt_rand(0, $len - 1) * 3, 3);
$char3 = substr($str, mt_rand(0, $len - 1) * 3, 3);
$char4 = substr($str, mt_rand(0, $len - 1) * 3, 3);

//  写入内容
//  字体路径
$font = 'C:\Windows\Fonts\msyh.ttc';
//  颜色
$str_color1 = imagecolorallocate($img, mt_rand(0, 100), mt_rand(0, 100), mt_rand(0, 100));
$str_color2 = imagecolorallocate($img, mt_rand(0, 100), mt_rand(0, 100), mt_rand(0, 100));
$str_color3 = imagecolorallocate($img, mt_rand(0, 100), mt_rand(0, 100), mt_rand(0, 100));
$str_color4 = imagecolorallocate($img, mt_rand(0, 100), mt_rand(0, 100), mt_rand(0, 100));
//  干扰线
for ($i = 0; $i < 10; $i++) {
    $line_color = imagecolorallocate($img, mt_rand(50, 150), mt_rand(50, 150), mt_rand(50, 150));
    imageline($img, mt_rand(0, 200), mt_rand(0, 50), mt_rand(0, 200), mt_rand(0, 50), $line_color);
}
imagettftext($img, mt_rand(10, 30), mt_rand(-15, 15), 10, 40, $str_color1, $font, $char1);
imagettftext($img, mt_rand(10, 30), mt_rand(-15, 15), 60, 40, $str_color2, $font, $char2);
imagettftext($img, mt_rand(10, 30), mt_rand(-15, 15), 120, 40, $str_color3, $font, $char3);
imagettftext($img, mt_rand(10, 30), mt_rand(-15, 15), 160, 40, $str_color4, $font, $char4);
//  干扰点
for ($i = 0; $i < 100; $i++) {
    $dots_color = imagecolorallocate($img, mt_rand(150, 250), mt_rand(150, 250), mt_rand(150, 250));
    imagestring($img, mt_rand(0, 2), mt_rand(0, 200), mt_rand(0, 50), '*', $dots_color);
}

//  输出资源
header('Content-type:image/png');
imagepng($img);
//  销毁资源
imagedestroy($img);
```

#### 缩略图的实现

1. 制作图片缩略图的原理

   缩略图: 将原图得到一个较小的图(尺寸上)

   原理: 将原图打开放到另外一个较小的图片资源中去, 最后进行保存即可

2. 实现固定宽高的缩略图

   1. 得到一张原图资源

   2. 得到一个缩略图资源(较小)

   3. 图片采样赋复制: GD提供了一个函数

      `imagecopyresampled(缩略图资源, 原图资源, 缩略图开始放x, 缩略图开始放y, 原图采样起始x, 原图采样起始y, 缩略图存放宽, 缩略图存放高, 原图采样宽, 原图采样高)`

   4. 保存缩略图

   5. 销毁缩略图

   ![53562068466](./php\1535621354732.png)

3. 实现等比例缩放的固定款或高的缩略图

   优点: 图片不会失真(变形)

   缺点: 缩略图有些部分需要进行额外填充(白色填充: 补白)

   等比例缩略图与固定缩略图的制作区别: 在于通过计算来得出缩略图的宽高

   算法原理: 

   	1.  计算缩略图宽高比
   	2.  计算原图宽高比
   	3.  比较: 
   	 	1.  如果缩略图宽高比大于原图宽高比, 将缩略图中用原图的高尽可能填满: 缩略图的高是完整的, 宽度不够(补白)
   	 	2.  如果缩略图宽高比小于原图宽高比, 将缩略图中用原图的宽尽可能填满: 缩略图的宽是完整的, 高度不够(补白)
   	4.  将图片放到缩略图资源中间

![53563424028](./php\1535634240282.png)

```php
<?php 
//  制作一个等比例的缩略图

//  获得原图资源
$src_img = '1.png';
//      拿到原图信息(宽/高)
$src_w = (int)getimagesize($src_img)[0];
$src_h = (int)getimagesize($src_img)[1];
$src_b = $src_w / $src_h;   //  原图宽高比
$src = imagecreatefromjpeg($src_img);

//  制作缩略图画布资源
$dst_w = 210;   //  缩略图宽
$dst_h = 100;   //  缩略图高
$dst_b = $dst_w / $dst_h;   //  缩略图宽高比例
$dst = imagecreatetruecolor($dst_w, $dst_h);

//  填充缩略图画布背景色
$dst_color = imagecolorallocate($dst, 255, 255, 255);
imagefill($dst, 0, 0, $dst_color);

//  初始化缩略图的宽/高, 位置
$start_w = $start_h = 0;
$pos_x = $pos_y = 0;

//  计算缩略图从原图采样的宽和高(缩略图到底是宽还是搞高被填满)
if ($dst_b >= $src_b) {
    //  缩略图宽高比 大于 原图宽高比(高度100%, 宽度补白)
    $start_h = $dst_h;
    $start_w = (int)($src_b * $dst_h);
    $pos_x = (int)(($dst_w - $start_w) / 2);
} else {
    //  缩略图宽高比 小于 原图宽高比(宽度100%, 高度补白)
    $start_w = $dst_w;
    $start_h = (int)($dst_w / $src_b);
    $pos_y = (int)(($dst_h - $start_h) / 2);
}
// echo $start_w, $start_h;

//  采样复制: imagecopyresampled 参数: 
//      缩略图资源, 原图资源, 缩略图起始点x, 缩略图起始点y, 原图起始点x, 原图起始点y, 缩略图终点x, 缩略图终点y, 原图终点x, 原图终点y) 
$res = imagecopyresampled($dst, $src, $pos_x, $pos_y, 0, 0, $start_w, $start_h, $src_w, $src_h);
//  保存
header('Content-type:image/png');
imagepng($dst);
//  保存到本地
imagepng($dst, 'uploads/美丽.png');

//  销毁资源
imagedestroy($src);
imagedestroy($dst);
```

#### 水印图的实现

水印图: watermark, 在某个图片上增加一个透明的印记 (马赛克)

水印图的用途: 版权操作 

1. 制作图片水印图的原理

   水印图制作原理: 将一个带有明显标志的图片放到另外一张需要处理的图片之上

   1. 获取原图资源

   2. 获取水印图资源

   3. 合并图片(把水印图合到目标图上)

      `imagecopymerge(目标资源, 水印资源, 目标起始x, 目标起始y, 水印起始x, 水印起始y, 水印宽, 水印高, 透明度)`

   4. 保存输出

   5. 清除资源

2. 实现固定位置的水印图

   ![53565070261](./php\1535650702618.png)

3. 实现可选9个位置的水印图: 封装制作水印图的函数

   1. 创建一个水印图的函数结构: 只做水印图需要提供多少条件? 原图资源, 水印图资源, 位置选择?9个, 透明度, 保存位置,失败信息 

   2. 结果是希望产生水印图: 但是可能成功, 返回文件保存名字; 如果产生失败返回 false, 但是还需要告知外界原因: 通过引用传参解决.

      ![53565144554](./php\1535651445546.png)

   3. 水印图前提: 原图和对应的水印图资源都存在, 保存位置是否不存在

      ![53565186695](./php\1535651866958.png)

   4. 打开原图和水图资源

      1. 想办法确定用什么函数来打开图片资源: 需要通过图片的 MIME 类型来确定. 获取图片信息 `getimagesize()`

         ![53565559231](./php\1535655592313.png)

      2. 通过 MIME 类型的到要打开图片的函数: 先设定一个数组进行匹配, 匹配成功自动构造创创建函数(保存函数)

         ![53565562230](./php\1535655622306.png)

      3. 匹配数据

         ![53565565279](./php\1535655652791.png)

      4. 组合函数名字: 打开原图资源函数, 打开水印图函数, 保存水印完成图函数

         ![53565568113](./php\1535655681138.png)

      5. 打开图片资源

         ![53565570114](./php\1535655701147.png)

   5. 合并图片资源, 保存水印图片, 销毁资源: 位置计算

      1. 计算水印图在原图中的位置: 根据参数 $pos

         ![53565572023](./php\1535655720235.png)

      2. 成功返回水印名称: 失败返回 error 信息, 销毁数据

         ![53565574605](./php\1535655746054.png)

```php
<?php 
//  函数封装: 水印图制作
/* 
    制作水印图
    @param1 string: $src_img    原图路径
    @param2 string: $wat_img    水印图路径
    @param3 string: $path,      水印图存储路径
    @param4 string: &$error,    记录错误信息的引用变量
    @param5 int   : $pos=1,     1代表左上角, 2代表中上位置, 9代表右下角, 依次类推, 默认左上角
    @param6 int   : $opacity=20,  透明度, 默认20
 */

function watermark($src_img, $wat_img, $path, &$error, $pos = 1, $opacity = 20)
{
    //  验证原图䄦水印图都存在
    if (!is_file($src_img)) {
        $error = '原图不存在!';
        return false;
    }
    if (!is_file($wat_img)) {
        $error = '水印图不存在';
        return false;
    }
    //  判断路径保存是否存在
    if (!is_dir($path)) {
        $error = '保存位置不正确';
        return false;
    }

    //  获取图片信息(MIME)
    $src_info = getimagesize($src_img)['mime'];
    $wat_info = getimagesize($wat_img)['mime'];

    //  定义一组数据, 用来产生对应图片
    $allow = array(
        'image/jpeg' => 'jpeg',
        'image/jpg' => 'jpeg',
        'image/gif' => 'gif',
        'image/png' => 'png',
        'image/pjpeg' => 'jpeg'
    );

    //  匹配数据    array_key_exists 函数, 确定某个 key 是否在数组中存在
    if (!array_key_exists($src_info, $allow)) {
        $error = '当前原图不允许制作资源使用';
    }
    if (!array_key_exists($wat_info, $allow)) {
        $error = '当前水印图不允许作资源使用';
    }

    //  组合函数: 打开原图资源函数, 打开水印图函数, 保存水印完成图函数
    $src_open = 'imagecreatefrom' . $allow[$src_info];
    $wat_open = 'imagecreatefrom' . $allow[$wat_info];
    $src_save = 'image' . $allow[$src_info];

    //  打开资源图
    $src = $src_open($src_img); //  原图资源
    $wat = $wat_open($wat_img); //  水印图资源

    //  计算水印图在原图出现的位置
    $pos_x = $pos_y = 0;
    switch ($pos) {
        case 1: //  左上
            break;
        case 2: //  中上
            $pos_x = (int)((imagesx($src) - imagesx($wat)) / 2);
            break;
        case 3: //  右上
            $pos_x = (int)(imagesx($src) - imagesx($wat));
            break;
        case 4: //  中左
            $pos_y = (int)((imagesy($src) - imagesy($wat)) / 2);
            break;
        case 5: //  正中
            $pos_x = (int)((imagesx($src) - imagesx($wat)) / 2);
            $pos_y = (int)((imagesy($src) - imagesy($wat)) / 2);
            break;
        case 6: //  中右
            $pos_x = (int)(imagesx($src) - imagesx($wat));
            $pos_y = (int)((imagesy($src) - imagesy($wat)) / 2);
            break;
        case 7: //  左下
            $pos_y = (int)(imagesy($src) - imagesy($wat));
            break;
        case 8: //  中下
            $pos_x = (int)((imagesx($src) - imagesx($wat)) / 2);
            $pos_y = (int)(imagesy($src) - imagesy($wat));
            break;
        case 9: //  右下
            $pos_x = (int)(imagesx($src) - imagesx($wat));
            $pos_y = (int)(imagesy($src) - imagesy($wat));
    }

    //  合并图片资源
    if (imagecopymerge($src, $wat, $pos_x, $pos_y, 0, 0, imagesx($wat), imagesy($wat), $opacity)) {
        //  成功: 保存水印图片和销毁资源
        $filename = 'watermark_' . time() . '.' . $allow[$src_info];
        $src_save($src, $path . $filename);
        //  销毁资源
        imagedestroy($src);
        imagedestroy($wat);
        //  返回文件名
        return $filename;
    } else {
        //  失败_
        $error = '水印图制作(合并)失败!';
        return false;
    }
}


//	函数的使用
//  	修改传入实参
$src_img = '1.png';
$wat_img = '2.png';
$path = './uploads/watermark/';
$error = '';
//  	调用函数
$res = watermark($src_img, $wat_img, $path, $error, 8, 50);
if ($res) { //  成功返回文件名
    echo $res;
} else {    //  失败返回err错误信息
    echo $error;
}
```

![53565603510](./php\1535656035102.png)



## 接口编程

### 概述/原理/小案例

接口又称为 API(应用程序编程接口). 是一些预先定义的函数, 目的是提供应用程序与开发人员基于某软件或硬件的访问一组例程的能力, 而无需访问原码或理解内部工作机制的细节.

只要能够提供第三方的服务或者功能都叫做 API 不论是函数, 类, 具体的代码文件

**接口调用原理**

接口的调用原理就是使用 http/https 协议传递具体的参数最后获得到具体的结果

**使用第三方接口的建议**

首要看文档. 在文档中规定请求的 URL 地址, 参数, 以及协议跟方式, 具体返回的结果的信息. 对于比较重要的接口一般都会直接提供各种语言的 demo. 对于不需要涉及到回调接口(是否需要再次请求项目中的接口) 可以直接在本地进行测试.

**调用第三方接口案例(天气查询)**

1. 聚合数据用户创建/接口调用申请

2. 根据API文档, 使用接口

   ![53569755282](./php\1535864440645.png)

```php
<?php 
//  第三方接口调用实例 : 调用聚合数据的 天气 接口

//  选择查看城市
$cityname = '温州';

//  我的聚合数据密匙
$key = '30602153e0ceba33898d843e9c8b0c70';

//  请求地址完善
$url = 'http://v.juhe.cn/weather/index?format=2&cityname=' . $cityname . '&key=' . $key;

//  调用接口  
$weather = file_get_contents($url, true);

//  查看返回数据
var_dump(json_decode($weather));
```

###  短信接口

**荣联云通讯 http://www.yuntongxun.com**

1. **接口申请** 我的密匙(8106965463044be2bf0119204def2052)

   1. 注册申请, 含免费的使用次数金额(用户id和密匙)

      ​

   2. 创建应用(具体选项填写)

      ​

   3. 应用上线(上线网站必须验证)

      ​

   4. 短信模板的使用

      ​

   5. 添加测试号码: 由于目前的应用没有上线 关于手机短信的发送只能跟测试号码进行

      ​

2. **具体实现手机短信验证码的发送功能**

   1. 查看文档

      1. 进入开发文档

      2. 查找短信接口文档(http://doc.yuntongxun.com/space/5a5098313b8496dd00dcdd7f)

      3. 下载deom(模板)

   2. **修改短信验证发送模板**

      1. 拷贝到下载的demo到web文件下, 修改基本信息

         ![53586557852](./php\1535865578527.png)

   3. 实现短信发送

      ![53586561223](./php\1535865612232.png)

   4. 访问查看发送结果

      ![53586566745](./php\1535865667459.png)

      说明短信发送成功, 我查看手机, 的确如定制一般收到了正确的内容


#### 项目中使用短信接口实现注册功能

**原理**



**实现短信发送**

1. 将已经实现发送短信发送的 demo 拷贝到项目中

2. 将发送短信的模板文件封装为一个函数: 以后使用时直接调用即可.

   ![53586579567](./php\1535865795677.png)

   ![53586582938](./php\1535865829382.png)

3. 项目中测试短信是否发送成功

**使用 ajax 实现短信发送**

1. 按钮绑定事件

   ![53827277575](./php\1538272775757.png)

   2.根据指定手机号发送短信验证码

   ![53827294548](./php\1538272945487.png)

   3.验证码发送成功， 记录session作验证过期使用

   ![53827271185](./php\1538272711850.png)


### 邮件发送

**发送原理**

![53837714346](./php\1538377143462.png)

1. 用户编辑具体的内容当点击发送之后, 会请求自己对应的邮件服务器中 smtp 服务
2. 邮件服务器接收请求会根据具体收件人地址进行判断, 如果是本平台的用户, 直接将邮件存储到对应的收件人的存储空间, 如果不是本平台, 请求收件人对应邮件服务器的 smtp 服务.
3. 收件人的邮件服务器接收请求. 判断如果当前收件人确实是本平台下用户. 将具体的邮件存储到用户对应的存储空间
4. 用户通过连接 pop3 服务获取最新的邮件数据

#### 实现邮件发送

**使用 163 的邮箱进行邮件收发操作**

① 注册/登录 163 邮箱账号

② 开启邮箱的 pop3 等服务

![53837775817](./php\1538377758172.png)

![53837781545](./php\1538377815455.png)

③ 设置**第三方客户端授权密码***

![53837786244](./php\1538377862441.png)

此密码和登录密码不是同一个.

**使用代码实现邮件发送**

使用插件: **PHPMailer** 

1. 拷贝源代码到本地 web 目录下

   ![53838078636](./php\1538380786369.png)

2. 创建php文件实现邮件发送

   ![53838562290](./php\1538385968509.png)

3. 访问发送邮件

   ![53838598995](./php\1538385989950.png)

#### 项目中实现邮件注册功能

**将邮件发送封装为函数**

1. 拷贝 PHPMailer 源码到项目中

2. 封装函数

   ![53838659129](./php\1538386591294.png)

3. 查看接收的邮箱情况

   ![53838653605](./php\1538386536058.png)

**实现邮件注册功能**

1. 修改表的结构

   ![53838670886](./php\1538386708861.png)

2. 创建邮箱注册方法

   ![53838689029](./php\1538386890299.png)

3. 修改模型增加方法

4. 处理邮箱注册模板

**邮箱注册发送激活邮件**

​	关于具体邮件内容本质是某一个方法的URL地址(此地址就是用于实现用户的激活操作). 当用访问该 URL 地址针对自己的账户进行激活操作, 因此在该 URL 地址是一定存在仓鼠标识具体的用户.在目前的 URL 地址中如果直接将用户的标准参数的值作为明文方式, 就会导致用户可以给其它用户做激活操作. 解决该方法又来那种方法: 第一种是直接将 ID标识进行加密处理(需要对具体密文能够进行解密操作). 第二种方法: 对于用户 ID 标识值同样适用明文方式. 在增加一个参数激活码(对每一个用户的激活码第不一样)

User_id =  具体用户 id 标识

1. 修改表结构增加激活码

   ![53838819446](./php\1538388194464.png)

2. 修改用户模型

   ![53838825349](./php\1538388253496.png)

3. 关于邮箱注册的方法

   ![53838837775](./php\1538388377754.png)

4. 修改邮箱注册控制器

   ![53838860477](./php\1538388604777.png)

5. 具体实现激活操作

#### 使用快递接口

**易源数据调用快递信息**

### 地图API

**介绍**

地图API所值的就是能够提供地图相关服务.

对于该服务一般都是通过 JavaScript 或其它语言将具体的地图信息嵌入到应用中.

例如 58 同城下经常见到的地图相关的信息 此次也是调用了地图 API 来实现的

![53839934459](./php\1538399344592.png)

对于地图API除了提供小地图功能之外还提供了很多其他的功能.如路线规划以及导航功能

对于目前能够使用的 地图API 很多, 常见的百度地图/高德地图/腾讯地图.

**具体使用腾讯地图API**

1. [腾讯地图api文档地址](lbs.qq.com/index.html)

   1. 引入API地址
   2. DOM元素创建
   3. [指定具体参数信息](https://lbs.qq.com/javascript_v2/doc/mapoptions.html)
   4. 创建地图对象
   5. 初始化地图

   ![53840220879](./php\1538402208798.png)

#### 项目中使用地图 API

1. 基本引入及初始化

2. 创建地图的dom元素

3. 设置地图的中心点([经纬度与地面转换](https://lbs.qq.com/javascript_v2/doc/geocoder.html))

   ① 找到服务地址解析

   ![53846505172](.\php\1538465051728.png)

   ![53846570497](.\php\1538465704979.png)

   ```html
   <!DOCTYPE html>
   <html>
   <head>
       <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
       <title>地址解析</title>
       <style type="text/css">
           * {
               margin: 0px;
               padding: 0px;
           }

           body,
           button,
           input,
           select,
           textarea {
               font: 12px/16px Verdana, Helvetica, Arial, sans-serif;
           }
           p {
               width: 603px;
               padding-top: 3px;
               margin-top: 10px;
               overflow: hidden;
           }
           input#address {
               width: 300px;
           }
       </style>
       <script charset="utf-8" src="https://map.qq.com/api/js?v=2.exp"></script>
   </head>

   <body onload="init()">
       <script>
           var geocoder, map, marker = null;
           var init = function() {
               var center = new qq.maps.LatLng(39.916527, 116.397128);
               map = new qq.maps.Map(document.getElementById('container'), {
                   center: center,
                   zoom: 15,
               });
               //地址和经纬度之间进行转换服务
               geocoder = new qq.maps.Geocoder();
           }
           function codeAddress() {
               var address = document.getElementById("address").value;
               //对指定地址进行解析
               geocoder.getLocation(address);
               //设置服务请求成功的回调函数
               geocoder.setComplete(function(result) {
                   map.setCenter(result.detail.location);
                   var marker = new qq.maps.Marker({
                       map: map,
                       position: result.detail.location
                   });
                   //点击Marker会弹出反查结果
                   qq.maps.event.addListener(marker, 'click', function() {
                       alert("坐标地址为： " + result.detail.location);
                   });
               });
               //若服务请求失败，则运行以下函数
               geocoder.setError(function() {
                   alert("出错了，请输入正确的地址！！！");
               });
           }
           setTimeout(()=>{
               codeAddress();
           },300)
       </script>
       <div>
           <input id="address" type="textbox" value="中国浙江省温州市鹿城区">
           <button onclick="codeAddress()">search</button>
       </div>
       <div style="width:603px;height:300px" id="container"></div>
       <p>输入地址，点击search进行地址解释,点击Marker会弹出反查结果。</p>
   </body>
   </html>
   ```

### 加密限制接口的访问权限

1. 拷贝加密函数到项目中
2. 修改方法实现具体加密解密操作

### 腾讯登录

#### 签约流程

1.  使用qq号登陆[qq互联](https://connect.qq.com/index.html)

   ![53875447690](.\php\1538754476901.png)

2. 互联下申请成为开发者

   ![53875734924](.\php\1538757349249.png)

3. 创建应用

   ![53875904599](.\php\1538759045998.png)

   当成为开发者后才可以创构用户

4. 选择具体应用方式

   ![53875927385](.\php\1538759273853.png)

5. 填写具体信

   ![53875942748](.\php\1538759427489.png)

   创建应用成功也需要审核.

6. 查看应用列表

7. 查看应用的appid 和 APPkey

   ![53875967543](.\php\1538759675438.png)

#### 项目中使用腾讯登录

**下载 SDK 及配置**

1. [查看文档](http://wiki.connect.qq.com/sdk%E4%B8%8B%E8%BD%BD)

   ![53876105833](.\php\1538761058339.png)

2. 下载 php 版本的 SDK 工具包

   1. SDK 目录结构

   ![53876099243](.\php\1538760992434.png)

3. 拷贝SDK到项目中

   ![53876127442](.\php\1538761274420.png)

4. 访问腾讯登录代码进行配置

   ![53876156261](.\php\1538761562614.png)

   ![53876151778](.\php\1538761517783.png)

5. 修改应用的回调地址

   ![53876167656](.\php\1538761676569.png)

6. 访问测试

   ![53876184293](.\php\1538761842939.png)

**项目中实现腾讯的登录**

 1. qq登录添加点击事件

    ![53876206254](.\php\1538762062547.png)

	2. 增加具体 de  JS 代码

    ![53876219832](.\php\1538762198327.png)

	3. 实现oauth

    ![53876243644](.\php\1538762436446.png)

	4. 实现callback

    ![53876270887](.\php\1538762708877.png)

	5. 测试授权登录

    ![53876278422](.\php\1538762784227.png)

**保存使用 qq 登录用户的信息**

1. 修改表结构

   ![53876312022](.\php\1538763120222.png)

   此处增加 openID字段标识出具体是哪一个qq号进行的登录操作, 在后期需要具体进行数据入库时, 需要判断当前的用户信息是否存在

2.  修改用户模型中的自定义字段信息.

   ![53876320335](.\php\1538763203356.png)

3. 修改 callback 方法, 实现用户信息保存

   ![53876353893](.\php\1538763538939.png)

4. 实现模型中的方法

   ![53876412146](.\php\1538764121460.png)

   ![53876414792](.\php\1538764147924.png)

### 自定义接口

#### 自定义接口案例

对于自定义接口最关键就是写接口文档. 在接口文档中规定具体的请求地址以及方式. 还有具体的参数信息.

**接口文档的书写**

| 请求地址 | websites.io/login                                            |
| -------- | ------------------------------------------------------------ |
| 请求方式 | get                                                          |
| 请求参数 | username password                                            |
| 返回结果 | 返回格式是 json / 对应的数据信息(status:具体状态标识/msg:具体提示信息/data:具体用户信息) |

**使用代码具体实现**

![53876508825](.\php\1538765088252.png)

对于自己写的接口的注意点

1. 对于姐扣扣是没有登录的验证
2. 对于接口接收的每一个参数都需要验证
3. 对于每一种情况都需要处理到
4. 对于返回的数据, 对于比较重要的数据可以不进行返回

#### 项目中使用自定义接口

**为嘛要在项目中使用自定义接口**

![53876558956](.\php\1538765589564.png)

对于项目比较多. 每一个项目所使用的数据都是相同的. 一旦有新的需求需要修改. 那么对于每一个项目都需要进行代码修改, 因此对于项目的维护成本比较高.

可以通过将项目进行拆分. 将具体的数据操作层拆分成一个单独的 API 项目. 一旦具体的项目需要具体的数据时. 直接调用 API 接口, 接下来由 API 接口来进行具体的数据操作.

对上述事宜 API 的方式将一个项目拆分为两个项目. 此方式可以使用 MVC 的方式来理解. 对于 API 就是 M 只做具体的数据操作. 具体的项目的作用就是 V和C. 接收数据展示结果. 对于具体数据操作由 API 完成.

对于自定义接口的使用API的方式对后期的性能扩展也有很大的帮助.

**配置 API 项目并操作数据**

1. 创建 Api 项目目录

   ![53876604036](.\php\1538766040369.png)

2. 拷贝 TP(ThinkPHP框架) 源代码

   ![53876610337](.\php\1538766103375.png)

3. 创建 api 项目的入口文件

   ![53876619792](.\php\1538766197925.png)

4. 修改 Apache 配置增加虚拟主机

   ![53876626190](.\php\1538766261906.png)

5. 修改域名指向信息

   ![53876630508](.\php\1538766305082.png)

6. 重启 Apache并访问生成代码

   ![53876639475](.\php\1538766394752.png)

7. 创建user控制器

   ![53876670807](.\php\1538766708078.png)

8. 创建公共控制器

   ![53876676387](.\php\1538766763877.png)

9. 增加数据库的配置信息

   ![53876680978](.\php\1538766809786.png)

10. 访问测试

    ![53876660871](.\php\1538766608712.png)

**项目中封装发送请求的函数**

在项目中一般发送请求都是使用 PHP 内置的 curl 函数进行请求发送

1. 项目中封装 curl 函数

   ![53876870607](.\php\1538768748849.png)

   ```php
   //	具体实现请求的发送. 此处使用php内置的curl 相关的函数实现
   //	想要实现请求的发送就必须指定相关的参数信息, 其中包括具体的请求地址/具体请求所携带参数信息以及具体的请求方式
   //	$url: 具体请求的url地址
   //	$data: 具体的请求所携带的参数信息
   //	$method: 具体请求方式,默认get
   function http_curl($url,$data=array(),$method='get'){
       if(!function_exists('curl_init')){
           //	不存在curl_init函数, 表示未开启 curl 扩展, 不能使用该扩展相关函数
           echo 'curl扩展未开启';exit();
       }
       //	组织函数实现请求的方式
       
       //	1. 打开会话(可以理解为mysql建立连接)
       $ch = curl_init();
       //	2. 设置参数信息 需要具体的请求地址以及参数还有请求方式
       //	设置具体请求方式. 对于curl 默认是get方式
       if($method == 'post'){
           //	设置为post请求
           curl_setopt($ch,CURLOPT_POST,true);
           //	设置请求的参数
           curl_setopt($ch,CURLOPT_POSTFIELDS,$data);
       }else{
           //	对于get方式请求的参数信息可以直接将参数添加到url地址后即可
           $url.='&'.http_build_query($data);
       }
       //	设置具体请求的url地址
       curl_setopt($ch,CURLOPT_URL,$url);
       //	将得到结果不进行输出
       curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);
       //	3. 执行具体的请求
       $res = curl_exec($ch);
       //	4. 关闭会话
       curl_close($ch);
       	//	将具体请求得到的结果转化为数组格式然后返回
       return json_decode($res,true);
   }
   ```

2. 调用:

   ![53876859440](.\php\1538768594405.png)

**项目中调用 api 接口**

1. 在项目中封装一个函数调用接口

   1. 可以简化具体接口地址的书写
   2. 对于项目中如果全部是使用接口方式进行数据操作. 如果使用接下来我们自定义函数实现 对项目后期的性能扩展有很大的帮助. 可以直接与后期的 redis/memcache 进行整合. 快速提升项目的性能.

   ```php
   //	调用接口(通过调用http_curl)进行数据操作
   //	$data: 具体的请求所携带的参数信息
   //	$method: 具体请求方式,默认get
   function get_data($data=array(),$method='get'){
       //	根据当前情况生成具体url地址
       //	规定如果要自己制定具体的接口 可以在 $data中增加两个参数 
       //	c代表具体的控制器 a代表具体的方法
       //		有时可以不指定具体的控制器及方法名称. 直接使用项目中同名的控制器及方法名称
       if(!$data['c']){
           //	说明目前没指定具体的接口的控制器名称
           $data['c'] = CONTROLLE_NAME;//	等于目前项目中的控制器名称
       }
       if(!$data['a']){
           //	说明目前没指定具体的接口的方法名称
           $data['a'] = ACTION_NAME;//	等于目前项目中的方法名称
       }
       //	需要考虑有时候请求的接口并不是自己的 api 接口项
       if($data['url']){
           $url = $data['url'];	//	具体的某一个其它接口地址
       }else{
   	    $url = 'http://api.com/index.php?m=Home&c='.$data['c'].'&a='.$data['a'];
       }
       unset($data['c']);
       unset($data['a']);
       unset($data['url']);
       
       $res = http_curl($url,$data,$method);
       return $res;
   }
   ```

2. 项目中使用接口

   ![53877084863](.\php\1538770848632.png)

**使用ip地址限制接口访问权限**

1. API 接口项目中增加方法

   ![53877145308](.\php\1538771493578.png)

2. 在构造方法中增加检查 IP

   ![53877152797](.\php\1538771527971.png)





















---

## 阿里百秀实战

### 模板的使用

> http://www.jsviews.com/#jsrapi

`jsrender` 模板的使用

```html
<script src="/static/assets/vendors/jsrender/jsrender.js"></script>		<!-- 引入模板 -->
<script id="comments_temp" type="text/x-jsrender">					   //	设置 id 和 type
{{for comments}}
<tr{{if status == 'held'}} class="warning" {{else status == 'rejected'}} class="danger"{{/if}} class="danger">
    <td class="text-center"><input type="checkbox"></td>
    <td>{{:author}}</td>
    <td>{{:content}}</td>
    <td>《{{:post_id}}》</td>
    <td>{{:created}}</td>
    <td>{{:status}}</td>
    <td class="text-center">
        <a href="post-add.html" class="btn btn-info btn-xs">批准</a>
    <a href="javascript:;" class="btn btn-danger btn-xs">删除</a>
    </td>
</tr>
{{/for}}
  
</script>
<script>	//	javascript 操作
  $tbody = $('tbody');
  $comments = $('#comments_temp');
  $.get('/admin/api/comments.php', {}, function (data) {
      var html = $comments.render({ comments: data });
      $tbody.html(html);
  })
</script>
```



### 分页组件的使用 `twbs-pagination`

> https://esimakin.github.io/twbs-pagination/



### AJAX 实现异步文件上传

```javascript
//	js部分
$avatar = $('#avatar');	//	拿到 file 的 input
$avatar.on('change', function () {
    var $this = $(this);
    var files = $this.prop('files');
    if (!files.length) return;	//	如果没有选择图片则 return
    //  选择了图片， 拿到我们要上传的文件
    var file = files[0];
    //  formData 是 HTML5 中新增的成员. 
    //  专门配合我们使用 ajax
    //  用于客户端和服务端之间进行二进制数据操作
    var data = new FormData();
    //  名 & 文件对象
    data.append('avatar', file);
    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/admin/api/upload.php');
    xhr.send(data); //借助 FormData 传递二进制
    xhr.onload = function () {	// 上传文件完毕， 执行界面上的展示操作
        //console.log(this.responseText);
        $this.siblings('img').attr('src', this.responseText);
        $('#avatar_url').val(this.responseText);
    }
})
```

```php
//	后台处理部分 upload.php 文件
<?php
//  异步图片上传基础步骤
//  接收文件
//  保存文件
//  返回文件的返回url

if (empty($_FILES['avatar'])) {
    exit('必须上头像');
}

$avatar = $_FILES['avatar'];

if ($avatar['error'] !== UPLOAD_ERR_OK) {
    exit('上传头像失败');
}

//  校验类型/大小等....
$ext = pathinfo($avatar['name'], PATHINFO_EXTENSION);
$target = '../../static/uploads/img-' . uniqid() . '.' . $ext; 

if (!move_uploaded_file($avatar['tmp_name'], $target)) {
    exit('上传失败');
}

//  上传成功
echo substr($target, 5);
```



### JSONP 跨域请求数据

必须: 目标网站允许允许我们进行跨域请求.

```js
$.ajax({
    url:'http://api.douban.com/v2/movie/in_theaters',
    dataType: 'jsonp',
    success(res) {
        console.log(res.subjects);
    }
})
```







